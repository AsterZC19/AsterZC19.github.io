<!-- build time:Mon Sep 05 2022 21:33:30 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,学习笔记"><link rel="canonical" href="https://asterzc19.github.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>网络流 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">网络流</h1><div class="meta"><span class="item" title="创建时间：2022-08-19 18:00:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-08-19T18:00:20+08:00">2022-08-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>28k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>25 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/79181978dd20d35c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/44d29b2c5b4e40c8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/db894a8df07c1517.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/848d77945ce37428.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p><strong>网络流</strong>是算法竞赛中的一个重要的<strong>模型</strong>，它分为两部分：网络和流。<br>学习自 Pecco、OI Wiki</p></blockquote><span id="more"></span><hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><p>首先，请分清楚 <strong>网络</strong>（或者流网络，Flow Network）与 <strong>网络流</strong>（Flow）的概念。</p></li><li><p>网络是指一个有向图 $G ; &#x3D; ; (V, ;E)$ 。</p></li><li><p>每条边都有一个权值 ，称之为容量（Capacity）。</p></li><li><p>其中有两个特殊的点：源点（Source） 和汇点（Sink）。</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-37f837b113bbcb3fe54ce54fd9040832_720w.jpg"></p></li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><strong>流</strong>，顾名思义，就像水流或电流，也具有它们的性质。如果把网络想象成一个自来水管道网络，那流就是其中流动的水。每条边上的流不能超过它的容量，并且对于除了源点和汇点外的所有点（即中继点），流入的流量都等于流出的流量。</li></ul><h1 id="网络流的常见问题"><a href="#网络流的常见问题" class="headerlink" title="网络流的常见问题"></a>网络流的常见问题</h1><ul><li><p>网络流问题中常见的有以下三种：最大流，最小割，费用流。</p></li><li><p>而最常见的问题就是<strong>网络最大流</strong>。假定从源点流出的流量足够多，求能够流入汇点的最大流量。例如对上面那张网络而言，最大流是5，其中1-&gt;3提供2流量，1-&gt;2-&gt;3提供2流量（这有点像木桶原理，某条路径的容量是由最窄的一根水管决定的），1-&gt;2-&gt;4-&gt;3提供1流量（注意这里不是2，因为上条路径已经占用了1-&gt;2的2单位容量，只剩1单位容量可用）。</p></li></ul><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><ul><li>我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。</li></ul><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><ul><li>最小费用最大流问题是这样的：每条边都有一个费用，代表单位流量流过这条边的开销。我们要在求出最大流的同时，要求花费的费用最小。</li></ul><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><ul><li>割其实就是删边的意思，当然最小割就是割掉 $X$ 条边来让  $S$ 跟 $T$ 不互通。我们要求 $X$ 条边加起来的流量总和最小。这就是最小割问题。</li></ul><h1 id="最大流-1"><a href="#最大流-1" class="headerlink" title="最大流"></a>最大流</h1><h2 id="Ford-Fulkerson-算法"><a href="#Ford-Fulkerson-算法" class="headerlink" title="Ford-Fulkerson 算法"></a>Ford-Fulkerson 算法</h2><ul><li><p>通常用于解决网络最大流。</p></li><li><p>FF算法的核心在于找<strong>增广路</strong>。何谓增广路？例如上图中我首先选择1-&gt;2-&gt;3，这是一条增广路，提供2流量；然后我们相应地<strong>扣除</strong>选择路径上各边的容量，1-&gt;2的容量变成1，2-&gt;3的容量变成0，这时的容量称为<strong>残余容量</strong>。然后我们再找到1-&gt;2-&gt;4-&gt;3这条路径，按残余容量计算流量，它提供1流量（选择这两条路的顺序可以颠倒）。1-&gt;2-&gt;4-&gt;3也是一条增广路。</p></li><li><p><strong>增广路</strong>，是从源点到汇点的路径，其上所有边的残余容量均大于0。FF算法就是不断寻找增广路，直到找不到为止。这个算法不一定正确，可以构造一张图让其出错。</p></li><li><p>为了解决这个错误，我们引入 <strong>反向边</strong>。在建边的同时，在反方向建一条边权为 0 的边。</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-1c4016f73a2e94109fbb8769a1e88566_720w.jpg"></p></li><li><p>我们仍然选择1-&gt;2-&gt;3-&gt;4，但在扣除正向边的容量时，反向边要<strong>加上</strong>等量的容量。</p></li><li><p><img data-src="https://pic4.zhimg.com/80/v2-f19ff404a0932ca1d6bdf713403142cf_720w.jpg"></p></li><li><p>这时我们可以另外找到一条增广路：1-&gt;3-&gt;2-&gt;4。</p></li><li><p>现在我们同时选择了2-&gt;3和3-&gt;2两条边，我们可以认为，这两条边上的水流 <strong>抵消</strong> 了。所以实际上选择的路径就是1-&gt;3-&gt;4和1-&gt;2-&gt;4。</p></li><li><p>其实可以把反向边理解成一种 <strong>撤销</strong>，走反向边就意味着撤回上次流经正向边的若干流量，这也合理解释了为什么扣除正向边容量时要给反向边加上相应的容量：反向边的容量意味着可以撤回的量。</p></li><li><p>加入了反向边这种反悔机制后，我们就可以保证，当找不到增广路的时候，流到汇点的流量就是最大流。</p></li><li><p>用 dfs 实现的 FF 算法时间复杂度上界是 $O(ef)$ ，其中 $e$ 为边数，$f$ 为最大流：</p></li></ul><pre><code class="cpp">int n, m, s, t;     // s 源点，t 汇点
bool vis[N];
int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t)&#123;
        return flow;    // 返回这条增广路的流量
    &#125;
    vis[u] = 1;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i], c;
        // 返回的条件是残余容量大于 0，未访问过该点且接下来可以到达终点
        // 传递下去的流量是边的容量与当前流量中的较小值
        if(v &gt; 0 &amp;&amp; !vis[j] &amp;&amp; (c = dfs(j, min(v, flow))) != -1)&#123;
            w[i] -= c;
            w[i ^ 1] += c;
            return c;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre><ul><li>这个算法的复杂度上界非常高，仍有很多优化空间。</li></ul><h2 id="Edmond-Karp-算法"><a href="#Edmond-Karp-算法" class="headerlink" title="Edmond-Karp 算法"></a>Edmond-Karp 算法</h2><ul><li>EK 算法就是 BFS 实现的 FF 算法。</li></ul><pre><code class="cpp">int n, m, s, t;     // s 源点，t 汇点
int last[N], flow[N];
inline int bfs()&#123;
    memset(last, -1, sizeof(last));
    queue&lt;int&gt; q;
    q.push(s);
    flow[s] = 0x3f3f3f3f;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        if(u == t) break;
        for(int i = h[u]; ~i; i = ne[i])&#123;
            int j = e[i], v = w[i];
            if(v &gt; 0 &amp;&amp; last[j] == -1)&#123;
                 // 如果残余容量大于 0 且未访问过（所以 last 保持在 -1 ）
                last[j] = i;
                flow[j] = min(flow[u], v);
                q.push(j);
            &#125;
        &#125;
    &#125;
    return last[t] != -1;
&#125;
inline int EK()&#123;
    int maxflow = 0;
    while(bfs())&#123;
        maxflow += flow[t];
        for(int i = t; i != s; i = e[last[i] ^ 1])&#123;
            // 从汇点原路返回更新残余容量
            w[last[i]] -= flow[t];
            w[last[i] ^ 1] += flow[t];
        &#125;
    &#125;
    return maxflow;
&#125;
</code></pre><ul><li>为什么在这里 BFS 通常比 DFS 的效果好？因为 DFS 很可能会“绕远路”，而 BFS 可以保证每次找到的都是最短的增广路。它的复杂度上限是 $O(ve^2)$ ，其中 $v$ 为点数。这个算法至少与流的大小无关了，算是多项式算法了，让人稍微安心了一点……</li></ul><h2 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h2><ul><li><p>然而，最常用的网络流算法是 Dinic 算法。作为 FF&#x2F;EK 算法的优化，它选择了先用BFS <strong>分层</strong>，再用 DFS 寻找。它的时间复杂度上界是 $O(v^2e)$ 。所谓分层，其实就是预处理出源点到每个点的距离（注意每次循环都要预处理一次，因为有些边可能容量变为 0 不能再走）。我们只往层数高的方向增广，可以保证不走回头路也不绕圈子。</p></li><li><p>我们可以使用 <strong>多路增广</strong> 节省很多花在重复路线上的时间：在某点 DFS 找到一条增广路后，如果还剩下多余的流量未用，继续在该点 DFS 尝试找到更多增广路。</p></li><li><p>此外还有<strong>当前弧优化</strong>。因为在Dinic算法中，一条边增广一次后就不会再次增广了，所以下次增广时不需要再考虑这条边。我们把 head 数组复制一份，但不断更新增广的起点。</p></li></ul><pre><code class="cpp">int n, m, s, t, lv[N], cur[N];      // lv是 每个点的层数，cur 用于当前弧优化标记增广起点
inline bool bfs()&#123;      // bfs 分层
    memset(lv, -1, sizeof(lv));
    queue&lt;int&gt; q;
    q.push(s);
    lv[s] = 0;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        for(int i = h[u]; ~i; i = ne[i])&#123;
            int j = e[i], v = w[i];
            if(v &gt; 0 &amp;&amp; lv[j] == -1)&#123;
                lv[j] = lv[u] + 1;
                q.push(j);
            &#125;
        &#125;
    &#125;
    return lv[t] != -1;     // 如果汇点未访问过说明已经无法达到汇点，此时返回 false
&#125;
int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int i = cur[u]; ~i; i = ne[i])&#123;
        cur[u] = i;     // 当前弧优化, 更新当前弧
        int j = e[i], v = w[i];
        if(v &gt; 0 &amp;&amp; lv[j] == lv[u] + 1)&#123;    // 往层数高的方向增广
            int c = dfs(j, min(remain, v)); // 尽可能多地传递流量
            remain -= c;    // 剩余流量减少
            w[i] -= c;     // 更新残余容量
            w[i ^ 1] += c; // 增加剩余流量
        &#125;
    &#125;
    return flow - remain;   // 返回传递出去的流量的大小
&#125;
inline int dinic()&#123;
    int ans = 0;
    memcpy(cur, h, sizeof(h));  // 当前狐优化初始化
    while(bfs())&#123;
        ans += dfs();
        memcpy(cur, h, sizeof(h));  // 当前狐优化初始化
    &#125;
    return ans;
&#125;
</code></pre><ul><li><p>值得注意的是，这个算法如果用在二分图中复杂度是 $O(v;\sqrt e)$ ，优于<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NjIyOTcwMA==">匈牙利算法</span>。</p></li><li><p>这里再提一下<strong>最大流最小割定理</strong>。所谓<strong>割</strong>，就是从网络中选择一些边，使得去掉这些边后，剩下两个不连通的分别包含源点和汇点的点集。割的大小是这些边的容量之和。在所有可行的割中，最小的割称为<strong>最小割</strong>。</p></li><li><p>这个神奇的定理只有短短几个字：<strong>最大流等于最小割</strong>。</p></li></ul><hr><h3 id="P3376-网络最大流"><a href="#P3376-网络最大流" class="headerlink" title="P3376 | 网络最大流"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzY=">P3376 | 网络最大流</span></h3><ul><li>模板题</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1210, M = 250010;
int h[N], e[M], ne[M], w[M], idx;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int n, m, s, t, lv[N], cur[N];
inline bool bfs()&#123;
    memset(lv, -1, sizeof(lv));
    memcpy(cur, h, sizeof(h));
    queue&lt;int&gt; q;
    q.push(s);
    lv[s] = 0;
    while(!q.empty())&#123;
        int u = q.front(); q.pop();
        for(int i = cur[u]; i != -1; i = ne[i])&#123;
            int j = e[i], v = w[i];
            if(v &gt; 0 &amp;&amp; lv[j] == -1)&#123;
                lv[j] = lv[u] + 1;
                q.push(j);
            &#125;
        &#125;
    &#125;
    return lv[t] != -1;
&#125;
int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i];
        if(v &gt; 0 &amp;&amp; lv[j] == lv[u] + 1)&#123;
            int tmp = dfs(j, min(remain, v));
            remain -= tmp;
            w[i] -= tmp;
            w[i ^ 1] += tmp;
        &#125;
    &#125;
    return flow - remain;
&#125;
inline int dinic()&#123;
    int ans = 0;
    while(bfs())&#123;
        ans += dfs();
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt;= m; i++)&#123;
        int u, v, c;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;
        add(u, v, c);
        add(v, u, 0);  // 反向边边权为 0
    &#125;
    cout &lt;&lt; dinic() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h2 id="二者取一式问题"><a href="#二者取一式问题" class="headerlink" title="二者取一式问题"></a>二者取一式问题</h2><ul><li><p>二者取一式问题可以这样描述：将若干元素 $e1, e2,…,en$ 划分到两个集合 $A,B$ 中。对于元素 $e_i$ ，它被划分到 $A$ 或 $B$ 中分别能获得一个 $a_{e_i}$ 或 $b_{e_i}$ 的分值。除此之外，还给出若干个组合 $C_i ;⊆;A$ ，当组合中的元素被同时划分到 $A$ 或 $B$ 时，可以获得额外的分值 $a_i^′$ 或 $b_i^′$ 。求最大的分值。</p></li><li><p>这个问题可以被转化为网络流中的<strong>最小割</strong>问题。如果我们把 $A$ 作为源点， $B$ 作为汇点，那么这个网络的一个<strong>割</strong>就是一种划分方法。如果没有组合的话，我们很容易就能建出这样的模型：</p></li><li><p><img data-src="https://pic4.zhimg.com/80/v2-8ca41bb30358f5b4d95addf974e497c7_720w.jpg"></p></li><li><p>当我们去割它时，与A连通的点代表放到 $A$ 集合中，与B连通的点代表放到 $B$ 集合中。当这个割是最小割时，剩下的边的容量和是最大的，故设最小割为 <code>cut</code>，边权总和为 <code>sum</code>，则所求最大分值为 <code>sum-cut</code>。</p></li><li><p>现在我们考虑组合。假设 $C_1&#x3D;{e_1,e_2}$ ，且对应的额外分值为 $a_1^′$ 和 $b_1^′$ 。我们从 $A$ 点伸出一条容量为 $a_1^′$ 的边通向虚点 $X$ ：</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-7d33e345ace0c6873f633477c30ad9ba_720w.jpg"></p></li><li><p>现在我们的需求是：只有当1、2点都被归入 $A$ 所在点集时，$X$ 才与 $A$ 连通。</p></li><li><p>反过来想，当 1 被归入 $B$ 所在点集时，要让 $A-&gt;X$ 被割掉。很自然地想到，让 $X$ 连向 1，这样当 1 被归入 $B$ 所在点集时，$A-&gt;X-&gt;1$ 必然会断，否则 $A$ 就与 $B$ 连通了。但如何确保割掉的是 $A-&gt;X$ 而不是 $X-&gt;1$ 呢？只要令 $X-&gt;1$ 的容量为$INF$ 即可，无穷大边不会被割掉。2 号点同理。</p></li><li><p><img data-src="https://pic4.zhimg.com/80/v2-3f06c22d87598fc1b5c1774376d303c3_720w.jpg"></p></li><li><p>好了，这就是我们需要的模型。这时我们求最小割 <code>cut</code>，并记非无穷边权和为 <code>sum</code>，那么跟刚刚一样，<code>sum-cut</code> 就是所求分数。</p></li></ul><h3 id="P1361-小M的作物"><a href="#P1361-小M的作物" class="headerlink" title="P1361 | 小M的作物"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEzNjE=">P1361 | 小M的作物</span></h3><ul><li>标准的二者取一式问题。</li><li>调整了初始化 <code>cur</code> 数组的位置，否则会导致 tle</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1510, M = 2e6 + 10;
int h[N &lt;&lt; 1], e[M], ne[M], w[M], idx;
inline void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
inline int read()&#123;
    int x = 0, f = 1; char ch = getchar();
    while(!isdigit(ch))&#123;if(ch == &#39;-&#39;) f = -1; ch = getchar();&#125;
    while(isdigit(ch)) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
    return x * f;
&#125;
int n, m, s, t, lv[N &lt;&lt; 1], cur[N &lt;&lt; 1];
inline bool bfs()&#123;
    memset(lv, -1, sizeof(lv));
    queue&lt;int&gt; q;
    q.push(s);
    lv[s] = 0;
    while(!q.empty())&#123;
        int u = q.front(); q.pop();
        for(int i = cur[u]; i != -1; i = ne[i])&#123;
            int j = e[i], v = w[i];
            if(lv[j] == -1 &amp;&amp; v &gt; 0)&#123;
                lv[j] = lv[u] + 1;
                q.push(j);
            &#125;
        &#125;
    &#125;
    return lv[t] != -1;
&#125;
inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i];
        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;
            int tmp = dfs(j, min(remain, v));
            remain -= tmp;
            w[i] -= tmp;
            w[i ^ 1] += tmp;
            if(!remain)&#123;
                break;
            &#125;
        &#125;
    &#125;
    return flow - remain;
&#125;
inline int dinic()&#123;
    int ans = 0;
    memcpy(cur, h, sizeof(h));
    while(bfs())&#123;
        //int tmp;
        ans += dfs();
        memcpy(cur, h, sizeof(h));
    &#125;
    return ans;
&#125;
int main()&#123;
    //cin.tie(0)-&gt;sync_with_stdio(false);
    n = read();
    s = 0, t = n + 1;
    int sum = 0, cnt = t;
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt;= n; i++)&#123;
        int x = read();
        add(0, i, x);
        add(i, 0, 0);
        sum += x;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x = read();
        add(i, n + 1, x);
        add(n + 1, i, 0);
        sum += x;
    &#125;
    cin &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int k = read(), a = read(), b = read();
        add(0, ++cnt, a);
        add(cnt, 0, 0);
        add(++cnt, n + 1, b);
        add(n + 1, cnt, 0);
        sum += a + b;
        while(k--)&#123;
            int c = read();
            add(cnt - 1, c, 0x3f3f3f3f);
            add(c, cnt - 1, 0);
            add(c, cnt, 0x3f3f3f3f);
            add(cnt, c, 0);
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, sum - dinic());
&#125;
</code></pre><h2 id="路径覆盖问题"><a href="#路径覆盖问题" class="headerlink" title="路径覆盖问题"></a>路径覆盖问题</h2><ul><li><p>这里说的路径覆盖，是在 <strong>DAG</strong>（有向无环图）上进行的，是指用找出尽可能少的一系列路径，使这些路径经过 DAG 上的所有点恰好各一次。</p></li><li><p>我们可以使用下面这样的思路：最开始，把每个点自己作为一条路径（这时一共有 $n$ 条路径），然后不断地将已有的路径<strong>首尾相连</strong>，合并成更长的路径，直到所有点被覆盖为止。</p></li><li><p>接下来，我们以这张DAG为例：</p></li><li><p><img data-src="https://pic1.zhimg.com/80/v2-cf1624121bc7f130adc1bb859c6c22f4_720w.jpg"></p></li><li><p>建网络流模型。我们把原图上的每个点<strong>拆</strong>成两个点（对于点<code>x</code>，可以把从它拆出去的点记为<code>x+n</code>），其中一个点与源点相连，另一个与汇点相连。</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-8be6911cfe0dff2357ef750e93487466_720w.jpg"></p></li><li><p>然后对于原 DAG 上的边 $A-&gt;B$，我们在网络中连接上 $A-&gt;B’$：</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-9115ac6cc2e0dd24ff8cb08bcc55694e_720w.jpg"></p></li><li><p>这里每一条边的容量均为 $1$。现在我说：跑一遍最大流，便能得到最大合并路径数，再用点数去减即得最小路径覆盖数。这几乎是显然的：从 $A$ 点到 $B’$ 点的每一条流，都代表着一次合并。而从源点只给每个点输送 $1$ 单位流量，又保证了每个点只被经过一次。</p></li><li><p>实际上，这里本质上就是二分图匹配，所以用<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NjIyOTcwMA==">匈牙利算法</span>也是可以的，复杂度略差一点。</p></li></ul><h3 id="P2764-最小路径覆盖问题"><a href="#P2764-最小路径覆盖问题" class="headerlink" title="P2764 | 最小路径覆盖问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI3NjQ=">P2764 | 最小路径覆盖问题</span></h3><ul><li>这道题有个麻烦点在于，需要输出方案。</li><li>如何输出方案？一种思路是在跑完最大流后再 dfs 一遍，但那样未免麻烦，我们其实可以在增广途中就用一个数组 <code>nxt[]</code> 记录每个点的下一个点。例如，如果使用 Dinic算法，可以在 dfs 函数内部稍微加两句：</li></ul><pre><code class="cpp">inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i];
        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;
            int c = dfs(j, min(remain, v));
            remain -= c;
            w[i] -= c;
            w[i ^ 1] += c;
            if(c)&#123;  // 只有增广成功才修改 nxt
                nxt[u] = j - n;
                // 如果选择用 x+n 记录从点 x 拆出的点，这里就这样写，记录下一个点
            &#125;
        &#125;
    &#125;
    return flow - remain;
&#125;
</code></pre><ul><li>然后遍历起点，分别找到对应的路径输出：</li></ul><pre><code class="cpp">for(int i = h[t]; ~i; i = ne[i])&#123;
    if(w[i ^ 1])&#123;
        int p = e[i] - n;
        while(p != s)&#123;
            cout &lt;&lt; p &lt;&lt; &#39; &#39;;
            p = nxt[p];
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><ul><li><p>这个遍历起点的方式可以注意一下。什么样的点是起点呢？如果 $A’$ 到汇点的边的残余容量为 $1$，说明没有点流向 $A’$ 点，也就是说 $A$ 是起点。</p></li><li><p>完整代码</p></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 310, M = 2e4 + 10;
int h[N], e[M], ne[M], w[M], idx;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int n, m, s, t, lv[N], cur[N];
inline bool bfs()&#123;
    memset(lv, -1, sizeof(lv));
    queue&lt;int&gt; q;
    q.push(s);
    lv[s] = 0;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int j = e[i], v = w[i];
            if(lv[j] == -1 &amp;&amp; v &gt; 0)&#123;
                lv[j] = lv[u] + 1;
                q.push(j);
            &#125;
        &#125;
    &#125;
    return lv[t] != -1;
&#125;
int nxt[N];
inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i];
        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;
            int c = dfs(j, min(remain, v));
            remain -= c;
            w[i] -= c;
            w[i ^ 1] += c;
            if(c)&#123;  // 只有增广成功才修改 nxt
                nxt[u] = j - n;
                // 如果选择用 x+n 记录从点 x 拆出的点，这里就这样写，记录下一个点
            &#125;
        &#125;
    &#125;
    return flow - remain;
&#125;
inline int dinic()&#123;
    int ans = 0;
    memcpy(cur, h, sizeof(h));
    while(bfs())&#123;
        ans += dfs();
        memcpy(cur, h, sizeof(h));
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    s = 0, t = 2 * n + 1;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b + n, 1);
        add(b + n, a, 0);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        add(s, i, 1);
        add(i, s, 0);
        add(i + n, t, 1);
        add(t, i + n, 0);
    &#125;
    int ans = dinic();
    for(int i = h[t]; ~i; i = ne[i])&#123;
        if(w[i ^ 1])&#123;
            int p = e[i] - n;
            while(p != s)&#123;
                cout &lt;&lt; p &lt;&lt; &#39; &#39;;
                p = nxt[p];
            &#125;
            cout &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    cout &lt;&lt; n - ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="P2765-魔术球问题"><a href="#P2765-魔术球问题" class="headerlink" title="P2765 | 魔术球问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI3NjU=">P2765 | 魔术球问题</span></h3><ul><li><p>这题乍一看跟网络流关系不大（好像也确实有其他做法），但如果我们把每根柱子看作一条路径，和为完全平方数的关系看作一条边的话，这完全就是DAG的路径覆盖问题了：</p></li><li><p><img data-src="https://pic2.zhimg.com/80/v2-28f84cb18d1c6082bb7ec61cead634b5_720w.jpg"></p></li><li><p>因为 $n$ 的范围很小，我们只需要一步一步建图，每添加一个新点就求一次最大流。如果某时刻求出的最小路径覆盖已经超过了 $n$ ，那说明加入这个点前的点的数量就是答案。</p></li><li><p>这个题还有一个小坑点，拆点时不能拆成 $x$ 和 $x+n$ ，因为这道题里的 $n$ 并不是点数，而是路径数。</p></li><li><p>完整代码</p></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 4010, M = 4e5 + 10, INF = 0x3f3f3f3f;
int h[N], e[M], ne[M], w[M], idx;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, w[idx] = 0, ne[idx] = h[b], h[b] = idx++;
&#125;
int n, s, t, lv[N], cur[N];
inline bool bfs()&#123;
    memset(lv, -1, sizeof(lv));
    queue&lt;int&gt; q;
    q.push(s);
    lv[s] = 0;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int j = e[i], v = w[i];
            if(lv[j] == -1 &amp;&amp; v &gt; 0)&#123;
                lv[j] = lv[u] + 1;
                q.push(j);
            &#125;
        &#125;
    &#125;
    return lv[t] != -1;
&#125;
int nxt[N];
inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i];
        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;
            int c = dfs(j, min(remain, v));
            remain -= c;
            w[i] -= c;
            w[i ^ 1] += c;
            if(c)&#123;
                nxt[u] = j &gt;&gt; 1;
            &#125;
        &#125;
    &#125;
    return flow - remain;
&#125;
inline int dinic()&#123;
    int ans = 0;
    memcpy(cur, h, sizeof(h));
    while(bfs())&#123;
        ans += dfs();
        memcpy(cur, h, sizeof(h));
    &#125;
    return ans;
&#125;
inline bool check(int x)&#123;
    int ans = sqrt(x);
    if(ans * ans == x) return true;
    return false;
&#125;
int pre[N &lt;&lt; 2], ans[N &lt;&lt; 2];
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    s = 0, t = 1;
    memset(h, -1, sizeof(h));
    int num = 0, tot = 0;
    while(1)&#123;
        tot++, num++;
        add(s, num &lt;&lt; 1, 1);
        add(num &lt;&lt; 1 | 1, t, 1);
        for(int i = 1; i &lt; num; i++)&#123;
            if(check(i + num))&#123;
                add(i &lt;&lt; 1, num &lt;&lt; 1 | 1, 1);
            &#125;
        &#125;
        tot -= dinic();
        /*
            dinic每次求出新增加的最大匹配
            dinic()==1，新加入的num和之前的数字匹配成功，放在了以前的柱子上
                用tot-dinic相当于去掉了新加入的没用的柱子
            dinic()==0，新加入的num和之前的数字无法匹配，放到新加入的柱子上
        */
        if(tot &gt; n) break;
    &#125;
    memset(pre, -1, sizeof(pre));
    cout &lt;&lt; num - 1 &lt;&lt; &#39;\n&#39;;
    for(int i = 1; i &lt;= num - 1; i++)&#123;
        int u = i &lt;&lt; 1;     // 左点
        for(int j = h[u]; ~j; j = ne[j])&#123;
            int k = e[j], v = w[j ^ 1];
            if(v &gt; 0 &amp;&amp; k &gt;&gt; 1)&#123;
                pre[k &gt;&gt; 1] = i;
                ans[i] = k &gt;&gt; 1;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= num - 1; i++)&#123;
        if(pre[i] &lt; 0)&#123;    // 判断起点
            int x = i;
            cout &lt;&lt; x &lt;&lt; &quot; &quot;;
            while(ans[x])&#123;
                cout &lt;&lt; ans[x] &lt;&lt; &quot; &quot;;
                x = ans[x];
            &#125;
            cout &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><h1 id="最小割-1"><a href="#最小割-1" class="headerlink" title="最小割"></a>最小割</h1><ul><li><p>对于一个网络流图 $G; &#x3D;; (V, E)$，其割的定义为一种 <strong>点的划分方式</strong>：将所有的点划分为 $S$ 和 $T$ 两个集合，其中源点 $s \in S$ ，汇点 $t \in T$。</p></li><li><p>最小割就是求得一个割，使得割的容量最小。</p></li><li><p><strong>最大流最小割定理</strong> ：<span class="exturl" data-url="aHR0cHM6Ly9vaXdpa2kub3JnL2dyYXBoL2Zsb3cvbWluLWN1dC8jXzU=">证明</span></p></li></ul><h2 id="割边数量"><a href="#割边数量" class="headerlink" title="割边数量"></a>割边数量</h2><ul><li>如果需要在最小割的前提下最小化割边数量，那么先求出最小割，把没有满流的边容量改成 ，满流的边容量改成 ，重新跑一遍最小割就可求出最小割边数量；如果没有最小割的前提，直接把所有边的容量设成 ，求一遍最小割就好了。</li></ul><h2 id="二者取一式问题-1"><a href="#二者取一式问题-1" class="headerlink" title="二者取一式问题"></a>二者取一式问题</h2><ul><li>于此不再赘述，同上网络流。</li></ul><h3 id="P2774-方格取数问题"><a href="#P2774-方格取数问题" class="headerlink" title="P2774 | 方格取数问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI3NzQ=">P2774 | 方格取数问题</span></h3><ul><li>题意<ul><li>有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</li></ul></li><li>分析<ul><li>相邻时，横坐标或纵坐标相差仅为 1，所以两个相邻点的横纵坐标之和的奇偶性不同。</li><li>因此，奇偶性相同的点必然不互斥，把互斥的点连边就会形成一个二分图。</li><li>为了实现能删掉一个元素，表示不取这个格子，且删掉的代价就是方格的权值，还能实现反悔，所以使用最小割。</li><li>源点连向二分图的一个点集（横纵坐标之和为奇数的那些方格），边权为点权。删一条边表示不取这个方格。</li><li>二分图的另一个点集连向超级汇，边权还是点权。删边也表示不取此点。</li><li>二分图内部的边，连接着互斥的点。边权全部赋为 $INF$，以保证在最小割中不被删。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e4 + 10, M = 1e5 + 10;
int h[N], e[M], w[M], ne[M], idx;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int n, m, s, t, lv[N], cur[N];
inline bool bfs()&#123;
    memset(lv, -1, sizeof(lv));
    queue&lt;int&gt; q;
    q.push(s);
    lv[s] = 0;
    while(q.size())&#123;
        int u = q.front();
        q.pop();
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(w[i] &gt; 0 &amp;&amp; lv[j] == -1)&#123;
                lv[j] = lv[u] + 1;
                q.push(j);
            &#125;
        &#125;
    &#125;
    return lv[t] != -1;
&#125;
inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    int remain = flow;
    for(int&amp; i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], v = w[i];
        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;
            int k = dfs(j, min(remain, v));
            w[i] -= k;
            w[i ^ 1] += k;
            remain -= k;
        &#125;
    &#125;
    return flow - remain;
&#125;
inline int dinic()&#123;
    int ans = 0;
    memcpy(cur, h, sizeof(h));
    while(bfs())&#123;
        ans += dfs();
        memcpy(cur, h, sizeof(h));
    &#125;
    return ans;
&#125;
inline int getid(int x, int y)&#123;
    return (x - 1) * m + y;
&#125;
int dx[4] = &#123;0, 0, 1, -1&#125;, dy[4] = &#123;1, -1, 0, 0&#125;;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    s = 0, t = n * m + 1;
    LL sum = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            int x;
            cin &gt;&gt; x;
            sum += x;
            int id = getid(i, j);
            if((i + j) &amp; 1)&#123;
                add(s, id, x);
                add(id, s, 0);
                for(int k = 0; k &lt; 4; k++)&#123;
                    int nx = i + dx[k], ny = j + dy[k];
                    if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) continue;
                    int nid = getid(nx, ny);
                    add(id, nid, 0x3f3f3f3f);
                    add(nid, id, 0);
                &#125;
            &#125;else&#123;
                add(id, t, x);
                add(t, id, 0);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; sum - dinic() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h2 id="最大权值闭合图"><a href="#最大权值闭合图" class="headerlink" title="最大权值闭合图"></a>最大权值闭合图</h2><ul><li><p>最大权值闭合图，即给定一张有向图，每个点都有一个权值（可以为正或负或 0 ），你需要选择一个权值和最大的子图，使得子图中每个点的后继都在子图中。</p></li><li><p>做法：建立超级源点 $s$ 和超级汇点 $t$，若节点 $u$ 权值为正，则 $s$ 向 $u$ 连一条有向边，边权即为该点点权；若节点 $u$ 权值为负，则由 $u$ 向 $t$ 连一条有向边，边权即为该点点权的相反数。原图上所有边权改为 $INF$ 。跑网络最大流，将所有正权值之和减去最大流，即为答案。</p></li></ul><h1 id="最小费用最大流-1"><a href="#最小费用最大流-1" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h1><ul><li><p>我们现在来考虑比一般的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjIzNzU1MzE=">网络流</span>复杂一点的一个模型：<strong>最小费用最大流</strong>（<em>Minimum Cost Maximum Flow，</em><strong>MCMF</strong>）。</p></li><li><p>现在网络上的每条边，除了容量外，还有一个属性：<strong>单位费用</strong>。一条边上的费用等于流量×单位费用。我们知道，网络最大流往往可以用多种不同的方式达到，所以现在要求：在保持流最大的同时，找到总费用最少的一种。</p></li><li><p>如下图，有多种方式可以达到最大流 3，但是 S-&gt;3-&gt;T (2) + S-&gt;3-&gt;2-&gt;T (1) 这种流法的费用是 7×2+5×1&#x3D;<strong>19</strong>，而 S-&gt;3-&gt;T (2) + S-&gt;1-&gt;2-&gt;T (1) 这种流法的费用则是7×2+4×1&#x3D;<strong>18</strong>，后者比前者的费用更低。事实上，后者正是这个网络的最小费用最大流。</p></li><li><p><img data-src="https://pic4.zhimg.com/80/v2-5d0c4b670cfeb4927613e780ffe206fb_720w.jpg"></p></li><li><p>其实这个问题很好解决。我们已经知道，只要建了反向边，无论增广的顺序是怎样，都能求出最大流。所以我们只需要每次都增广费用最少的一条路径即可。</p></li></ul><h2 id="SSP-算法"><a href="#SSP-算法" class="headerlink" title="SSP 算法"></a>SSP 算法</h2><ul><li><p>SSP（Successive Shortest Path）算法是一个贪心的算法。它的思路是每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p></li><li><p>如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。此时需要先使用消圈算法消去图上的负圈。</p></li><li><p>只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。</p></li><li><p>具体地，把<strong>EK算法</strong> 里的BFS换成 SPFA :</p></li></ul><pre><code class="cpp">int h[N], e[M], ne[M], w[M], c[M], idx;     // 新增一维费用
void add(int a, int b, int x, int y)&#123;
    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;
&#125;
int n, m, s, t, last[N], flow[N], dis[N];
bool st[N];
bool spfa()&#123;
    queue&lt;int&gt; q;
    memset(dis, 0x3f, sizeof(dis));
    memset(last, -1, sizeof(last));
    memset(st, 0, sizeof(st));
    flow[s] = INF;
    dis[s] = 0;
    q.push(s);
    while(q.size())&#123;
        int u = q.front(); q.pop();
        st[u] = 0;
        for(int i = h[u]; ~i; i = ne[i])&#123;
            int j = e[i], x = w[i], y = c[i];
            if(dis[j] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;       // 容量大于0才增广
                dis[j] = dis[u] + y;
                flow[j] = min(flow[u], x);
                last[j] = i;
                if(!st[j])&#123;
                    st[j] = 1;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    return last[t] != -1;
&#125;
inline pair&lt;int, int&gt; MCMF()&#123;
    int maxflow = 0, mincost = 0;
    while(spfa())&#123;
        maxflow += flow[t];
        mincost += flow[t] * dis[t];
        for(int i = t; i != s; i = e[last[i] ^ 1])&#123;
            w[last[i]] -= flow[t];
            w[last[i] ^ 1] += flow[t];
        &#125;
    &#125;
    return &#123;maxflow, mincost&#125;;
&#125;
int main()&#123;
    // 建边
    int u, v, a, b;
    add(u, v, a, b);
    add(v, u, 0, -b);
&#125;
</code></pre><ul><li><p>反向边的费用是正向边的相反数（只要你知道建反向边的目的，这应该是显然的）。</p></li><li><p>这和一般的EK算法没多大区别，毕竟SPFA可以看作一种特殊的BFS。当然，也可以把EK用<strong>dinic</strong>取代，这样有时会有很大优化，有时不太明显。（dinic是否采用当前弧优化也比较玄学，有时候不用当前弧优化反而更快。）</p></li><li><p>下为 Dinic 算法实现</p></li></ul><pre><code class="cpp">int h[N], e[M], ne[M], w[M], c[M], idx;     // 新增一维费用
void add(int a, int b, int x, int y)&#123;
    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;
&#125;
int n, m, s, t, dis[N];
int cur[N];
bool st[N], vis[N];
inline bool spfa()&#123;
    queue&lt;int&gt; q;
    fill(dis, dis + N, INF);
    copy(cur, cur + N, h);
    dis[s] = 0;
    q.push(s);
    st[s] = true;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        st[u] = false;
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int j = e[i], x = w[i], y = c[i];
            if(dis[j] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;
                dis[j] = dis[u] + y;
                if(!st[j])&#123;
                    st[j] = true;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    return dis[t] != INF;
&#125;
inline int dfs(int u = s, int flow = INF)&#123;
    if(u == t) return flow;
    vis[u] = true;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], x = w[i], y = c[i];
        if(!vis[j] &amp;&amp; dis[j] == dis[u] + y &amp;&amp; x &gt; 0)&#123;
            int c = dfs(j, min(remain, x));
            remain -= c;
            w[i] -= c;
            w[i ^ 1] += c;
        &#125;
    &#125;
    vis[u] = false;
    return flow - remain;
&#125;
inline pair&lt;int, int&gt; dinic()&#123;
    int maxflow = 0, mincost = 0;
    while(spfa())&#123;
        int flow = dfs();
        maxflow += flow;
        mincost += flow * dis[t];
    &#125;
    return &#123;maxflow, mincost&#125;;
&#125;
</code></pre><h3 id="P4452-航班安排"><a href="#P4452-航班安排" class="headerlink" title="P4452 | 航班安排"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ0NTI=">P4452 | 航班安排</span></h3><ul><li>网络流重点在于建图。</li><li>本题对请求进行拆点，拆点后两个点之间连价值为 $c$，流量为 1 的边，代表每一个请求只能执行一次。</li><li>对于一个请求，如果00时刻可以从 0 机场飞到该请求的起点机场，那么源点向该请求连价值为 (-飞行费用)，流量为 INF 的边，同理，若一个请求的结束时间，加上它的结束机场飞回 0 的时间小于等于总的时间限制，该请求向汇点连边。</li><li>但是每次执行完一个请求并未规定一定要飞回 0 机场，也可以飞去其他请求的起点机场，所以两两枚举请求，如果满足时间条件也进行连边。</li><li>最后考虑有 k 架飞机，所以再建一个源点，向原来的源点连费用为 0，流量为 k 的边即可。</li><li>稍微改下 spfa 函数，让其跑最长路。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 510, M = 1e6 + 10, INF = 0x3f3f3f3f;
int h[N], e[M], ne[M], w[M], c[M], idx;
void add(int a, int b, int x, int y)&#123;
    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;
&#125;
struct Node&#123;
    int a, b, s, t, c;
&#125;query[N];
int s, t, cur[N], dis[N];
bool st[N], vis[N];
inline bool spfa()&#123;
    queue&lt;int&gt; q;
    fill(dis, dis + N, -INF);
    memcpy(cur, h, sizeof(cur));
    dis[s] = 0;
    q.push(s);
    st[s] = true;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        st[u] = false;
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int j = e[i], x = w[i], y = c[i];
            if(dis[j] &lt; dis[u] + y &amp;&amp; x &gt; 0)&#123;
                dis[j] = dis[u] + y;
                if(!st[j])&#123;
                    st[j] = true;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    return dis[t] != -0x3f3f3f3f;
&#125;
inline int dfs(int u = s, int flow = INF)&#123;
    if(u == t) return flow;
    vis[u] = true;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], x = w[i], y = c[i];
        if(!vis[j] &amp;&amp; dis[j] == dis[u] + y &amp;&amp; x &gt; 0)&#123;
            int c = dfs(j, min(remain, x));
            remain -= c;
            w[i] -= c;
            w[i ^ 1] += c;
        &#125;
    &#125;
    vis[u] = false;
    return flow - remain;
&#125;
inline LL dinic()&#123;
    LL ans = 0;
    while(spfa())&#123;
        int tmp = dfs();
        ans += (LL) tmp * dis[t];
    &#125;
    return ans;
&#125;
int g[N][N], f[N][N];
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m, k, ed;
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; ed;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            cin &gt;&gt; g[i][j];
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            cin &gt;&gt; f[i][j];
        &#125;
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        cin &gt;&gt; query[i].a &gt;&gt; query[i].b &gt;&gt; query[i].s &gt;&gt; query[i].t &gt;&gt; query[i].c;
        query[i].a++;
        query[i].b++;
    &#125;
    s = 0, t = m * 2 + 5;
    for(int i = 1; i &lt;= m; i++)&#123;
        add(i + 1, i + m + 1, 1, query[i].c);
        if(query[i].t + g[query[i].b][1] &lt;= ed)&#123;
            add(i + m + 1, t, INF, -f[query[i].b][1]);
        &#125;
        if(query[i].s - g[1][query[i].a] &gt;= 0)&#123;
            add(1, i + 1, INF, -f[1][query[i].a]);
        &#125;
        for(int j = 1; j &lt;= m; j++)&#123;
            if(i != j &amp;&amp; query[i].t + g[query[i].b][query[j].a] &lt;= query[j].s)&#123;
                add(i + m + 1, j + 1, INF, -f[query[i].b][query[j].a]);
            &#125;
        &#125;
    &#125;
    add(s, 1, k, 0);
    cout &lt;&lt; dinic() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="P2050-美食节"><a href="#P2050-美食节" class="headerlink" title="P2050 | 美食节"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIwNTA=">P2050 | 美食节</span></h3><ul><li>费用流 + 动态开点</li><li>被用到的点很少，因此可以一边跑流一边加点，这样可以省去很多没用的点。</li><li>点数的规模 $(mp + n) \to (n + m + p)$，边数的规模 $(nmp) \to (np)$。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vc29sdXRpb24vUDIwNTA=">详细题解</span></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e5 + 10, M = 3e7 + 10;
int h[N], e[M], ne[M], w[M], c[M], idx;
void add(int a, int b, int x, int y)&#123;
    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;
&#125;

int nxt[N], top[N];
int n, m, s, t, dis[N], cur[N];
bool st[N], vis[N];
int p[N], ct[60][120];
inline bool spfa()&#123;
    memset(dis, 0x3f, sizeof(dis));
    memcpy(cur, h, sizeof(h));
    queue&lt;int&gt; q;
    q.push(s);
    dis[s] = 0;
    while(q.size())&#123;
        int u = q.front(); q.pop();
        st[u] = 0;
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int j = e[i], x = w[i], y = c[i];
            if(dis[j] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;
                dis[j] = dis[u] + y;
                if(!st[j])&#123;
                    st[j] = 1;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    return dis[t] != 0x3f3f3f3f;
&#125;
inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;
    if(u == t) return flow;
    vis[u] = 1;
    int remain = flow;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int j = e[i], x = w[i], y = c[i];
        if(!vis[j] &amp;&amp; dis[j] == dis[u] + y &amp;&amp; x &gt; 0)&#123;
            int tmp = dfs(j, min(remain, x));
            if(tmp &gt; 0)&#123;
                remain -= tmp;
                w[i] -= tmp;
                w[i ^ 1] += tmp;
                nxt[u] = j;
            &#125;
        &#125;
    &#125;
    vis[u] = 0;
    return flow - remain;
&#125;
int sum;
inline int getid(int x, int y)&#123;
    return (x - 1) * sum + y;
&#125;
inline pair&lt;int, int&gt; dinic()&#123;
    int maxflow = 0, mincost = 0;
    while(spfa())&#123;
        int flow = dfs();
        maxflow += flow;
        mincost += flow * dis[t];
        for(int j = 1; j &lt;= m; j++)&#123;
            if(nxt[n + getid(j, top[j])] &amp;&amp; top[j] &lt; sum)&#123;
                top[j]++;
                int now = n + getid(j, top[j]);
                for(int i = 1; i &lt;= n; i++)&#123;
                    add(i, now, 1, ct[i][j] * top[j]);
                &#125;
                add(now, t, 1, 0);
            &#125;
        &#125;
    &#125;
    return &#123;maxflow, mincost&#125;;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; p[i];
        sum += p[i];
    &#125;
    s = m * sum + n + 1, t = s + 1;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            cin &gt;&gt; ct[i][j];
        &#125;
    &#125;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= n; i++)&#123;
        add(s, i, p[i], 0);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            add(i, n + getid(j, 1), 1, ct[i][j]);
        &#125;
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        top[i] = 1;
        add(n + getid(i, 1), t, 1, 0);
    &#125;
    auto [x, y] = dinic();
    cout &lt;&lt; y &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="P3980-志愿者招募"><a href="#P3980-志愿者招募" class="headerlink" title="P3980 | 志愿者招募"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM5ODA=">P3980 | 志愿者招募</span></h3><ul><li><p>招募的人可以打工一段时间，且只需要支付一次费用，因此需要特殊的建图方式。</p></li><li><p>将人数限制放置在相邻两天之间，并且将志愿者单独建边，覆盖那一段时间。</p></li><li><p>此时我们相当于是把第i天的决策放到了第 $i$ 个点和第 $i+1$ 个点之间的所有边上（就是把所有点排成一排，这两个点之间的那一条位置里的所有边，包括跨过这个区间的志愿者边）</p></li><li><p>需要志愿者？让它们从志愿者边上流过去，同时让人数限制边满流到 $-a[i]$，这样求一个 $1\to n+1$ 的最大流，流量为 $0$ 的最小费用就是雇佣人的最小费用了</p></li><li><p>为了让这个限制起效，又因为网络流中流量非负，所以我们建立点 $S$ 和 $T$，限制为$INF$，费用为 $0$。</p></li><li><p>同时，我们把之前的人数限制边的流量改成$(INF-a[i])$，这样最终的最大流一定是$INF$，而且限制依然成立</p></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1010, M = 5e4 + 10, INF = 0x3f3f3f3f;
int h[N], e[M], ne[M], w[M], c[M], idx;
void add(int a, int b, int x, int y)&#123;
    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;
&#125;
int n, m, s, t, dis[N], cur[N];
bool st[N], vis[N];
inline bool spfa()&#123;
    memset(dis, 0x3f, sizeof dis);
    memcpy(cur, h, sizeof cur);
    queue&lt;int&gt; q;
    dis[s] = 0;
    q.push(s);
    while(q.size())&#123;
        int u = q.front(); q.pop();
        st[u] = 0;
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int v = e[i], x = w[i], y = c[i];
            if(dis[v] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;
                dis[v] = dis[u] + y;
                if(!st[v])&#123;
                    st[v] = true;
                    q.push(v);
                &#125;
            &#125;
        &#125;
    &#125;
    return dis[t] != INF;
&#125;
inline int dfs(int u = s, int flow = INF)&#123;
    if(u == t) return flow;
    int remain = flow;
    vis[u] = true;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int v = e[i], x = w[i], y = c[i];
        if(!vis[v] &amp;&amp; dis[v] == dis[u] + y &amp;&amp; x &gt; 0)&#123;
            int tmp = dfs(v, min(remain, x));
            remain -= tmp;
            w[i] -= tmp;
            w[i ^ 1] += tmp;
        &#125;
    &#125;
    vis[u] = false;
    return flow - remain;
&#125;
inline pair&lt;int, int&gt; dinic()&#123;
    int maxflow = 0, mincost = 0;
    while(spfa())&#123;
        int flow = dfs();
        maxflow += flow;
        mincost += flow * dis[t];
    &#125;
    return &#123;maxflow, mincost&#125;;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        add(i, i + 1, INF - x, 0);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        int u, v, a;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; a;
        add(u, v + 1, INF, a);
    &#125;
    s = 0, t = n + 2;
    add(s, 1, INF, 0);
    add(n + 1, t, INF, 0);
    auto [maxflow, mincost] = dinic();
    cout &lt;&lt; mincost &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><ul><li>上下界网络流可以看做普通网络流的升级版，现在对于流量网络，我们不再只关注其流量的<strong>上界</strong>，而是同时关注流量的<strong>上下界</strong>。</li></ul><h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a>无源汇有上下界可行流</h3><ul><li><p>这是上下界网络流中最简单的一种，给定一个没有源点和汇点、每条边的流量有上下界的流量网络，问是否存在一种可行流使得流量平衡。</p></li><li><p><img data-src="https://pic1.zhimg.com/80/v2-5c7a4eaa79b5c9da4be7fb03658ba598_720w.jpg"></p></li><li><p>做法是，我们把它<strong>拆</strong>成两个结构与原图相同的普通网络，一个每条边的容量为原网络对应边的<strong>流量下界</strong>，另一个为对应边的<strong>流量上界与下界之差</strong>。</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-b2894f46d6e7b1f146a7dd5edb6be1d6_720w.jpg"></p></li><li><p>我们希望下界网络和差网络的流相加后恰好是原图的一个可行流，这首先要求下界网络是满流的（可行流必须达到每条边的下界）。但是下界网络满流后不一定流量平衡，所以我们要对差网络进行一定的修改以弥补这种不平衡。</p></li><li><p>我们分别考虑下界网络的每个点。A点，流入量为3，流出量也为3，所以是平衡的，那么在差网络中，也应该是平衡的，所以不做修改。B点，流入量为3，流出量为1，流入比流出多2，所以我们希望在差网络中，B的流出应该比流入多2，于是我们在差网络中新设一个<strong>源点</strong>，然后加入一条容量为2的<strong>附加边</strong>从源点连向B，这样在差网络平衡时，除去附加边，B点的流出恰好比流入多2，C点与B点类似。D点则相反，因为我们希望在差网络中D点流入比流出多2，所以我们新设一个<strong>汇点</strong>，然后从D点连一条容量为2的附加边到汇点，E点又和D类似。</p></li><li><p>也就是说，如果下界网络中某个点有x的净流入，在差网络中我们就从源点向它连一条容量为x的附加边；相反，如果下界网络中某个点有x的净流出，在差网络中我们就从它向汇点连一条容量为x的附加边。这样，我们把差网络修改如下：</p></li><li><p><img data-src="https://pic1.zhimg.com/80/v2-f213c0b0ff05657a1b819179d195ba34_720w.jpg"></p></li><li><p>在差网络上跑一遍最大流，把每条非附加边的流，加上下界网络的满流，就是一个可行流。但是，如果跑完最大流发现，存在附加边未满流，那说明平衡条件没有得到满足，于是原图不存在可行流。</p></li><li><p>在实际中，是不需要建立下界网络的，只需要对差网络进行操作即可。另外最后判断的时候并无必要遍历所有附加边，而只需要判断所有从源点出发的边，或者判断所有连向汇点的边即可，因为根据网络流的性质，两者容量和应该相等，于是它们要么都满流，要么都不满流。</p></li></ul><h2 id="有源汇有上下界可行流"><a href="#有源汇有上下界可行流" class="headerlink" title="有源汇有上下界可行流"></a>有源汇有上下界可行流</h2><ul><li><p>从汇点到源点连一条下界为 $0$ ，上界为 $∞$ 的附加边，得到一张和原图等价的无源汇流量网络，于是转化成了无源汇有上下界可行流问题。此时从源点到汇点的可行流流量，即为从汇点到源点的那条附加边的流量（注意下界网络中对应边流量为 $0$）。</p></li><li><p>注意，这时候原来的源点和汇点已被处理成普通点，和之后差网络需要额外建立的源、汇点是不同的点，之后如果这两者同时出现，我们记前者为 S 、 T ，后者为 S′ 、 T′ 。</p></li><li><p><img data-src="https://pic2.zhimg.com/80/v2-02ceb585a4de85ffcb326000849a251d_720w.jpg"></p></li></ul><h2 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a>有源汇有上下界最大流</h2><ul><li><p>按照上一节的方法，我们已经得到了一个可行流，且知道它的流量就是T到S的附加边的流量。</p></li><li><p><img data-src="https://pic2.zhimg.com/80/v2-fdfcf569bb5131fce027d0c2d92e52e9_720w.jpg"></p></li><li><p>要求从 $S$ 到 $T$ 的最大流，我们可以在差网络中把所有附加边删除，然后以 $S$ 与 $T$ 为源点与汇点，再求残余网络的最大流，加上可行流的流量即为原网络的最大流。这是因为，可行流已经保证了流量平衡，那么删去附加边后，我们再跑一次最大流把残余网络“榨干”，最后得到的流仍保证是平衡的。</p></li><li><p><img data-src="https://pic3.zhimg.com/80/v2-849e347da5ce4a259c4f346f9082597a_720w.jpg"></p></li><li><p>当然实际上 $S’$ 与 $T’$ 连接的附加边不需要删，这种出度或入度为 0、又非源汇点的点是不影响最大流的，何况如果存在可行流，它们的残余容量已经为 0 了。</p></li></ul><h2 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a>有源汇有上下界最小流</h2><ul><li>跟上面几乎完全相同，只需要在拆掉附加边后，<strong>从汇点到源点</strong>，而不是从源点到汇点跑一遍最大流。可行流的流量，减去从汇点到源点的最大流即为答案。如果说上下界最大流是把残量网络“榨干”，那么上下界最小流就是把不需要的流“退回”。</li></ul><h2 id="有上下界最小费用可行流"><a href="#有上下界最小费用可行流" class="headerlink" title="有上下界最小费用可行流"></a>有上下界最小费用可行流</h2><ul><li>和（无&#x2F;有源汇）有上下界可行流的原理相同，也是拆成两个网络。所有附加边的费用设为0。最后的费用是下界网络满流的费用，加上在差网络上跑MCMF后得到的费用之和。而前者即所有边的容量与费用乘积的和。注意，这样求出来的是满足最小费用的可行流，而不是满足流最大的前提下费用最小的流。</li></ul><h2 id="P4043-支线剧情"><a href="#P4043-支线剧情" class="headerlink" title="P4043 | 支线剧情"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQwNDM=">P4043 | 支线剧情</span></h2><ul><li>题意<ul><li>观看一个支线剧情花费一定时间，并且每个支线剧情至少观看一次，将这个条件抽象成网络上的一条边，容量上界为 $\infty$，下界为 1，费用为 $t_i$。</li><li>由于在每个点都可以退出游戏，于是将每个点向一个虚拟的汇点 $t$ 连边，容量上界为 $\infty$，下界为 0，费用为 0。</li><li>求解这个源点为 $s&#x3D;1$，汇点为 $t$ 的网络的最小费用可行流即可。</li></ul></li><li>题解<ul><li>由于这是一个有源有汇网络，其中源点 $s$ 与汇点 $t$ 不满足流量守恒性质，所以连边 $t \to s$ 将其转化为无源无汇网络。</li><li>先让每一条边都满足它的容量下界，可以发现此时有些点并不满足流量守恒性质，于是我们需要补流。</li><li>对于每一个点 $u$，记录它流入流量与流出流量的差</li><li>建立超级源点 $S$，与超级汇点 $T$ 用于补流。然后对于 $d_u$ 分类讨论：<ul><li>$d_u&#x3D;0$，不需要补流。</li><li>$d_u&gt;0$，流入流量多了，连边 $u \to T$，容量为 $d_u$，将多余流量送入超级汇点 $T$。</li><li>$d_u&lt;0$，流入流量不够，连边 $S \to u$，容量为 $|d_u|$，让超级源点 $S$ 对其补流。</li></ul></li><li>在新建的网络上跑最小费用最大流即可。</li><li>由于最开始强制给了每条边 1 的流量，最小费用还要加上这个操作的费用才是答案。</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 2010, M = 2e5 + 10, INF = 0x3f3f3f3f;
int h[N], e[M], ne[M], w[M], c[M], idx;
void add(int a, int b, int x, int y)&#123;
    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;
&#125;
int n, s, t, dis[N], cur[N];
bool st[N], vis[N];
inline bool spfa()&#123;
    for(int i = 1; i &lt;= n + 3; i++)&#123;
        dis[i] = 0x3f3f3f3f;
    &#125;
    memcpy(cur, h, sizeof cur);
    queue&lt;int&gt; q;
    dis[s] = 0;
    q.push(s);
    while(q.size())&#123;
        int u = q.front(); q.pop();
        st[u] = 0;
        for(int i = cur[u]; ~i; i = ne[i])&#123;
            int v = e[i], x = w[i], y = c[i];
            if(dis[v] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;
                dis[v] = dis[u] + y;
                if(!st[v])&#123;
                    st[v] = true;
                    q.push(v);
                &#125;
            &#125;
        &#125;
    &#125;
    return dis[t] != INF;
&#125;
inline int dfs(int u = s, int flow = INF)&#123;
    if(u == t) return flow;
    int remain = flow;
    vis[u] = true;
    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;
        int v = e[i], x = w[i], y = c[i];
        if(!vis[v] &amp;&amp; dis[v] == dis[u] + y &amp;&amp; x &gt; 0)&#123;
            int tmp = dfs(v, min(remain, x));
            remain -= tmp;
            w[i] -= tmp;
            w[i ^ 1] += tmp;
        &#125;
    &#125;
    vis[u] = false;
    return flow - remain;
&#125;
inline pair&lt;int, int&gt; dinic()&#123;
    int maxflow = 0, mincost = 0;
    while(spfa())&#123;
        int flow = dfs();
        maxflow += flow;
        mincost += flow * dis[t];
    &#125;
    return &#123;maxflow, mincost&#125;;
&#125;
int d[N];
int main()&#123;
    int ans = 0;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    memset(h, -1, sizeof h);
    s = n + 2, t = n + 3;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        for(int j = 1; j &lt;= x; j++)&#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            d[a]++, d[i]--;
            ans += b;
            add(i, a, INF, b);
        &#125;
    &#125;
    int S = 1, T = n + 1;
    for(int i = 2; i &lt;= n; i++)&#123;
        add(i, T, INF, 0);
    &#125;
    add(T, S, INF, 0);
    for(int i = 1; i &lt;= n + 1; i++)&#123;
        if(d[i] &gt; 0) add(s, i, d[i], 0);
        if(d[i] &lt; 0) add(i, t, -d[i], 0);
    &#125;
    auto [maxflow, mincost] = dinic();
    cout &lt;&lt; mincost + ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 学习笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-05 19:45:54" itemprop="dateModified" datetime="2022-09-05T19:45:54+08:00">2022-09-05</time> </span><span id="post/网络流.html" class="item leancloud_visitors" data-flag-title="网络流" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" title="网络流">https://asterzc19.github.io/post/网络流.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;06&#x2F;25&#x2F;ff62598e6c27ddd4.png" title="Flyme 更新日志"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Flyme 更新日志</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">1.1.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">1.2.</span> <span class="toc-text">流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">网络流的常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-number">2.3.</span> <span class="toc-text">最小割</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81-1"><span class="toc-number">3.</span> <span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ford-Fulkerson-%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">Ford-Fulkerson 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Edmond-Karp-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">Edmond-Karp 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dinic-%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">Dinic 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P3376-%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">P3376 | 网络最大流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8F%96%E4%B8%80%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">二者取一式问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P1361-%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9"><span class="toc-number">3.4.1.</span> <span class="toc-text">P1361 | 小M的作物</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">路径覆盖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P2764-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.1.</span> <span class="toc-text">P2764 | 最小路径覆盖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2765-%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.2.</span> <span class="toc-text">P2765 | 魔术球问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2-1"><span class="toc-number">4.</span> <span class="toc-text">最小割</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%B2%E8%BE%B9%E6%95%B0%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">割边数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8F%96%E4%B8%80%E5%BC%8F%E9%97%AE%E9%A2%98-1"><span class="toc-number">4.2.</span> <span class="toc-text">二者取一式问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P2774-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.1.</span> <span class="toc-text">P2774 | 方格取数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%9D%83%E5%80%BC%E9%97%AD%E5%90%88%E5%9B%BE"><span class="toc-number">4.3.</span> <span class="toc-text">最大权值闭合图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81-1"><span class="toc-number">5.</span> <span class="toc-text">最小费用最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSP-%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">SSP 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P4452-%E8%88%AA%E7%8F%AD%E5%AE%89%E6%8E%92"><span class="toc-number">5.1.1.</span> <span class="toc-text">P4452 | 航班安排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2050-%E7%BE%8E%E9%A3%9F%E8%8A%82"><span class="toc-number">5.1.2.</span> <span class="toc-text">P2050 | 美食节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P3980-%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F"><span class="toc-number">5.1.3.</span> <span class="toc-text">P3980 | 志愿者招募</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">6.</span> <span class="toc-text">上下界网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-number">6.0.1.</span> <span class="toc-text">无源汇有上下界可行流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-number">6.1.</span> <span class="toc-text">有源汇有上下界可行流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">6.2.</span> <span class="toc-text">有源汇有上下界最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%B0%8F%E6%B5%81"><span class="toc-number">6.3.</span> <span class="toc-text">有源汇有上下界最小流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-number">6.4.</span> <span class="toc-text">有上下界最小费用可行流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P4043-%E6%94%AF%E7%BA%BF%E5%89%A7%E6%83%85"><span class="toc-number">6.5.</span> <span class="toc-text">P4043 | 支线剧情</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/AcWing/" title="分类于 AcWing">AcWing</a></div><span><a href="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html" title="线性同余方程">线性同余方程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" title="高级数据结构题集">高级数据结构题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%96%87%E7%AB%A0/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" title="图论题集">图论题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/STL%E7%AE%80%E4%BB%8B.html" title="STL 简介">STL 简介</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html" title="数学知识">数学知识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/CodeForces/" title="分类于 CodeForces">CodeForces</a> <i class="ic i-angle-right"></i> <a href="/categories/AtCoder/" title="分类于 AtCoder">AtCoder</a></div><span><a href="/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" title="题目小集">题目小集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" title="网络流">网络流</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">274k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:09</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/网络流.html",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->