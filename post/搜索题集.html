<!-- build time:Mon Sep 12 2022 21:42:04 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,题集"><link rel="canonical" href="https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>搜索题集 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">搜索题集</h1><div class="meta"><span class="item" title="创建时间：2022-03-08 18:00:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-08T18:00:20+08:00">2022-03-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>28k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>25 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/85da8357bdceba73.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2b1d828f5ff26065.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/05ac51bc092a5a09.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/c262304a9abc9a8f.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/9d2607c6eedc2a1d.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/8e1dc72d6a2cd665.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/b545cd4703efa0d4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/9259140c0ac4c203.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/79181978dd20d35c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/cc4fe587071a62d8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/0ff0506797b60902.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/7f6edf1d98b0d8a0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/958c3bf3cd3a0db5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/04b816dd3c5c9934.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2ed81611f053c81c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/e82f196e980a63f5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/40c7bc0e06dce5f2.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/ff4c0e1d1c41cedd.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/82a4dfcddf3ba7e0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/adf69ad6a75c5594.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/21bbfe021cfceec4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/93a7b0f96c0166ce.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/44d29b2c5b4e40c8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/728c619db3847842.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/372deb0eedb17ea9.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/4203257a6c65e036.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/db894a8df07c1517.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p>包括 BFS 中的 Flood Fill、最短路模型、多源 BFS、最小步数模型、双端队列广搜、双向广搜、A-Star 以及 DFS 中的连通性模型、DFS 之搜索顺序、DFS 之剪枝与优化、迭代加深、双向 DFS、IDA* 等</p></blockquote><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ol><li>求最小，最短</li><li>基于迭代、不会爆栈</li></ol><h3 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h3><ul><li>可以在线性时间复杂度内，找到某个点所在的连通块</li></ul><h4 id="AcWing-池塘计数"><a href="#AcWing-池塘计数" class="headerlink" title="AcWing|池塘计数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA5OS8=">AcWing|池塘计数</span></h4><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int, int&gt; PII;
const int N = 1010;
string g[N];
bool vis[N][N];
int n, m, ans;
void bfs(int x, int y)&#123;
    queue&lt;PII&gt; q;
    q.push(PII(x, y));
    vis[x][y] = 1;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        int x = t.first, y = t.second;
        for(int i = x - 1; i &lt;= x + 1; i++)&#123;
            for(int j = y - 1; j &lt;= y + 1; j++)&#123;
                if(i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m || vis[i][j] || g[i][j] == &#39;.&#39;) continue;
                vis[i][j] = 1;
                q.push(PII(i, j));
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            if(g[i][j] == &#39;W&#39; &amp;&amp; !vis[i][j])&#123;
                ans++;
                bfs(i, j);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h4 id="AcWing-城堡问题"><a href="#AcWing-城堡问题" class="headerlink" title="AcWing|城堡问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwMC8=">AcWing|城堡问题</span></h4><ul><li>使用状态压缩可以简单地处理每个状态</li><li>原题更复杂</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 60;
bool st[N][N];
int g[N][N];
int n, m;
int bfs(int x, int y)&#123;
    int dx[4] = &#123;0, -1, 0, 1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;
    queue&lt;PII&gt; q;
    q.push(&#123;x, y&#125;);
    st[x][y] = 1;
    int ans = 0;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        ans++;
        int x = t.first, y = t.second;
        for(int i = 0; i &lt; 4; i++)&#123;
            int nx = x + dx[i], ny = y + dy[i];
            if(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; m || st[nx][ny]) continue;
            if(g[x][y] &gt;&gt; i &amp; 1) continue;
            q.push(&#123;nx, ny&#125;);
            st[nx][ny] = 1;
        &#125;
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            cin &gt;&gt; g[i][j];
        &#125;
    &#125;
    int cnt = 0, area = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            if(!st[i][j])&#123;
                area = max(area, bfs(i, j));
                cnt++;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39; &lt;&lt; area &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h4 id="AcWing-山峰和山谷"><a href="#AcWing-山峰和山谷" class="headerlink" title="AcWing|山峰和山谷"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwOC8=">AcWing|山峰和山谷</span></h4><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 1010, M = N * N;
int n;
int h[N][N];
bool st[N][N];
void bfs(int x, int y, bool&amp; has_higher, bool&amp; has_lower)&#123;
    queue&lt;PII&gt; q;
    q.push(&#123;x, y&#125;);
    st[x][y] = 1;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        for(int i = t.first - 1; i &lt;= t.first + 1; i++)&#123;
            for(int j = t.second - 1; j &lt;= t.second + 1; j++)&#123;
                if(i == t.first &amp;&amp; j == t.second) continue;
                if(i &lt;= 0 || i &gt; n || j &lt;= 0 || j &gt; n) continue;
                if(h[i][j] != h[t.first][t.second])&#123;
                    if(h[i][j] &gt; h[t.first][t.second]) has_higher = 1;
                    else has_lower = 1;
                &#125;else if(!st[i][j])&#123;
                    q.push(&#123;i, j&#125;);
                    st[i][j] = 1;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            cin &gt;&gt; h[i][j];
        &#125;
    &#125;
    int peak = 0, valley = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            if(!st[i][j])&#123;
                bool has_higher = 0, has_lower = 0;
                bfs(i, j, has_higher, has_lower);
                if(!has_higher) peak++;
                if(!has_lower) valley++;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; peak &lt;&lt; &#39; &#39; &lt;&lt; valley &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="最短路模型"><a href="#最短路模型" class="headerlink" title="最短路模型"></a>最短路模型</h3><ul><li>小证明<ul><li>队列中的所有元素具有<ul><li>两段性 $x, x + 1$ （最多有两段）</li><li>单调性，队列前面的元素一定小于等于后加入的元素</li></ul></li><li>使用数学归纳法证明<ul><li>类比堆优化版 Dijkstra</li></ul></li></ul></li></ul><h4 id="AcWing-迷宫问题"><a href="#AcWing-迷宫问题" class="headerlink" title="AcWing|迷宫问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3OC8=">AcWing|迷宫问题</span></h4><ul><li>从终点开始 BFS，遍历前驱节点时即可不需要倒序输出</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 1010;
int n;
int g[N][N];
PII pre[N][N];
void bfs(int x, int y)&#123;
    int dx[4] = &#123;0, -1, 0, 1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;
    queue&lt;PII&gt; q;
    q.push(&#123;x, y&#125;);
    memset(pre, -1, sizeof(pre));
    pre[x][y] = &#123;0, 0&#125;;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        for(int i = 0; i &lt; 4; i++)&#123;
            int nx = t.first + dx[i], ny = t.second + dy[i];
            if(g[nx][ny]) continue;
            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || pre[nx][ny].first != -1) continue;
            q.push(&#123;nx, ny&#125;);
            pre[nx][ny] = &#123;t.first, t.second&#125;;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            cin &gt;&gt; g[i][j];
        &#125;
    &#125;
    bfs(n - 1, n - 1);
    PII end = &#123;0, 0&#125;;
    while(1)&#123;
        cout &lt;&lt; end.first &lt;&lt; &quot; &quot; &lt;&lt; end.second &lt;&lt; &#39;\n&#39;;
        if(end.first == n - 1 &amp;&amp; end.second == n - 1) break;
        end = pre[end.first][end.second];
    &#125;
&#125;
</code></pre><h4 id="AcWing-武士风度的牛"><a href="#AcWing-武士风度的牛" class="headerlink" title="AcWing|武士风度的牛"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTkwLw==">AcWing|武士风度的牛</span></h4><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 160;
string g[N];
int n, m;
bool st[N][N];
int dis[N][N];
int dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;, dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;
int bfs(int x, int y)&#123;
    queue&lt;PII&gt; q;
    q.push(&#123;x, y&#125;);
    st[x][y] = 1;
    memset(dis, -1, sizeof(dis));
    dis[x][y] = 0;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        int a = t.first, b = t.second;
        for(int i = 0; i &lt; 8; i++)&#123;
            int nx = a + dx[i], ny = b + dy[i];
            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || st[nx][ny] || g[nx][ny] == &#39;*&#39;) continue;
            if(dis[nx][ny] != -1) continue;
            if(g[nx][ny] == &#39;H&#39;) return dis[a][b] + 1;
            q.push(&#123;nx, ny&#125;);
            dis[nx][ny] = dis[a][b] + 1;
            st[nx][ny] = 1;
        &#125;
    &#125;
    return -1;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; m &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
    int ans;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            if(g[i][j] == &#39;K&#39;)&#123;
                ans = bfs(i, j);
                break;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h4 id="AcWing-抓住那头牛"><a href="#AcWing-抓住那头牛" class="headerlink" title="AcWing|抓住那头牛"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwMi8=">AcWing|抓住那头牛</span></h4><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
int n, k;
int dis[N];
int bfs()&#123;
    memset(dis, -1, sizeof(dis));
    queue&lt;int&gt; q;
    dis[n] = 0;
    q.push(n);
    while(q.size())&#123;
        int t = q.front(); q.pop();
        if(t == k) return dis[t];
        if(t + 1 &lt; N &amp;&amp; dis[t + 1] == -1)&#123;
            dis[t + 1] = dis[t] + 1;
            q.push(t + 1);
        &#125;
        if(t - 1 &gt;= 0 &amp;&amp; dis[t - 1] == -1)&#123;
            dis[t - 1] = dis[t] + 1;
            q.push(t - 1);
        &#125;
        if(t * 2 &lt; N &amp;&amp; dis[t * 2] == -1)&#123;
            dis[t * 2] = dis[t] + 1;
            q.push(t * 2);
        &#125;
    &#125;
    return -1;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; k;
    cout &lt;&lt; bfs() &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;
</code></pre><h3 id="多源-BFS"><a href="#多源-BFS" class="headerlink" title="多源 BFS"></a>多源 BFS</h3><h4 id="AcWing-矩阵距离"><a href="#AcWing-矩阵距离" class="headerlink" title="AcWing|矩阵距离"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTc1Lw==">AcWing|矩阵距离</span></h4><ul><li>本题有多个起点，可以转换成从源点到每个点的最短距离，源点到每个起点的边权都为 $0$</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1010;
typedef pair&lt;int, int&gt; PII;
string g[N];
int n, m;
int dis[N][N];
int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;
void bfs()&#123;
    memset(dis, -1, sizeof(dis));
    queue&lt;PII&gt; q;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            if(g[i][j] == &#39;1&#39;)&#123;
                dis[i][j] = 0;
                q.push(PII(i, j));
            &#125;
        &#125;
    &#125;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        int x = t.first, y = t.second;
        for(int i = 0; i &lt; 4; i++)&#123;
            int nx = x + dx[i], ny = y + dy[i];
            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue;
            if(g[nx][ny] == &#39;0&#39; &amp;&amp; dis[nx][ny] == -1)&#123;
                dis[nx][ny] = dis[x][y] + 1;
                q.push(PII(nx, ny));
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
    bfs();
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            cout &lt;&lt; dis[i][j] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="最小步数模型"><a href="#最小步数模型" class="headerlink" title="最小步数模型"></a>最小步数模型</h3><ul><li>典型例题 「八数码」</li><li>通常使用哈希存储状态&#x2F;康托展开</li></ul><h4 id="AcWing-魔板"><a href="#AcWing-魔板" class="headerlink" title="AcWing|魔板"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwOS8=">AcWing|魔板</span></h4><ul><li>BFS 时按照 「ABC」的顺序依次遍历，即可满足字典序最小的条件</li><li>三种操作模拟一遍即可</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
char g[2][4];
unordered_map&lt;string, pair&lt;char, string&gt;&gt; pre;
unordered_map&lt;string, int&gt; dis;
void set_string(string st)&#123;
    for(int i = 0; i &lt; 4; i++) g[0][i] = st[i];
    for(int i = 7, j = 0; j &lt; 4; i--, j++) g[1][j] = st[i];
&#125;
string get()&#123;
    string res;
    for(int i = 0; i &lt; 4; i++) res += g[0][i];
    for(int i = 3; i &gt;= 0; i--) res += g[1][i];
    return res;
&#125;
string move0(string st)&#123;
    set_string(st);
    for(int i = 0; i &lt; 4; i++) swap(g[0][i], g[1][i]);
    return get();
&#125;
string move1(string st)&#123;
    set_string(st);
    for(int i = 3; i &gt;= 1; i--)&#123; 
        swap(g[0][i], g[0][i - 1]);
        swap(g[1][i], g[1][i - 1]);
    &#125;
    return get();
&#125;
string move2(string st)&#123;
    set_string(st);
    char tmp = g[0][1];
    g[0][1] = g[1][1];
    g[1][1] = g[1][2];
    g[1][2] = g[0][2];
    g[0][2] = tmp;
    return get();
&#125;
int bfs(string st, string ed)&#123;
    if(st == ed) return 0;
    queue&lt;string&gt; q;
    q.push(st);
    dis[st] = 0;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        string m[3];
        m[0] = move0(t);
        m[1] = move1(t);
        m[2] = move2(t);
        for(int i = 0; i &lt; 3; i++)&#123;
            if(!dis.count(m[i]))&#123;
                dis[m[i]] = dis[t] + 1;
                pre[m[i]] = make_pair(&#39;A&#39; + i, t);
                q.push(m[i]);
                if(m[i] == ed) return dis[m[i]];
            &#125;
        &#125;
    &#125;
    return -1;
&#125;
int main()&#123;
    int x;
    string st, ed;
    for(int i = 0; i &lt; 8; i++)&#123;
        cin &gt;&gt; x;
        ed += char(x + &#39;0&#39;);
    &#125;
    for(int i = 1; i &lt;= 8; i++) st += char(i + &#39;0&#39;);
    int step = bfs(st, ed);
    cout &lt;&lt; step &lt;&lt; &#39;\n&#39;;
    string ans;
    while(ed != st)&#123;
        ans += pre[ed].first;
        ed = pre[ed].second;
    &#125;
    reverse(ans.begin(), ans.end());
    if(step &gt; 0) cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h3><h4 id="AcWing-电路维修"><a href="#AcWing-电路维修" class="headerlink" title="AcWing|电路维修"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTc3Lw==">AcWing|电路维修</span></h4><ul><li>可以看作是有两种边权的路，需要旋转的边权为 $1$，不需要的边权为 $0$</li><li>假如起点与终点奇偶条件（横纵坐标之和）不一样则无解</li><li>假如扩展的边权为 $1$ 则插入到队尾，否则插入到队头</li><li>第一个偏移量是以格点为中心向四周移动</li><li>第二个偏移量是以格点为中心向四周移动时经过的方格</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 510, M = N * N;
int n, m;
string g[N];
int dis[N][N];
bool st[N][N];
int bfs()&#123;
    memset(dis, 0x3f, sizeof(dis));
    memset(st, 0, sizeof(st));
    dis[0][0] = 0;
    deque&lt;PII&gt; q;
    q.push_back(PII(0, 0));

    char cs[] = &quot;\\/\\/&quot;;
    int dx[4] = &#123;-1, -1, 1, 1&#125;, dy[4] = &#123;-1, 1, 1, -1&#125;;
    int ix[4] = &#123;-1, -1, 0, 0&#125;, iy[4] = &#123;-1, 0, 0, -1&#125;;

    while(q.size())&#123;
        auto t = q.front(); q.pop_front();
        int x = t.first, y = t.second;
        if(st[x][y]) continue;
        st[x][y] = true;
        for(int i = 0; i &lt; 4; i++)&#123;
            int nx = x + dx[i], ny = y + dy[i];
            if(nx &lt; 0 || nx &gt; n || ny &lt; 0 || ny &gt; m) continue;
            int cx = x + ix[i], cy = y + iy[i];
            int d = dis[x][y] + (g[cx][cy] != cs[i]);
            if(d &lt; dis[nx][ny])&#123;
                dis[nx][ny] = d;
                if(g[cx][cy] != cs[i]) q.push_back(&#123;nx, ny&#125;);
                else q.push_front(&#123;nx, ny&#125;);
            &#125;
        &#125;
    &#125;
    return dis[n][m];
&#125;
void solve()&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
    int t = bfs();
    if(t == 0x3f3f3f3f) cout &lt;&lt; &quot;NO SOLUTION\n&quot;;
    else cout &lt;&lt; t &lt;&lt; &#39;\n&#39;;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h3 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h3><ul><li>朴素版扩展</li><li>每次选择当前元素较少的队列扩展</li></ul><h4 id="AcWing-字符变换🌸"><a href="#AcWing-字符变换🌸" class="headerlink" title="AcWing|字符变换🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTkyLw==">AcWing|字符变换</span>🌸</h4><ul><li>可以把每一种字符串看作是一个点，所有的变化方案可以形成一张图，求最短路</li><li>每次扩展需要 <strong>扩展一层</strong></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 6;
int n; 
string A, B;
string a[N], b[N];
int extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp; da, unordered_map&lt;string, int&gt;&amp; db, string a[], string b[])&#123;
    int d = da[q.front()];
    while(q.size() &amp;&amp; da[q.front()] == d)&#123;	// 扩展一层
        auto t = q.front(); q.pop();
        for(int i = 0; i &lt; n; i++)&#123;
            for(int j = 0; j &lt; t.size(); j++)&#123;
                if(t.substr(j, a[i].size()) == a[i])&#123;
                    string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size());
                    if(db.count(r)) return da[t] + db[r] + 1;
                    if(!da.count(r))&#123;
                        da[r] = da[t] + 1;
                        q.push(r);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return 11;
&#125;
int bfs()&#123;
    if(A == B) return 0;
    queue&lt;string&gt; qa, qb;
    unordered_map&lt;string, int&gt; da, db;
    qa.push(A); da[A] = 0;
    qb.push(B); db[B] = 0;
    int step = 0;
    while(qa.size() &amp;&amp; qb.size())&#123;
        int t;
        if(qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b);
        else t = extend(qb, db, da, b, a);
        if(t &lt;= 10) return t;
        if(++step == 10) return -1;
    &#125;
    return -1;
&#125;
int main()&#123;
    cin &gt;&gt; A &gt;&gt; B;
    while(cin &gt;&gt; a[n] &gt;&gt; b[n]) n++;
    int ans = bfs();
    if(ans == -1) cout &lt;&lt; &quot;NO ANSWER!\n&quot;;
    else cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="A-Star"><a href="#A-Star" class="headerlink" title="A-Star"></a>A-Star</h3><ul><li>启发函数<ul><li>只需要搜索非常少的状态即可到达终点</li></ul></li><li>把 BFS 中的队列换成优先队列</li><li>队列中存「从起点到当前点的真实距离和从当前点到终点的估计距离」，按和的权重排序</li><li>当终点第一次出队的时候 <code>break</code></li><li><del>Dijkstra 可以看作是从当前点到终点的估计距离为 $0$ 的 A-Star 算法</del></li><li>如果无解就不要用 A-Star 算法</li><li>只能保证到终点的距离是最优</li></ul><pre><code>A* 应用场景:
起点→终点的最短距离
状态空间 &gt;&gt; 1e10 
启发函数减小搜索空间

A*算法:
while(q.size())
    t ← 优先队列的队头  小根堆
        当终点第一次出队时 break;
        从起点到当前点的真实距离 d_real
        从当前点到终点的估计距离 d_estimate
        选择一个估计距离最小的点 min(d_estimate)
    for j in ne[t]:
        将邻边入队

A*算法条件:
估计距离&lt;=真实距离
d[state] + f[state] = 起点到state的真实距离 + state到终点的估计距离=估计距离
                                                                       ^
d[state] + g[state] = 起点到state的真实距离 + state到终点的真实距离=真实距离

一定是有解才有 d[i]   &gt;= d[最优] = d[u]+f[u]
        f[u] &gt;= 0

证明终点第一次出队列即最优解

    1 假设终点第一次出队列时不是最优 
      则说明当前队列中存在点u
         有 d[估计]&lt; d[真实]
      d[u] + f[u] &lt;= d[u] + g[u] = d[队头终点]
      即队列中存在比d[终点]小的值,
    2 但我们维护的是一个小根堆,没有比d[队头终点]小的d[u],矛盾

    证毕

A* 不用判重
以边权都为1为例
  A o→o→o
    ↑   ↓
  S o→o→o→o→o→o→o T
      B
dist[A] = dist[S]+1 + f[A] = 7
dist[B] = dist[S]+1 + f[B] = 5
则会优先从B这条路走到T
B走到T后再从A这条路走到T

作者：仅存老实人
链接：https://www.acwing.com/solution/content/21233/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre><h4 id="AcWing-八数码🌸"><a href="#AcWing-八数码🌸" class="headerlink" title="AcWing|八数码🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgxLw==">AcWing|八数码</span>🌸</h4><ul><li>有解的充分必要条件是读出来排列好的数字序列中，逆序对的数量是偶数</li><li>估价函数：当前状态中每个数与它的目标位置的曼哈顿距离之和</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzM1NTI4Lw==">较好的题解</span></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int f(string st)&#123;
    int res = 0;
    for(int i = 0; i &lt; st.size(); i++)&#123;
        if(st[i] != &#39;x&#39;)&#123;
            int t = st[i] - &#39;1&#39;;
            res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3);
        &#125;
    &#125;
    return res;
&#125;
string bfs(string start)&#123;
    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;
    char op[4] = &#123;&#39;u&#39;, &#39;r&#39;, &#39;d&#39;, &#39;l&#39;&#125;;
    string ed = &quot;12345678x&quot;;
    unordered_map&lt;string, int&gt; dis;
    unordered_map&lt;string, pair&lt;string, char&gt;&gt; pre;
    priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; q;

    dis[start] = 0;
    q.push(&#123;f(start), start&#125;);
    while(q.size())&#123;
        auto t = q.top(); q.pop();
        if(t.second == ed) break;
        int x, y;
        for(int i = 0; i &lt; 9; i++)&#123;
            if(t.second[i] == &#39;x&#39;)&#123;
                x = i / 3, y = i % 3;
                break;
            &#125;
        &#125;
        string source = t.second;
        for(int i = 0; i &lt; 4; i++)&#123;
            int nx = x + dx[i], ny = y + dy[i];
            if(nx &gt;= 0 &amp;&amp; nx &lt; 3 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 3)&#123;
                swap(t.second[3 * nx + ny], t.second[3 * x + y]);
                if(!dis.count(t.second) || dis[t.second] &gt; dis[source] + 1)&#123;
                    dis[t.second] = dis[source] + 1;
                    pre[t.second] = &#123;source, op[i]&#125;;
                    q.push(&#123;dis[t.second] + f(t.second), t.second&#125;);
                &#125;
                swap(t.second[3 * nx + ny], t.second[3 * x + y]);
            &#125;
        &#125;
    &#125;
    string ans;
    while(ed != start)&#123;
        ans += pre[ed].second;
        ed = pre[ed].first;
    &#125;
    reverse(ans.begin(), ans.end());
    return ans;
&#125;
int main()&#123;
    string g, c, seq;
    for(int i = 0; i &lt;= 8; i++)&#123;
        cin &gt;&gt; c;
        g += c;
        if(c != &quot;x&quot;) seq += c;
    &#125;
    int t = 0;
    for(int i = 0; i &lt; seq.size(); i++)&#123;
        for(int j = i + 1; j &lt;= seq.size(); j++)&#123;
            if(seq[i] &gt; seq[j]) t++;
        &#125;
    &#125;
    if(t % 2) cout &lt;&lt; &quot;unsolvable\n&quot;;
    else cout &lt;&lt; bfs(g) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h4 id="AcWing-第-K-短路🌖"><a href="#AcWing-第-K-短路🌖" class="headerlink" title="AcWing|第 K 短路🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgwLw==">AcWing|第 K 短路</span>🌖</h4><ul><li><del>正解是可持久化可并堆</del></li><li>把当前点能扩展到的点全部加进去</li><li>弹出第 $k$ 次，即第 $k$ 小</li><li>建反向边 Dijkstra 求各点到终点的距离作为估计值 $f[u]$</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
typedef tuple&lt;int, int, int&gt; TIII;
const int N = 1010, M = 2e5 + 10;   // 需要反向建边
int n, m, S, T, K;
int h[N], rh[N], e[M], w[M], ne[M], idx;
int dist[N];
bool st[N];
void add(int h[], int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
// 反向 Dijkstra 求估价，dist 存的是该点到终点的最小距离
void dijkstra()&#123;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;
    pq.push(&#123;0, T&#125;);    // 距离，点编号
    memset(dist, 0x3f, sizeof(dist));
    dist[T] = 0;
    while(pq.size())&#123;
        auto t = pq.top(); pq.pop();
        int ver = t.second;
        if(st[ver]) continue;
        st[ver] = true;
        // 反向图上遍历
        for(int i = rh[ver]; ~i; i = ne[i])&#123;
            int to = e[i];
            if(dist[to] &gt; dist[ver] + w[i])&#123;
                dist[to] = dist[ver] + w[i];
                pq.push(&#123;dist[to], to&#125;);
            &#125;
        &#125;
    &#125;
&#125;
int astar()&#123;
    priority_queue&lt;TIII, vector&lt;TIII&gt;, greater&lt;TIII&gt;&gt; pq;
    pq.push(&#123;0 + dist[S], 0, S&#125;);
    int cnt = 0;
    if(dist[S] == 0x3f3f3f3f) return -1;
    while(pq.size())&#123;
        auto t = pq.top(); pq.pop();
        int ver = get&lt;2&gt;(t), distance = get&lt;1&gt;(t);
        if(ver == T) cnt++;
        if(cnt == K) return distance;
        // 正向扩展所有的边
        // 用起点到该点的真实距离 + 该点到终点的估价距离作为标准
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int to = e[i];
            pq.push(&#123;distance + w[i] + dist[to], distance + w[i], to&#125;);
        &#125;
    &#125;
    return -1;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    memset(rh, -1, sizeof(rh));
    for(int i = 0; i &lt; m; i++)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(h, a, b, c);
        add(rh, b, a, c);
    &#125;
    cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;
    if(S == T) K++;
    dijkstra();
    cout &lt;&lt; astar() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="DFS-之连通性模型"><a href="#DFS-之连通性模型" class="headerlink" title="DFS 之连通性模型"></a>DFS 之连通性模型</h3><h4 id="AcWing-迷宫"><a href="#AcWing-迷宫" class="headerlink" title="AcWing|迷宫"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExNC8=">AcWing|迷宫</span></h4><ul><li>第一次搜索到终点时只能求出来是否连通，不能解决最短路问题</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
bool st[N][N];
string g[N];
int n, xa, ya, xb, yb;
int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;
bool dfs(int x, int y)&#123;
    if(g[x][y] == &#39;#&#39;) return false;
    if(x == xb &amp;&amp; y == yb) return true;
    for(int i = 0; i &lt; 4; i++)&#123;
        int nx = x + dx[i], ny = y + dy[i];
        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n) continue;
        if(st[nx][ny]) continue;
        if(g[nx][ny] == &#39;#&#39;) continue;
        st[nx][ny] = true;
        if(dfs(nx, ny)) return true;
    &#125;
    return false;
&#125;
void solve()&#123;
    memset(st, 0, sizeof(st));
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
    cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;
    if(dfs(xa, ya)) cout &lt;&lt; &quot;YES\n&quot;;
    else cout &lt;&lt; &quot;NO\n&quot;;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h4 id="AcWing-红与黑"><a href="#AcWing-红与黑" class="headerlink" title="AcWing|红与黑"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExNS8=">AcWing|红与黑</span></h4><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 25;
int n, m;
bool st[N][N];
string g[N];
int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;
int dfs(int x, int y)&#123;
    int cnt = 1;
    st[x][y] = true;
    for(int i = 0; i &lt; 4; i++)&#123;
        int nx = x + dx[i], ny = y + dy[i];
        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue;
        if(st[nx][ny]) continue;
        if(g[nx][ny] == &#39;#&#39;) continue;
        st[nx][ny] = true;
        cnt += dfs(nx, ny);
    &#125;
    return cnt;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    while(cin &gt;&gt; m &gt;&gt; n)&#123;
        if(m == 0 &amp;&amp; n == 0) break;
        memset(st, 0, sizeof(st));
        int stx, sty;
        for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
        for(int i = 0; i &lt; n; i++)&#123;
            for(int j = 0; j &lt; m; j++)&#123;
                if(g[i][j] == &#39;@&#39;)&#123;
                    stx = i; sty = j;
                    break;
                &#125;
            &#125;
        &#125;
        cout &lt;&lt; dfs(stx, sty) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="DFS-之搜索顺序"><a href="#DFS-之搜索顺序" class="headerlink" title="DFS 之搜索顺序"></a>DFS 之搜索顺序</h3><ul><li>把棋盘整体当作一个状态进行变化是外部搜索</li><li>在棋盘内部进行变化是内部搜索</li></ul><h4 id="AcWing-马走日"><a href="#AcWing-马走日" class="headerlink" title="AcWing|马走日"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExOC8=">AcWing|马走日</span></h4><ul><li>每个状态对应一个节点，需要回溯</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 10;
bool st[N][N];
int ans, n, m;
int dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;, dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;
void dfs(int x, int y, int cnt)&#123;
    if(cnt == n * m)&#123;
        ans++;
        return;
    &#125;
    st[x][y] = true;
    for(int i = 0; i &lt; 8; i++)&#123;
        int nx = x + dx[i], ny = y + dy[i];
        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || st[nx][ny]) continue;
        dfs(nx, ny, cnt + 1);
    &#125;
    st[x][y] = false;
&#125;
void solve()&#123;
    int a, b;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;
    ans = 0;
    dfs(a, b, 1);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;    
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h4 id="AcWing-单词接龙"><a href="#AcWing-单词接龙" class="headerlink" title="AcWing|单词接龙"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExOS8=">AcWing|单词接龙</span></h4><ul><li>先预处理能接在某个单词后的单词和重叠长度</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 21;
int n, ans;
string word[N];
int g[N][N];
int vis[N];
void dfs(string dragon, int last)&#123;
    ans = max((int)dragon.size(), ans);
    vis[last]++;
    for(int i = 0; i &lt; n; i++)&#123;
        if(vis[i] == 2) continue;
        if(g[last][i])&#123;
            dfs(dragon + word[i].substr(g[last][i]), i);
        &#125;
    &#125;
    vis[last]--;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; word[i];
    char st;
    cin &gt;&gt; st;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            string a = word[i], b = word[j];
            for(int k = 1; k &lt; min(a.size(), b.size()); k++)&#123;
                if(a.substr(a.size() - k, k) == b.substr(0, k))&#123;
                    g[i][j] = k;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    for(int i = 0; i &lt; n; i++)&#123;
        if(word[i][0] == st) dfs(word[i], i);
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h4 id="AcWing-分成互质组"><a href="#AcWing-分成互质组" class="headerlink" title="AcWing|分成互质组"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyMC8=">AcWing|分成互质组</span></h4><ul><li>把某个数加到当前的最后一组中</li><li>新开一个组放这个数</li><li>要按照组合的方法搜索，不能按照排列的方法搜索</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 11;
int n, ans;
int num[N];
int group[N][N];
bool vis[N];
int gcd(int a, int b)&#123;
    return b ? gcd(b, a % b) : a;
&#125;
bool check(int u[], int uc, int n)&#123;
    for(int i = 0; i &lt; uc; i++)&#123;
        if(gcd(u[i], num[n]) != 1) return false;
    &#125;
    return true;
&#125;
void dfs(int u, int uc, int tot, int start)&#123;    // 当前组的编号，组内元素个数，总的元素个数，当前枚举的开始元素
    if(u &gt;= ans) return;
    if(tot == n) ans = u;
    bool flag = true;
    for(int i = start; i &lt;= n; i++)&#123;
        if(!vis[i] &amp;&amp; check(group[u], uc, i))&#123;
            vis[i] = true;
            group[u][uc] = num[i];
            dfs(u, uc + 1, tot + 1, i + 1);
            vis[i] = false;
            flag = false;
        &#125;
    &#125;
    if(flag) dfs(u + 1, 0, tot, 1);     // 新开一组需要从第一个元素开始从头枚举
&#125;
int main()&#123;
    cin &gt;&gt; n; ans = n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; num[i];
    dfs(1, 0, 0, 1);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="DFS-之剪枝与优化"><a href="#DFS-之剪枝与优化" class="headerlink" title="DFS 之剪枝与优化"></a>DFS 之剪枝与优化</h3><ol><li>优化搜索顺序<ul><li>大部分情况下，我们应该优先搜索分支较少的节点。</li></ul></li><li>排除等效冗余</li><li>可行性剪枝</li><li>最优性剪枝</li><li>记忆化搜索（DP）</li></ol><h4 id="AcWing-小猫爬山"><a href="#AcWing-小猫爬山" class="headerlink" title="AcWing|小猫爬山"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY3Lw==">AcWing|小猫爬山</span></h4><ul><li>先把小猫从大到小排序，然后枚举是否需要放入新的车</li><li>剪枝<ul><li>优化搜索顺序，先考虑放重猫</li><li>可行性剪枝，考虑重量</li><li>最优性剪枝，大于当前最优答案即可剪枝</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20;
int w[N], sum[N];
int n, k, ans;
void dfs(int u, int cnt)&#123;
    if(cnt &gt;= ans) return;
    if(u == n)&#123;
        ans = cnt;
        return;
    &#125;
    for(int i = 0; i &lt; cnt; i++)&#123;
        if(sum[i] + w[u] &lt;= k)&#123; // 可行性剪枝
            sum[i] += w[u];
            dfs(u + 1, cnt);
            sum[i] -= w[u];
        &#125;
    &#125;
    sum[cnt] = w[u];    // 新开一辆车
    dfs(u + 1, cnt + 1);
    sum[cnt] = 0;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; w[i];
    sort(w, w + n, greater&lt;int&gt;());
    ans = n;
    dfs(0, 0);
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><h4 id="AcWing-数独🌖"><a href="#AcWing-数独🌖" class="headerlink" title="AcWing|数独🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY4Lw==">AcWing|数独</span>🌖</h4><ul><li>先考虑顺序，再考虑剪枝</li><li>随意选择空格子，可以先判断没有用过的数字是哪些</li><li>剪枝<ul><li>优化搜索顺序，首先选择可用数字最少的格子</li><li>可行性剪枝，不能与当前行、列、九宫格有重复</li></ul></li><li>位运算优化<ul><li>用九位的二进制数表示该行&#x2F;列&#x2F;九宫格的状态</li><li>lowbit 运算</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 9, M = 1 &lt;&lt; N;
int one[M], mp[M]; // one 为不同状态中有几个 1，mp 为不同状态对应的十进制数
int col[N], row[N], cell[3][3];
string str;
int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;
int get(int x, int y)&#123;
    return row[x] &amp; col[y] &amp; cell[x / 3][y / 3];
&#125;
void init()&#123;    // 初始化（将所有位置都初始化为可以填数的状态
    for(int i = 0; i &lt; N; i++) row[i] = col[i] = (1 &lt;&lt; N) - 1;
    for(int i = 0; i &lt; 3; i++)&#123;
        for(int j = 0; j &lt; 3; j++)&#123;
            cell[i][j] = (1 &lt;&lt; N) - 1;
        &#125;
    &#125;
&#125;
void draw(int x, int y, int t, bool is_set)&#123;    // 在该位置上是否填 t
    if(is_set) str[x * N + y] = t + &#39;1&#39;;
    else str[x * N + y] = &#39;.&#39;;
    int v = 1 &lt;&lt; t;   // 找到该数对应二进制之后的位置的数
    if(!is_set) v = -v;
    // 在这个原数对应的位置上减去该数的二进制数
    row[x] -= v;    
    col[y] -= v;
    cell[x / 3][y / 3] -= v;
&#125;
bool dfs(int cnt)&#123;
    if(!cnt) return true;
    int minv = 10;  // 记录当前最少枚举方案
    int x, y;
    for(int i = 0; i &lt; N; i++)&#123;
        for(int j = 0; j &lt; N; j++)&#123;
            if(str[i * N + j] == &#39;.&#39;)&#123;
                int state = get(i, j);  // 找到该位置上能填的数的状态
                if(one[state] &lt; minv)&#123;
                    x = i, y = j;
                    minv = one[state];
                &#125;
            &#125;
        &#125;
    &#125;
    int state = get(x, y);
    for(int i = state; i; i-= lowbit(i))&#123;   // 枚举该位置上能填的数
        int t = mp[lowbit(i)];
        draw(x, y, t, true);
        if(dfs(cnt - 1)) return true;
        draw(x, y, t, false);
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    for(int i = 0; i &lt; N; i++) mp[1 &lt;&lt; i] = i;
    for(int i = 0; i &lt; 1 &lt;&lt; N; i++)&#123;
        for(int j = 0; j &lt; N; j++)&#123;
            one[i] += (i &gt;&gt; j) &amp; 1;
        &#125;
    &#125;
    while(cin &gt;&gt; str, str[0] != &#39;e&#39;)&#123;
        init();
        int cnt = 0;    // 记录有几个空格需要填数
        for(int i = 0, k = 0; i &lt; N; i++)&#123;
            for(int j = 0; j &lt; N; j++, k++)&#123;
                if(str[k] != &#39;.&#39;)&#123;
                    int t = str[k] - &#39;1&#39;;
                    draw(i, j, t, true);
                &#125;else cnt++;
            &#125;
        &#125;
        dfs(cnt);
        cout &lt;&lt; str &lt;&lt; endl;
    &#125;
&#125;
</code></pre><h4 id="AcWing-木棍"><a href="#AcWing-木棍" class="headerlink" title="AcWing|木棍"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY5Lw==">AcWing|木棍</span></h4><ul><li>枚举拼接的木棒的长度</li><li>剪枝<ul><li>只枚举 sum 能整除的长度</li><li>优化搜索顺序，先枚举较长的木棍</li><li>排除等效冗余<ul><li>按照组合数方式枚举</li><li>如果当前木棍加到当前木棒失败则直接略过，后面所有等长的也都略过</li><li>如果某木棒放第一根木棍 $u$ 导致当前这根木棒凑不成 $length$, 整个方案一定失败</li><li>如果木棒的最后一根木棍 $u$ 放在这里导致后续方案失败, 则整个方案一定失败</li></ul></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 70;
int w[N], sum, length, n;
bool st[N];
bool dfs(int u, int part, int start)&#123;
    if(u * length == sum) return true;
    if(part == length) return dfs(u + 1, 0, 0);
    for(int i = start; i &lt;= n; i++)&#123;
        if(st[i] || w[i] + part &gt; length) continue;
        st[i] = true;
        if(dfs(u, part + w[i], i + 1)) return true;
        st[i] = false;
        if(!part) return false; // 第一根失败
        if(w[i] + part == length) return false; // 最后一根失败
        int j = i;
        while(j &lt;= n &amp;&amp; w[j] == w[i]) j++;
        i = j - 1;
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    while(cin &gt;&gt; n, n)&#123;
        memset(st, false, sizeof(st));
        sum = 0, length = 1;
        for(int i = 1; i &lt;= n; i++)&#123;
            cin &gt;&gt; w[i];
            sum += w[i];
        &#125;
        sort(w + 1, w + n + 1, greater());
        while(1)&#123;   // 枚举 length
            if(sum % length == 0 &amp;&amp; dfs(0, 0, 0))&#123;
                cout &lt;&lt; length &lt;&lt; endl;
                break;
            &#125;
            length++;
        &#125;
    &#125;
&#125;
</code></pre><h4 id="AcWing-生日蛋糕"><a href="#AcWing-生日蛋糕" class="headerlink" title="AcWing|生日蛋糕"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTcwLw==">AcWing|生日蛋糕</span></h4><ul><li>优化搜索顺序，自底向上搜，从大到小枚举半径和高度，半径优先于高度（ $R^2,h$ ）</li><li>可行性剪枝（可以有更严格的上界）<ul><li>$U \le R_U \le min \left { \sqrt{N - V}，R_{U + 1} - 1 \right }$</li><li>$U \le H_U \le min \left { \frac{N - V}{R^2} ，H_{U + 1} - 1 \right }$</li></ul></li><li>最优性剪枝<ul><li>$S_{1 \sim U} &#x3D; \sum_{k &#x3D; 1}^{U} 2 \times R_k H_k &#x3D; \frac{2}{R_{U + 1}} \sum_{k &#x3D; 1}^{U} R_k H_k R_{U + 1} \ge \frac{2}{R_{U + 1}} \sum_{k &#x3D; 1}^{U} R_{k}^2 H_k &#x3D; \frac{2 (N - V)}{R_{U + 1}}$</li><li>因此 $S + \frac{2(N - V)}{R_{U + 1}} \ge S_{ans}$ 时即可剪枝</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e4 + 10;
int H[N], R[N]; // 记录每层的高和半径，每次搜索需要用到上一层的高度和半径
int minS[N], minV[N];
int n, m, ans = 1e9;
void dfs(int u, int v, int s)&#123;
    if(v + minV[u] &gt; N) return;
    if(s + minS[u] &gt;= ans) return;
    if(s + 2 * (n - v) / R[u + 1] &gt;= ans) return;
    if(!u)&#123;
        if(v == n) ans = s;
        return;
    &#125;
    for(int r = min(R[u + 1] - 1, (int)sqrt(n - v)); r &gt;= u; r--)&#123;
        for(int h = min(H[u + 1] - 1, (n - v) / r / r); h &gt;= u; h--)&#123;
            H[u] = h, R[u] = r;
            int t = 0;
            if(u == m) t = r * r;   // 最底下一层需要加上整个上表面面积
            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);
        &#125;
    &#125;
&#125;
int main()&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;    // 预处理前面几层最小值
        minS[i] = minS[i - 1] + 2 * i * i;
        minV[i] = minV[i - 1] + i * i * i;
    &#125;
    R[m + 1] = H[m + 1] = 1e9;
    dfs(m, 0, 0);
    if(ans == 1e9) ans = 0;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><h3 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h3><ul><li><del>面向深度剪枝</del></li><li>节省空间、时间</li></ul><h4 id="AcWing-加成序列"><a href="#AcWing-加成序列" class="headerlink" title="AcWing|加成序列"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTcyLw==">AcWing|加成序列</span></h4><ul><li>优化搜索顺序，从大到小枚举下一个数</li><li>排除等效冗余，某个数被枚举过了就不用再枚举了</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
int path[N];
int n;
bool dfs(int u, int depth)&#123;
    if(u &gt; depth) return false;
    if(path[u - 1] == n) return true;
    bool st[N] = &#123;0&#125;;
    for(int i = u - 1; i &gt;= 0; i--)&#123;
        for(int j = i; j &gt;= 0; j--)&#123;
            int t = path[i] + path[j];
            if(st[t] || t &lt; path[u - 1] || t &gt; n) continue;
            st[t] = true;
            path[u] = t;
            if(dfs(u + 1, depth)) return true;
        &#125;
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    path[0] = 1;
    while(cin &gt;&gt; n, n)&#123;
        int depth = 1;
        while(!dfs(1, depth)) depth++;
        for(int i = 0; i &lt; depth; i++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="双向-DFS"><a href="#双向-DFS" class="headerlink" title="双向 DFS"></a>双向 DFS</h3><ul><li>与双向 BFS 原理相同</li></ul><h4 id="AcWing-送礼物"><a href="#AcWing-送礼物" class="headerlink" title="AcWing|送礼物"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTczLw==">AcWing|送礼物</span></h4><ul><li>用空间换时间<ul><li>先枚举前一半物品能凑出来的重量</li><li>DFS 后一半物品，搜索能否有一种方案加上前面凑出来的重量使得答案最大</li><li>排序 + 二分优化时间复杂度</li></ul></li><li>将所有物品按重量从大到小排序</li><li>先将前 $K$ 件物品的选择方式，然后在表中二分出不超过 $W$ 的最大值</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 50;
int w[N], weight[1 &lt;&lt; 25];
LL n, cnt = 1, W, k, ans;
void dfs1(int u, int sum)&#123;
    if(u == k)&#123;
        weight[cnt++] = sum;
        return;
    &#125;
    dfs1(u + 1, sum);
    if((LL)sum + w[u] &lt;= W) dfs1(u + 1, sum + w[u]);
&#125;
void dfs2(int u, int sum)&#123;
    if(u == n)&#123;     // 二分找满足条件的最大值
        int l = 0, r = cnt - 1;
        while(l &lt; r)&#123;
            int mid = (l + r + 1) &gt;&gt; 1;
            if((LL)weight[mid] + sum &lt;= W) l = mid;
            else r = mid - 1;
        &#125;
        ans = max(ans, (LL)weight[l] + sum);
        return;
    &#125;
    dfs2(u + 1, sum);
    if((LL)sum + w[u] &lt;= W) dfs2(u + 1, sum + w[u]);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; W &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; w[i];
    if(n &gt;= 2) k = n / 2 + 2;
    sort(w, w + n, greater());
    dfs1(0, 0);
    sort(weight, weight + cnt);
    cnt = unique(weight, weight + cnt) - weight;    // 去重
    dfs2(k, 0);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h3><ul><li>类似 A*</li><li>证明较 A* 简单</li><li>通常配合迭代加深</li><li>预估当前这个点需要多少步才能到达<ul><li>估价函数 $\le$ 真实值</li></ul></li><li><em>优点</em><ol><li>空间开销小：每个深度下实际上是一个深度优先搜索，不过深度有限制，使用 DFS 可以减小空间消耗；</li><li>利于深度剪枝。</li></ol></li><li><em>缺点</em><ol><li>重复搜索：即使前后两次搜索相差微小，回溯过程中每次深度变大都要再次从头搜索。</li></ol></li></ul><h4 id="AcWing-排书"><a href="#AcWing-排书" class="headerlink" title="AcWing|排书"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgyLw==">AcWing|排书</span></h4><ul><li>可以采用双向 BFS，也可以使用 IDA*</li><li>之后设计估价函数，考虑排序后每个数的后继，$i$ 的后继应该是 $i + 1$，同时，每次操作我们最多更改 $3$ 个元素的后继关系</li><li>每次递归前，我们可以计算出当前有多少个后继关系是不正确的，记当前序列一共有 $tot$ 个后继不正确，则修复这些后继需要的最少步数为 $\left \lceil \frac{tot}{3} \right \rceil$</li><li>如果当前深度加上估价函数的值大于迭代加深的最大深度时，则直接回溯。</li><li>我们每次只需要枚举将长度为 $i$ 的书放到某个位置即可</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20;
int n;
int q[N], w[6][N];  // 书的编号，恢复现场
int f()&#123;    // 估价函数
    int tot = 0;
    for(int i = 1; i + 1 &lt;= n; i++)&#123;
        if(q[i + 1] != q[i] + 1) tot++;
    &#125;
    return (tot + 2) / 3;
&#125;
bool dfs(int u, int depth)&#123;
    if(u + f() &gt; depth) return false;
    if(f() == 0) return true;
    for(int len = 1; len &lt;= n; len++)&#123;
        for(int l = 1; l + len - 1 &lt;= n; l++)&#123;
            int r = l + len - 1;
            for(int k = r + 1; k &lt;= n; k++)&#123;
                memcpy(w[u], q, sizeof(q));
                int x, y;
                for(x = r + 1, y = l; x &lt;= k; x++, y++) q[y] = w[u][x];
                for(x = l; x &lt;= r; x++, y++) q[y] = w[u][x];
                if(dfs(u + 1, depth)) return true;
                memcpy(q, w[u], sizeof(q));
            &#125;
        &#125;
    &#125;
    return false;
&#125;
void solve()&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; q[i];
    int depth = 0;  // 可能初始就是排好的
    while(depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth++;
    if(depth &gt;= 5) cout &lt;&lt; &quot;5 or more\n&quot;;
    else cout &lt;&lt; depth &lt;&lt; &#39;\n&#39;;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h4 id="AcWing-回转游戏🌖"><a href="#AcWing-回转游戏🌖" class="headerlink" title="AcWing|回转游戏🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgzLw==">AcWing|回转游戏</span>🌖</h4><ul><li>估价函数：<ul><li>统计中间 $8$ 个方格中出现次数最多的数的个数，记为 $k$</li><li>每次操作会从中间 $8$ 个方格中移出一个数，再移入一个数，所以最多会减少一个不同的数</li><li>因此估价函数可以设为 $8 - k$</li></ul></li><li>剪枝<ul><li>记录上一次的操作，避免枚举上一次的逆操作</li></ul></li></ul><pre><code class="cpp">/*
      0     1
      2     3
4  5  6  7  8  9  10
      11    12
13 14 15 16 17 18 19
      20    21
      22    23
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 24;
int q[N];
int op[8][7] = &#123;
    &#123;0, 2, 6, 11, 15, 20, 22&#125;,
    &#123;1, 3, 8, 12, 17, 21, 23&#125;,
    &#123;10, 9, 8, 7, 6, 5, 4&#125;,
    &#123;19, 18, 17, 16, 15, 14, 13&#125;,
    &#123;23, 21, 17, 12, 8, 3, 1&#125;,
    &#123;22, 20, 15, 11, 6, 2, 0&#125;,
    &#123;13, 14, 15, 16, 17, 18, 19&#125;,
    &#123;4, 5, 6, 7, 8, 9, 10&#125;,
&#125;;
int center[8] = &#123;6, 7, 8, 11, 12, 15, 16, 17&#125;;
int opposite[8] = &#123;5, 4, 7, 6, 1, 0, 3, 2&#125;;
int path[100];
int f()&#123;
    int sum[4] = &#123;0&#125;;
    for(int i = 0; i &lt; 8; i++) sum[q[center[i]]]++;
    int cnt = 0;
    for(int i = 1; i &lt;= 3; i++) cnt = max(cnt, sum[i]);
    return 8 - cnt;
&#125;
void operation(int x)&#123;
    for(int i = 0; i &lt; 6; i++) swap(q[op[x][i]], q[op[x][i + 1]]);
&#125;
bool dfs(int u, int depth, int last)&#123;
    if(f() + u &gt; depth) return false;
    if(f() == 0) return true;
    for(int i = 0; i &lt; 8; i++)&#123;
        if(opposite[i] == last) continue;
        operation(i);
        path[u] = i;
        if(dfs(u + 1, depth, i)) return true;
        operation(opposite[i]);
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    while(cin &gt;&gt; q[0], q[0])&#123;
        for(int i = 1; i &lt; N; i++) cin &gt;&gt; q[i];
        int depth = 0;
        while(!dfs(0, depth, -1)) depth++;
        if(!depth) cout &lt;&lt; &quot;No moves needed&quot;;
        for(int i = 0; i &lt; depth; i++) cout &lt;&lt; char(path[i] + &#39;A&#39;);
        cout &lt;&lt; &#39;\n&#39; &lt;&lt; q[6] &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E9%A2%98%E9%9B%86/" rel="tag"><i class="ic i-tag"></i> 题集</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-07 09:04:59" itemprop="dateModified" datetime="2022-09-07T09:04:59+08:00">2022-09-07</time> </span><span id="post/搜索题集.html" class="item leancloud_visitors" data-flag-title="搜索题集" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" title="搜索题集">https://asterzc19.github.io/post/搜索题集.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;06&#x2F;7f6edf1d98b0d8a0.jpg" title="动态规划题集"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>动态规划题集</h3></a></div><div class="item right"><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;44d29b2c5b4e40c8.jpg" title="图论题集"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>图论题集</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-number">1.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flood-Fill"><span class="toc-number">1.1.</span> <span class="toc-text">Flood Fill</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E6%B1%A0%E5%A1%98%E8%AE%A1%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">AcWing|池塘计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%9F%8E%E5%A0%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">AcWing|城堡问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%B1%B1%E5%B3%B0%E5%92%8C%E5%B1%B1%E8%B0%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">AcWing|山峰和山谷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">最短路模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">AcWing|迷宫问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E6%AD%A6%E5%A3%AB%E9%A3%8E%E5%BA%A6%E7%9A%84%E7%89%9B"><span class="toc-number">1.2.2.</span> <span class="toc-text">AcWing|武士风度的牛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B"><span class="toc-number">1.2.3.</span> <span class="toc-text">AcWing|抓住那头牛</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90-BFS"><span class="toc-number">1.3.</span> <span class="toc-text">多源 BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E7%9F%A9%E9%98%B5%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">AcWing|矩阵距离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">最小步数模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E9%AD%94%E6%9D%BF"><span class="toc-number">1.4.1.</span> <span class="toc-text">AcWing|魔板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%B9%BF%E6%90%9C"><span class="toc-number">1.5.</span> <span class="toc-text">双端队列广搜</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E7%94%B5%E8%B7%AF%E7%BB%B4%E4%BF%AE"><span class="toc-number">1.5.1.</span> <span class="toc-text">AcWing|电路维修</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C"><span class="toc-number">1.6.</span> <span class="toc-text">双向广搜</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%AD%97%E7%AC%A6%E5%8F%98%E6%8D%A2%F0%9F%8C%B8"><span class="toc-number">1.6.1.</span> <span class="toc-text">AcWing|字符变换🌸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Star"><span class="toc-number">1.7.</span> <span class="toc-text">A-Star</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%85%AB%E6%95%B0%E7%A0%81%F0%9F%8C%B8"><span class="toc-number">1.7.1.</span> <span class="toc-text">AcWing|八数码🌸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E7%AC%AC-K-%E7%9F%AD%E8%B7%AF%F0%9F%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">AcWing|第 K 短路🌖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-number">2.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-%E4%B9%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">DFS 之连通性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E8%BF%B7%E5%AE%AB"><span class="toc-number">2.1.1.</span> <span class="toc-text">AcWing|迷宫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E7%BA%A2%E4%B8%8E%E9%BB%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">AcWing|红与黑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-%E4%B9%8B%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">DFS 之搜索顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E9%A9%AC%E8%B5%B0%E6%97%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">AcWing|马走日</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-number">2.2.2.</span> <span class="toc-text">AcWing|单词接龙</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%88%86%E6%88%90%E4%BA%92%E8%B4%A8%E7%BB%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">AcWing|分成互质组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-%E4%B9%8B%E5%89%AA%E6%9E%9D%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">DFS 之剪枝与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1"><span class="toc-number">2.3.1.</span> <span class="toc-text">AcWing|小猫爬山</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E6%95%B0%E7%8B%AC%F0%9F%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">AcWing|数独🌖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E6%9C%A8%E6%A3%8D"><span class="toc-number">2.3.3.</span> <span class="toc-text">AcWing|木棍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">AcWing|生日蛋糕</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1"><span class="toc-number">2.4.</span> <span class="toc-text">迭代加深</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%8A%A0%E6%88%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">AcWing|加成序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-DFS"><span class="toc-number">2.5.</span> <span class="toc-text">双向 DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E9%80%81%E7%A4%BC%E7%89%A9"><span class="toc-number">2.5.1.</span> <span class="toc-text">AcWing|送礼物</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDA"><span class="toc-number">2.6.</span> <span class="toc-text">IDA*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E6%8E%92%E4%B9%A6"><span class="toc-number">2.6.1.</span> <span class="toc-text">AcWing|排书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-%E5%9B%9E%E8%BD%AC%E6%B8%B8%E6%88%8F%F0%9F%8C%96"><span class="toc-number">2.6.2.</span> <span class="toc-text">AcWing|回转游戏🌖</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/data-structures/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/CodeForces/" title="分类于 CodeForces">CodeForces</a> <i class="ic i-angle-right"></i> <a href="/categories/AtCoder/" title="分类于 AtCoder">AtCoder</a></div><span><a href="/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" title="题目小集">题目小集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a></div><span><a href="/post/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html" title="位运算合集">位运算合集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/AcWing/" title="分类于 AcWing">AcWing</a></div><span><a href="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html" title="线性同余方程">线性同余方程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" title="搜索题集">搜索题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/data-structures/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF.html" title="基础数据结构模板">基础数据结构模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html" title="线段树进阶">线段树进阶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/data-structures/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a></div><span><a href="/post/algorithm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" title="基础算法模板">基础算法模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" title="网络流">网络流</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">308k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:40</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/搜索题集.html",favicon:{show:"嗨~",hide:"呜呜呜"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->