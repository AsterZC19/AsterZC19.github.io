<!-- build time:Tue Sep 06 2022 07:01:19 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,题集"><link rel="canonical" href="https://asterzc19.github.io/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>图论题集 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">图论题集</h1><div class="meta"><span class="item" title="创建时间：2022-03-14 18:00:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-14T18:00:20+08:00">2022-03-14</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>72k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:05</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/728c619db3847842.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/db894a8df07c1517.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/82a4dfcddf3ba7e0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/40c7bc0e06dce5f2.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/05ac51bc092a5a09.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p>包括单源最短路的建图方式、单源最短路的综合应用、单源最短路的扩展应用、Floyd 算法、最小生成树、最小生成树的扩展应用、负环、差分约束、最近公共祖先、强连通分量、双连通分量、二分图、欧拉回路和欧拉路径、拓扑排序等内容</p></blockquote><ul><li>图论的重点在于问题的转化和抽象</li></ul><hr><h2 id="单源最短路的建图方式"><a href="#单源最短路的建图方式" class="headerlink" title="单源最短路的建图方式"></a>单源最短路的建图方式</h2><h3 id="AcWing-热浪"><a href="#AcWing-热浪" class="headerlink" title="AcWing|热浪"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzMS8=">AcWing|热浪</span></h3><ul><li>spfa 不会被卡</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2510, M = 6200 * 2 + 10;
int h[N], e[M], ne[M], w[M], idx;
int dis[N];
bool st[N];
int n, m;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void spfa(int x)&#123;
    memset(dis, 0x3f, sizeof(dis));
    dis[x] = 0;
    st[x] = true;
    queue&lt;int&gt; q;
    q.push(x);
    while(!q.empty())&#123;
        int u = q.front(); q.pop();
        st[u] = false;
        for(int i = h[u]; ~i; i = ne[i])&#123;
            int v = e[i];
            if(dis[u] + w[i] &lt; dis[v])&#123;
                dis[v] = dis[u] + w[i];
                if(!st[v])&#123;
                    st[v] = true;
                    q.push(v);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int start, end;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; end;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c); add(b, a, c);
    &#125;
    spfa(start);
    cout &lt;&lt; dis[end] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-信使"><a href="#AcWing-信使" class="headerlink" title="AcWing|信使"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzMC8=">AcWing|信使</span></h3><ul><li>对于每个点来说，它接收到信的时间，等于它到指挥部的最短距离</li><li>数据范围很小，可以直接用 Floyd</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 110, M = 210 * 2 + 10;
int h[N], e[M], ne[M], w[M], idx;
int dis[N];
bool st[N];
int n, m;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int dijkstra(int x)&#123;
    memset(dis, 0x3f, sizeof(dis));
    dis[x] = 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;
    q.push(&#123;0, x&#125;);
    while(q.size())&#123;
        auto t = q.top(); q.pop();
        int ver = t.second, distance = t.first;
        if(st[ver]) continue;
        st[ver] = true;
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dis[j] &gt; distance + w[i])&#123;
                dis[j] = distance + w[i];
                q.push(&#123;dis[j], j&#125;);
            &#125;
        &#125;
    &#125;
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(dis[i] == 0x3f3f3f3f) return -1;
        ans = max(ans, dis[i]);
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c); add(b, a, c);
    &#125;
    cout &lt;&lt; dijkstra(1) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-香甜的黄油"><a href="#AcWing-香甜的黄油" class="headerlink" title="AcWing|香甜的黄油"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyOS8=">AcWing|香甜的黄油</span></h3><ul><li>多源汇最短路问题</li><li>以每一个牧场为终点，全部求一遍最短路之和，找到最小值即可</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 810, M = 3000;
int h[N], e[M], ne[M], w[M], idx;
int dis[N], id[N];
bool st[N];
int n, p, m;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int spfa(int x)&#123;
    memset(dis, 0x3f, sizeof(dis));
    dis[x] = 0;
    queue&lt;int&gt; q;
    q.push(x);
    st[x] = true;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dis[j] &gt; dis[t] + w[i])&#123;
                dis[j] = dis[t] + w[i];
                if(!st[j])&#123;
                    st[j] = true;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    int res = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        int j = id[i];
        if(dis[j] == 0x3f3f3f3f) return 0x3f3f3f3f;
        res += dis[j];
    &#125;
    return res;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; id[i];
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c); add(b, a, c);
    &#125;
    int ans = 0x3f3f3f3f;
    for(int i = 1; i &lt;= p; i++) ans = min(ans, spfa(i));
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-最小花费"><a href="#AcWing-最小花费" class="headerlink" title="AcWing|最小花费"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyOC8=">AcWing|最小花费</span></h3><ul><li>可以转化成从 $A$ 到 $B$ 权值乘积最大的路</li><li>对权值乘积可以取对数转换成加法，且取完对数权值全是非正，所以可以转换成最短路，用 Dijkstra 求</li><li>此处直接乘法做即可</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2010;
double g[N][N];
double dist[N];
bool st[N];
int n, m;
void dijkstra(int x)&#123;
    dist[x] = 1;
    for(int i = 1; i &lt;= n; i++)&#123;
        int t = -1;
        for(int j = 1; j &lt;= n; j++)&#123;
            if(!st[j] &amp;&amp; (t == -1 || dist[j] &gt; dist[t])) t = j;
        &#125;
        st[t] = 1;
        for(int j = 1; j &lt;= n; j++)&#123;
            dist[j] = max(dist[j], dist[t] * g[t][j]);
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cout &lt;&lt; fixed &lt;&lt; setprecision(8);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        double t = (100 - z) / 100.0;
        g[x][y] = g[y][x] = max(g[x][y], t);
    &#125;
    int start, end; cin &gt;&gt; start &gt;&gt; end;
    dijkstra(start);
    cout &lt;&lt; (100 / dist[end]) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-最优乘车"><a href="#AcWing-最优乘车" class="headerlink" title="AcWing|最优乘车"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTIyLw==">AcWing|最优乘车</span></h3><ul><li>每趟巴士的所有站之间可以建立一条权值为 $1$ 的有向边，换乘数可以转换成从起点坐到终点的权值 $-1$</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 510;
bool g[N][N];
int dist[N];
int stop[N];
int n, m;
void bfs()&#123;
    queue&lt;int&gt; q;
    memset(dist, 0x3f, sizeof(dist));
    q.push(1);
    dist[1] = 0;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        for(int i = 1; i &lt;= n; i++)&#123;
            if(g[t][i] &amp;&amp; dist[i] &gt; dist[t] + 1)&#123;
                dist[i] = dist[t] + 1;
                q.push(i);
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; m &gt;&gt; n;
    string line;
    getline(cin, line);
    while(m--)&#123;
        getline(cin, line);
        stringstream ssin(line);
        int cnt = 0, p;
        while(ssin &gt;&gt; p) stop[++cnt] = p;
        for(int j = 1; j &lt;= cnt; j++)&#123;
            for(int k = j + 1; k &lt;= cnt; k++)&#123;
                g[stop[j]][stop[k]] = true;
            &#125;
        &#125;
    &#125;
    bfs();
    if(dist[n] == 0x3f3f3f3f) cout &lt;&lt; &quot;NO\n&quot;;
    else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-昂贵的聘礼"><a href="#AcWing-昂贵的聘礼" class="headerlink" title="AcWing|昂贵的聘礼"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTA1Lw==">AcWing|昂贵的聘礼</span></h3><ul><li>可以设置一个虚拟源点，边权全为原价购买的价格</li><li>枚举不同等级区间内的最短路，取最小值</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110, INF = 0x3f3f3f3f;
int n, m;
int w[N][N], level[N];
int dist[N];
bool st[N];
int dijkstra(int down, int up)&#123;
    memset(dist, 0x3f, sizeof(dist));
    memset(st, 0, sizeof(st));
    dist[0] = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        int t = -1;
        for(int j = 0; j &lt;= n; j++)&#123;
            if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;
        &#125;
        st[t] = 1;
        for(int j = 1; j &lt;= n; j++)&#123;
            if(level[j] &gt;= down &amp;&amp; level[j] &lt;= up)&#123;
                dist[j] = min(dist[j], dist[t] + w[t][j]);
            &#125;
        &#125;
    &#125;
    return dist[1];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; m &gt;&gt; n;
    memset(w, 0x3f, sizeof(w));
    for(int i = 1; i &lt;= n; i++)&#123;
        w[i][i] = 0;
        int price, cnt;
        cin &gt;&gt; price &gt;&gt; level[i] &gt;&gt; cnt;
        w[0][i] = min(price, w[0][i]);
        while(cnt--)&#123;
            int id, cost;
            cin &gt;&gt; id &gt;&gt; cost;
            w[id][i] = min(w[id][i], cost);
        &#125;
    &#125;
    int ans = INF;
    for(int i = level[1] - m; i &lt;= level[1]; i++)&#123;
        ans = min(ans, dijkstra(i, i + m));
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h2 id="单源最短路的综合应用"><a href="#单源最短路的综合应用" class="headerlink" title="单源最短路的综合应用"></a>单源最短路的综合应用</h2><ul><li>单源最短路与其他算法的结合<ul><li>DFS</li><li>二分</li><li>DP</li><li>拓扑排序</li></ul></li></ul><h3 id="AcWing-新年好"><a href="#AcWing-新年好" class="headerlink" title="AcWing|新年好"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzNy8=">AcWing|新年好</span></h3><ul><li>最短路与 DFS 的结合</li><li>先预处理最短路，之后 DFS 拜访顺序<ul><li>先预处理出从 $1, a, b, c, d, e$ 出发到其他所有点的单源最短路径</li><li>DFS 所有拜访顺序 $5!$，对于每一种拜访顺序，可以通过查表的方式算出最短距离</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 50010, M = 200010, INF = 0x3f3f3f3f;
int h[N], e[M], ne[M], w[M], idx;
int dist[6][N], source[6];
bool st[N];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void dijkstra(int start, int dist[])&#123;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;
    memset(st, 0, sizeof(st));
    dist[start] = 0;
    pq.push(&#123;0, start&#125;);
    while(pq.size())&#123;
        auto t = pq.top(); pq.pop();
        int ver = t.second, distance = t.first;
        if(st[ver]) continue;
        st[ver] = 1;
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &gt; distance + w[i])&#123;
                dist[j] = distance + w[i];
                pq.push(&#123;dist[j], j&#125;);
            &#125;
        &#125;
    &#125;
&#125;
int dfs(int u, int start, int dis)&#123;
    if(u &gt; 5) return dis;
    int ans = INF;
    for(int i = 1; i &lt;= 5; i++)&#123;
        if(!st[i])&#123;
            int nxt = source[i];
            st[i] = 1;
            ans = min(ans, dfs(u + 1, i, dis + dist[start][nxt]));
            st[i] = 0;
        &#125;
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    memset(dist, 0x3f, sizeof(dist));
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= 5; i++) cin &gt;&gt; source[i];
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c), add(b, a, c);
    &#125;
    source[0] = 1;	// 从这里出发
    for(int i = 0; i &lt;= 5; i++) dijkstra(source[i], dist[i]);
    memset(st, 0, sizeof(st));
    cout &lt;&lt; dfs(1, 0, 0) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-通信线路"><a href="#AcWing-通信线路" class="headerlink" title="AcWing|通信线路"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQyLw==">AcWing|通信线路</span></h3><ul><li>判断是否能二分的条件是，查找的值是否在分界点上，即分界点左边满足这个性质，右边不满足这个性质<ul><li>定义在 $[0, 1000001]$ 这个区间中的性质如下</li><li>对于区间中的某一个点 $x$，求出从 $1 \sim N$ 中最少经过几条长度大于 $x$ 的边，假设有 $cnt$ 条，是否满足 $cnt \le k$</li></ul></li><li>求出从 $1$ 到 $N$ 最少经过几条长度大于 $x$ 的边，可以将所有边分类：如果边长大于 $x$，则边权看成 $1$，否则边权为 $0$<ul><li>因此可以使用双端队列 BFS 来求最短路，时间复杂度 $O(n)$</li></ul></li><li>因此本题即为 <strong>双端队列 + 二分</strong></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1010, M = 20010;
int h[N], e[M], ne[M], w[M], idx;
int dist[N];
bool st[N];
int n, m, k;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool bfs(int x)&#123;
    memset(st, 0, sizeof(st));
    memset(dist, 0x3f, sizeof(dist));
    deque&lt;int&gt; q;
    q.push_back(1);
    dist[1] = 0;
    while(q.size())&#123;
        auto t = q.front(); q.pop_front();
        if(st[t]) continue;
        st[t] = 1;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i], v = w[i] &gt; x;
            if(dist[j] &gt; dist[t] + v)&#123;
                dist[j] = dist[t] + v;
                if(!v) q.push_front(j);
                else q.push_back(j);
            &#125;
        &#125;
    &#125;
    return dist[n] &lt;= k;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    while(m--)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c), add(b, a, c);
    &#125;
    int l = 0, r = 1e6 + 1;     // r 比边界多 1 判断是否有解
    while(l &lt; r)&#123;
        int mid = l + r &gt;&gt; 1;
        if(bfs(mid)) r = mid;
        else l = mid + 1;
    &#125;
    if(r == 1e6 + 1) cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else cout &lt;&lt; r &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-道路与航线🌖🌖"><a href="#AcWing-道路与航线🌖🌖" class="headerlink" title="AcWing|道路与航线🌖🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ0Lw==">AcWing|道路与航线</span>🌖🌖</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9hY3Rpdml0eS9jb250ZW50L2NvZGUvY29udGVudC8yNzI2Njgv">详细题解</span></li><li>道路是双向，边权非负，航线是单向，边权可正可负，但没有自环</li><li><strong>$spfa$ 会被卡掉</strong></li><li>可以把只有道路的几个节点看成一个团，团内用 Dijkstra，团与团之间用拓扑序处理</li><li>单源最短路 + 拓扑排序</li><li>先输入所有双向道路，然后 DFS 出所有连通块，计算两个数组：<em>id</em> 存储每个点属于哪个连通块，<em>block</em> 存储每个连通块里有哪些点</li><li>输入所有航线，同时统计出每个连通块的入度</li><li>按照拓扑序依次处理每个连通块，先将所有入度为 $0$ 的连通块的编号加入队列中，每次从队头取出一个连通块的编号 $bid$，将该 $block[bid]$ 中的所有点加入堆中，然后对堆中所有跑 Dijkstra，每次取出堆中距离最小的点 $ver$，然后遍历 $ver$ 的所有邻点 $j$，如果 $id[ver] &#x3D; id[j]$，那么如果 $j$ 能被更新，则将 $j$ 插入堆中；如果 $id[ver] \ne id[j]$，则将 $id[j]$ 这个连通块的入度减去 $1$ ，如果减成 $0$ 了，则将其插入拓扑排序的队列中</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 25010, M = 150010, INF = 0x3f3f3f3f;
int n, mr, mp, S;
int id[N];
int h[N], e[M], w[M], ne[M], idx;
int dist[N], din[N];
vector&lt;int&gt; block[N];
int bcnt;
bool st[N];
queue&lt;int&gt; q;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u, int bid)&#123;
    id[u] = bid, block[bid].push_back(u);
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!id[j]) dfs(j, bid);
    &#125;
&#125;
void dijkstra(int bid)&#123;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;
    for(auto u : block[bid]) pq.push(&#123;dist[u], u&#125;);
    while(pq.size())&#123;
        auto t = pq.top(); pq.pop();
        int ver = t.second, distance = t.first;
        if(st[ver]) continue;
        st[ver] = 1;
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(id[j] != id[ver] &amp;&amp; --din[id[j]] == 0) q.push(id[j]);
            if(dist[j] &gt; dist[ver] + w[i])&#123;
                dist[j] = dist[ver] + w[i];
                if(id[j] == id[ver]) pq.push(&#123;dist[j], j&#125;);
            &#125;
        &#125;
    &#125;
&#125;
void topsort()&#123;
    memset(dist, 0x3f, sizeof(dist));
    dist[S] = 0;
    for(int i = 1; i &lt;= bcnt; i++)&#123;
        if(!din[i]) q.push(i);
    &#125;
    while(q.size())&#123;
        auto t = q.front(); q.pop();
        dijkstra(t);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; S;
    memset(h, -1, sizeof(h));
    while(mr--)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c), add(b, a, c);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!id[i]) dfs(i, ++bcnt);
    &#125;
    while(mp--)&#123;
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        din[id[b]]++;
        add(a, b, c);
    &#125;
    topsort();
    for(int i = 1; i &lt;= n; i++)&#123;
        if(dist[i] &gt; INF / 2) cout &lt;&lt; &quot;NO PATH\n&quot;;
        else cout &lt;&lt; dist[i] &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-最优贸易"><a href="#AcWing-最优贸易" class="headerlink" title="AcWing|最优贸易"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQzLw==">AcWing|最优贸易</span></h3><ul><li>结合 DP 思想，枚举分界点 $k$ 分开买卖区域，分界点也可买卖<ul><li>由于不是拓扑图，状态的更新可能存在环，因此不能使用动态规划，只能使用最短路的方法</li><li>求 $1 \to k$ 买入的最小值，$k \to n$ 卖出的最大值</li><li>通过取能走到 $k$ 的路中买入的最小值，求出在 $k$ 分界点前买入的最小值</li><li>建反向图，求 $n \to k$ 的路中卖出的最大值</li></ul></li><li>能用 Dijkstra 的核心是从堆中取出的最小值一定不会在之后被更新，而此题无法保证这个条件，因此能用 Bellman-ford，迭代 $k$ 次，可以求出边数不超过 $k - 1$ 条的最短路</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, M = 2e6 + 10;
int w[N];
int hs[N], he[N], e[M], ne[M], idx;
int n, m;
int dmin[N], dmax[N];
bool st[N];
void add(int h[], int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void spfa(int dist[], bool ok, int h[])&#123;
    queue&lt;int&gt; q;
    if(ok == 0)&#123;
        memset(dist, 0x3f, sizeof(dmin));   // 注意初始化的 sizeof
        dist[1] = w[1];
        q.push(1);
    &#125;else&#123;
        memset(dist, -0x3f, sizeof(dmax));
        dist[n] = w[n];
        q.push(n);
    &#125;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        st[t] = 0;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(ok == 0 &amp;&amp; dist[j] &gt; min(dist[t], w[j]) || ok == 1 &amp;&amp; dist[j] &lt; max(dist[t], w[j]))&#123;
                dist[j] = (ok == 0 ? min(dist[t], w[j]) : max(dist[t], w[j]));
                if(!st[j])&#123;
                    st[j] = 1;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(hs, -1, sizeof(hs));
    memset(he, -1, sizeof(he));

    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    for(int i = 1; i &lt;= m; i++)&#123;
        int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        if(z == 1) add(hs, x, y), add(he, y, x);
        else add(hs, x, y), add(he, y, x), add(hs, y, x), add(he, x, y);
    &#125;
    spfa(dmin, 0, hs);
    spfa(dmax, 1, he);
    int ans = 0;
    for(int i = 1; i &lt;= n; i++) ans = max(ans, dmax[i] - dmin[i]);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h2 id="单源最短路的扩展应用"><a href="#单源最短路的扩展应用" class="headerlink" title="单源最短路的扩展应用"></a>单源最短路的扩展应用</h2><ul><li>BFS 每个点只入队一次，只出队一次。可以抽象成拓扑图，因为它可以保证被更新的点的父节点一定已经是最短距离了，并且这个点的条数已经被完全更新过了</li><li>Dijkstra 每个点只出队一次。也可以抽象成拓扑图，同理由于每一个出队的点一定已经是最短距离，并且它出队的时候是队列中距离最小的点，这就代表他的最短距离条数已经被完全更新了，所以构成拓扑性质</li><li>Bellman-ford 本身不具备拓扑序，因为更新它的点不一定是最短距离，所以会出错</li></ul><h3 id="AcWing-选择最佳路线"><a href="#AcWing-选择最佳路线" class="headerlink" title="AcWing|选择最佳路线"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzOS8=">AcWing|选择最佳路线</span></h3><ul><li>可以建反向边，把终点当作起点</li><li>本题采用一种适用于多个起点和多个终点的做法<ul><li>假想一个虚拟源点，向每个起点连一个边权为 $0$ 的边</li><li>问题转化为：从虚拟源点出发到终点的最短路径</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 1010, M = 21010, INF = 0x3f3f3f3f;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
bool st[N];
int n, m, s;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int dijkstra()&#123;
    memset(dist, 0x3f, sizeof(dist));
    memset(st, 0, sizeof(st));
    dist[0] = 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;
    pq.push(&#123;0, 0&#125;);
    while(pq.size())&#123;
        auto [dis, ver] = pq.top(); pq.pop();
        if(st[ver]) continue;
        st[ver] = 1;
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &gt; dis + w[i])&#123;
                dist[j] = dis + w[i];
                pq.push(&#123;dist[j], j&#125;);
            &#125;
        &#125;
    &#125;
    if(dist[s] == INF) return -1;
    return dist[s];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123;
        memset(h, -1, sizeof(h));
        idx = 0;    // 别忘了初始化 idx
        for(int i = 1; i &lt;= m; i++)&#123;
            int p, q, t;
            cin &gt;&gt; p &gt;&gt; q &gt;&gt; t;
            add(p, q, t);
        &#125;
        int cnt; cin &gt;&gt; cnt;
        while(cnt--)&#123;
            int x; cin &gt;&gt; x;
            add(0, x, 0);
        &#125;
        cout &lt;&lt; dijkstra() &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-拯救大兵瑞恩🌖🌖"><a href="#AcWing-拯救大兵瑞恩🌖🌖" class="headerlink" title="AcWing|拯救大兵瑞恩🌖🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzMy8=">AcWing|拯救大兵瑞恩</span>🌖🌖</h3><ul><li><strong>拆点&#x2F;分层图</strong></li><li>仿照 DP 来考虑<ul><li>$d(x, y, state)$ 所有从起点走到 $(x, y)$ 这个格子，且当前已经拥有的钥匙是 $state$ 的所有路线的集合</li><li>$(x, y)$ 这里有一些钥匙，那么可以直接将所有钥匙拿起，<code>state | key</code>，<code>d[x, y, state | key] = min(d[x, y, state | key], d[x, y, state])</code></li><li>向上下左右四个方向走<ul><li>没有门和墙</li><li>有门，且有匹配的钥匙，坐标是 $(a, b)$ <code>d[a, b, state] = min(d[a b, state], d[x, y, state] + 1)</code></li></ul></li><li>但是会出现环形依赖，所以不能用 DP 求解</li></ul></li><li>转化成最短路问题，拿钥匙的路边权为 $0$，其他的路边权为 $1$，求 $d[n, m, 0 \sim 2^{p - 1}]$，故可以用双端队列 BFS</li><li>为了方便，将两维坐标转化成一维，墙和门直接用给的坐标建边，然后用 $set$ 存已经建的边</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 11, M = 360, P = 1 &lt;&lt; 10;
int n, m, k, p;
int h[N * N], e[M], w[M], ne[M], idx;
int g[N][N], key[N * N];
int dist[N * N][P];
bool st[N * N][P];
set&lt;PII&gt; edges;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void build()&#123;
    int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            for(int u = 0; u &lt; 4; u++)&#123;
                int x = i + dx[u], y = j + dy[u];
                if(!x || x &gt; n || !y || y &gt; m) continue;
                int a = g[i][j], b = g[x][y];
                if(!edges.count(&#123;a, b&#125;)) add(a, b, 0);
            &#125;
        &#125;
    &#125;
&#125;
// 双端队列 BFS 处理最短路
int bfs()&#123;
    memset(dist, 0x3f, sizeof(dist));
    dist[1][0] = 0;
    deque&lt;PII&gt; q;
    q.push_back(&#123;1, 0&#125;);
    while(q.size())&#123;
        auto [ver, now] = q.front(); q.pop_front();
        if(st[ver][now]) continue;
        st[ver][now] = 1;
        if(ver == n * m) return dist[ver][now];
        if(key[ver])&#123;
            int state = now | key[ver];
            if(dist[ver][state] &gt; dist[ver][now])&#123;
                dist[ver][state] = dist[ver][now];
                q.push_back(&#123;ver, state&#125;);
            &#125;
        &#125;
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(w[i] &amp;&amp; !(now &gt;&gt; w[i] - 1 &amp; 1)) continue;
            if(dist[j][now] &gt; dist[ver][now] + 1)&#123;
                dist[j][now] = dist[ver][now] + 1;
                q.push_back(&#123;j, now&#125;);
            &#125;
        &#125;
    &#125;
    return -1;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;
    for(int i = 1, t = 1; i &lt;= n; i++)&#123;     // 一维化
        for(int j = 1; j &lt;= m; j++)&#123;
            g[i][j] = t++;
        &#125;
    &#125;
    memset(h, -1, sizeof(h));
    while(k--)&#123;     // 处理门和墙
        int x1, y1, x2, y2, c;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;
        int a = g[x1][y1], b = g[x2][y2];
        edges.insert(&#123;a, b&#125;), edges.insert(&#123;b, a&#125;);
        if(c) add(a, b, c), add(b, a, c);
    &#125;
    build();    // 建立普通通道
    int s; cin &gt;&gt; s;
    while(s--)&#123;     // 状态压缩表示钥匙状态，向左偏移1，从0开始
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        key[g[x][y]] |= 1 &lt;&lt; c - 1;
    &#125;
    cout &lt;&lt; bfs() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-最短路计数🌸"><a href="#AcWing-最短路计数🌸" class="headerlink" title="AcWing|最短路计数🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzNi8=">AcWing|最短路计数</span>🌸</h3><ul><li><strong>证明待看</strong></li><li>求方案数<ul><li>可以类比 DP 求方案数</li><li>$dist[i]$ 表示到 $i$ 点的最短路，$cnt[i]$ 表示到 $i$ 点的最短路数量</li></ul></li><li>如何让最短路问题转化成拓扑序–最短路树（拓扑图）<ul><li>存下前驱点</li><li>规定一个点只能被一个前驱更新</li><li>每个点只入队一次</li></ul></li><li>假如图中存在负权边，可以使用 spfa 求出最短路径，然后再把最短路径树建出来，最后在这棵树上统计最短路径数</li><li>本题边权全为 $1$，使用 BFS 即可，对于某个点，如果能更新其距离，则更新，并将这个点的条数变成上一点对应的条数；如果说距离相等的话，距离不用更新，条数累加起来</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, M = 4e5 + 10, MOD = 100003;
int h[N], e[M], ne[M], idx;
int dist[N], cnt[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void bfs()&#123;
    memset(dist, 0x3f, sizeof(dist));
    queue&lt;int&gt; q;
    dist[1] = 0;
    cnt[1] = 1;
    q.push(1);
    while(q.size())&#123;
        int u = q.front(); q.pop();
        for(int i = h[u]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &gt; dist[u] + 1)&#123;
                dist[j] = dist[u] + 1;
                cnt[j] = cnt[u];
                q.push(j);
            &#125;else if(dist[j] == dist[u] + 1)&#123;
                cnt[j] = (cnt[j] + cnt[u]) % MOD;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    while(m--)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b); add(b, a);
    &#125;
    bfs();
    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; cnt[i] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-观光🌸"><a href="#AcWing-观光🌸" class="headerlink" title="AcWing|观光🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzg1Lw==">AcWing|观光</span>🌸</h3><ul><li><strong>证明待看</strong></li><li>求最短路径的条数，和次短路径的条数，如果次短路径长度恰好比最短路径多一，则加上次短路径的条数</li><li>$dist[i, 0&#x2F;1]$ 表示从 $1$ 到 $i$ 的最短路径&#x2F;次短路径，全部初始化为正无穷，初始时起点不存在次短路</li><li>Dijkstra 枚举城市 $t$ 可通往的城市 $j$ 时，有四种情况<ul><li>$dist[j][0] &gt; dist[t][type] + w[i]$ ：当前最短路变成次短路，更新最短路，将最短路和次短路加入优先队列</li><li>$dist[j][0] &#x3D; dist[t][type] + w[i]$ ：找到一条新的最短路，更新最短路条数</li><li>$dist[j][1] &gt; dist[t][type] + w[i]$ ：找到一条更短的次短路，覆盖掉当前次短路，加入优先队列</li><li>$dist[j][1] &#x3D; dist[t][type] + w[i]$ ：找到一条新的次短路，更新次短路条数</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1010, M = 10010;
typedef tuple&lt;int, int, int&gt; TIII;
int h[N], e[M], ne[M], w[M], idx;
int dist[N][2], cnt[N][2];
bool st[N][2];
int n, m, S, F;
void add(int a, int b, int c)&#123;
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
&#125;
int dijkstra()&#123;
    memset(dist, 0x3f, sizeof(dist));
    memset(cnt, 0, sizeof(cnt));
    memset(st, 0, sizeof(st));
    priority_queue&lt;TIII, vector&lt;TIII&gt;, greater&lt;TIII&gt;&gt; pq;
    dist[S][0] = 0;
    cnt[S][0] = 1;
    pq.push(&#123;0, 0, S&#125;);
    while(pq.size())&#123;
        auto [dis1, type, ver] = pq.top(); pq.pop();
        if(st[ver][type]) continue;
        st[ver][type] = true;
        for(int i = h[ver]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j][0] &gt; dis1 + w[i])&#123;
                dist[j][1] = dist[j][0], cnt[j][1] = cnt[j][0];
                pq.push(&#123;dist[j][1], 1, j&#125;);
                dist[j][0] = dis1 + w[i], cnt[j][0] = cnt[ver][type];
                pq.push(&#123;dist[j][0], 0, j&#125;);
            &#125;else if(dist[j][0] == dis1 + w[i])&#123;
                cnt[j][0] = (cnt[j][0] + cnt[ver][type]);
                pq.push(&#123;dist[j][0], 0, j&#125;);
            &#125;else if(dist[j][1] &gt; dis1 + w[i])&#123;
                dist[j][1] = dis1 + w[i], cnt[j][1] = cnt[ver][type];
                pq.push(&#123;dist[j][1], 1, j&#125;);
            &#125;else if(dist[j][1] == dis1 + w[i])&#123;
                cnt[j][1] = (cnt[j][1] + cnt[ver][type]);
                pq.push(&#123;dist[j][1], 1, j&#125;);
            &#125;
        &#125;
    &#125;
    int ans = cnt[F][0];
    if(dist[F][1] == dist[F][0] + 1) ans += cnt[F][1];
    return ans;
&#125;
void solve()&#123;
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b, c; 
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    &#125;
    cin &gt;&gt; S &gt;&gt; F;
    cout &lt;&lt; dijkstra() &lt;&lt; &#39;\n&#39;;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><hr><h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><ul><li>应用<ul><li>最短路</li><li>传递闭包</li><li>找最小环（一般是正权）</li><li>恰好经过 $k$ 条边的最短路（倍增）</li></ul></li><li>原理<ul><li>基于 DP</li><li>状态表示 $d[k, i, j]$<ul><li>集合：所有从 $i$ 出发，最终走到 $j$，且中间只经过节点编号不超过 $k$ 的所有路径</li><li>属性：路径长度的最小值</li></ul></li><li>状态计算<ul><li>分为两类，所有不包含节点 $k$ 的路径和所有包含节点 $k$ 的路径</li><li>因为 $i \to k$ 与 $k \to j$ 无关，所以只需要前两者都为最小值，即为最短路</li><li><code>d[k][i][j] = min (d[k][i][j], d[k - 1][i][k] + d[k - 1][k][j])</code></li><li>所有的 $d[i, k], d[k][i][k] &#x3D; d[k - 1][i][k]$，所以可以少一维</li></ul></li></ul></li></ul><h3 id="AcWing-牛的旅行"><a href="#AcWing-牛的旅行" class="headerlink" title="AcWing|牛的旅行"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyNy8=">AcWing|牛的旅行</span></h3><ul><li>分析<ul><li>新的连通块的直径一定 $\ge$ 所有连通块直径的最大值</li><li>经过新边的最长路径</li></ul></li><li>题解<ul><li>用 $Floyd$ 求出任意两点之间的最短距离</li><li>求 $maxd[i]$，表示和 $i$ 连通的且距离 $i$ 最远的点的距离</li><li>情况 1：所有 $maxd[i]$ 的最大值</li><li>情况 2：枚举在哪两个点之间连边，$(i, j)$，满足 $d[i, j] &#x3D; INF$，$maxd[i] + dist[i, j] + maxd[j]$</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 160;
const double INF = 1e20;
PII p[N];
double dist[N][N], maxd[N];
string g[N];
double get_dist(PII a, PII b)&#123;
    double dx = a.first - b.first, dy = a.second - b.second;
    return sqrt(dx * dx + dy * dy);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n; cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];
    
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            if(i != j)&#123;
                if(g[i][j] == &#39;1&#39;) dist[i][j] = get_dist(p[i], p[j]);
                else dist[i][j] = INF;
            &#125;
        &#125;
    &#125;
    for(int k = 0; k &lt; n; k++)&#123;
        for(int i = 0; i &lt; n; i++)&#123;
            for(int j = 0; j &lt; n; j++)&#123;
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            &#125;
        &#125;
    &#125;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            if(dist[i][j] &lt; INF) maxd[i] = max(maxd[i], dist[i][j]);
        &#125;
    &#125;
    double res = 0;
    for(int i = 0; i &lt; n; i++) res = max(res, maxd[i]);
    double ans = INF;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            if(dist[i][j] &gt;= INF) ans = min(ans, get_dist(p[i], p[j]) + maxd[i] + maxd[j]);
        &#125;
    &#125;
    cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; max(res, ans) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-排序🌸"><a href="#AcWing-排序🌸" class="headerlink" title="AcWing|排序🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ1Lw==">AcWing|排序</span>🌸</h3><ul><li>传递闭包<ul><li>间接能到达的点都连一条直接的边</li></ul></li><li>初始化 $d[i, j] &#x3D; g[i, j]$, $1$ 表示有边，$0$ 表示没有边</li><li>Floyd 求传递闭包<ul><li>$A &lt; B$ 即 $d[A, B] &#x3D; 1$</li><li>矛盾，即 $d (i, i) &#x3D; 1$</li><li>唯一确定，即 $i \ne j, d (i, j), d (j, i)$ 必有一个是 $1$<ul><li>排序，将所有点按照能到达的点数从小到大排序，然后依次输出编号</li></ul></li><li>顺序不唯一</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 30;
bool g[N][N], d[N][N];
bool st[N];
int n, m;
void floyd()&#123;
    memcpy(d, g, sizeof(g));
    for(int k = 0; k &lt; n; k++)&#123;
        for(int i = 0; i &lt; n; i++)&#123;
            for(int j = 0; j &lt; n; j++)&#123;
                d[i][j] |= d[i][k] &amp;&amp; d[k][j];
            &#125;
        &#125;
    &#125;
&#125;
int check()&#123;
    for(int i = 0; i &lt; n; i++)&#123;
        if(d[i][i]) return 2;
    &#125;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; i; j++)&#123;
            if(!d[i][j] &amp;&amp; !d[j][i]) return 0;
        &#125;
    &#125;
    return 1;
&#125;
char get_min()&#123;
    for(int i = 0; i &lt; n; i++)&#123;
        if(!st[i])&#123;
            bool flag = 1;
            for(int j = 0; j &lt; n; j++)&#123;
                if(d[j][i] &amp;&amp; !st[j])&#123;
                    flag = 0;
                    break;
                &#125;
            &#125;
            if(flag)&#123;
                st[i] = 1;
                return &#39;A&#39; + i;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    while(cin &gt;&gt; n &gt;&gt; m, n || m)&#123;
        memset(g, 0, sizeof(g));
        int type = 0, t;
        for(int i = 1; i &lt;= m; i++)&#123;
            string s; cin &gt;&gt; s;
            int a = s[0] - &#39;A&#39;, b = s[2] - &#39;A&#39;;
            if(!type)&#123;
                g[a][b] = 1;
                floyd();
                type = check();
                if(type) t = i;
            &#125;
        &#125;
        if(!type) cout &lt;&lt; &quot;Sorted sequence cannot be determined.\n&quot;;
        else if(type == 2) cout &lt;&lt; &quot;Inconsistency found after &quot; &lt;&lt; t &lt;&lt; &quot; relations.\n&quot;;
        else &#123;
            memset(st, 0, sizeof(st));
            cout &lt;&lt; &quot;Sorted sequence determined after &quot; &lt;&lt; t &lt;&lt; &quot; relations: &quot;;
            for(int i = 0; i &lt; n; i++)&#123;
                cout &lt;&lt; get_min();
            &#125;
            cout &lt;&lt; &quot;.\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre><ul><li>本题可以优化每次加入的新边，但是需要注意<strong>传递</strong></li></ul><pre><code class="cpp">memset(d, 0, sizeof(d));
int type = 0, t;
for(int i = 1; i &lt;= m; i++)&#123;
    string s; cin &gt;&gt; s;
    int a = s[0] - &#39;A&#39;, b = s[2] - &#39;A&#39;;
    if(!type)&#123;
        d[a][b] = 1;
        //floyd();
        for(int x = 0; x &lt; n; x++)&#123;
            if(d[b][x]) d[a][x] = 1;
            if(d[x][a]) d[x][b] = 1;
            for(int y = 0; y &lt; n; y++)&#123;
                if(d[x][a] &amp;&amp; d[b][y])&#123;
                    d[x][y] = 1;
                &#125;
            &#125;
        &#125;
        type = check();
        if(type) t = i;
    &#125;
&#125;
</code></pre><h3 id="AcWing-观光之旅🌸"><a href="#AcWing-观光之旅🌸" class="headerlink" title="AcWing|观光之旅🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ2Lw==">AcWing|观光之旅</span>🌸</h3><ul><li>Floyd 求最小环，设环的形式是 $i \longleftrightarrow k \longleftrightarrow j$，Floyd 是典型的插点算法，每次插入点 $k$，因此，在点 $k$ 插入前可以计算这个环，我们只需要枚举所有以 $k$ 为环中的最大节点的环即可</li><li>用集合思考，按环上的最大编号来分类</li><li>$pos[i, j]$ 即 $i \longleftrightarrow j$ 的最短路中经过的点是 $k$ （即由这个状态转移过来），且这个 $k$ 是此路径中编号最大的点</li><li>性质<ul><li>在 $i \longleftrightarrow j$ 的最短路中，一定没有环</li><li>这三个点之间的两条最短路必然没有交集</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 110;
int d[N][N], g[N][N];
int path[N], pos[N][N], cnt;
void get_path(int i, int j)&#123;
    if(pos[i][j] == 0) return ;
    int k = pos[i][j];
    get_path(i, k);
    path[cnt++] = k;
    get_path(k, j);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(g, 0x3f, sizeof(g));
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int u, v, l;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; l;
        g[u][v] = g[v][u] = min(g[u][v], l);
    &#125;
    memcpy(d, g, sizeof(d));
    int ans = 0x3f3f3f3f;
    for(int k = 1; k &lt;= n; k++)&#123;
        for(int i = 1; i &lt; k; i++)&#123;
            for(int j = i + 1; j &lt; k; j++)&#123;
                if((LL)d[i][j] + g[i][k] + g[k][j] &lt; ans)&#123;
                    ans = d[i][j] + g[i][k] + g[k][j];
                    cnt = 0;
                    path[cnt++] = k;
                    path[cnt++] = i;
                    get_path(i, j);
                    path[cnt++] = j;
                &#125;
            &#125;
        &#125;
        for(int i = 1; i &lt;= n; i++)&#123;
            for(int j = 1; j &lt;= n; j++)&#123;
                if(d[i][j] &gt; d[i][k] + d[k][j])&#123;
                    d[i][j] = d[i][k] + d[k][j];
                    pos[i][j] = k;
                &#125;
            &#125;
        &#125;
    &#125;
    if(ans == 0x3f3f3f3f) cout &lt;&lt; &quot;No solution.\n&quot;;
    else&#123;
        for(int i = 0; i &lt; cnt; i++) cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-牛站🌖"><a href="#AcWing-牛站🌖" class="headerlink" title="AcWing|牛站🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ3Lw==">AcWing|牛站</span>🌖</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzM2NjAzLw==">AcWing 345. 牛站(通俗图解版) - AcWing</span></li><li>Floyd 的倍增应用<ul><li>原本的状态表示 $d[k, i, j]$ 表示从 $i$ 到 $j$ 只经过 $1 \sim k$ 的话，最短路径是多少</li><li>本题的状态表示 $d[k, i, j]$ 表示从 $i$ 到 $j$，恰好经过 $k$ 条边的最短路径</li><li>$d[a + b, i, j] &#x3D; min(d[a, i, k] + d[b, k, j])$ 其中 $k &#x3D; 1 \sim n$，前后两段最短路无关</li><li>之后发现每一段的顺序都不影响最终答案，具有结合律，因此可以使用快速幂&#x2F;倍增的思想</li></ul></li><li>本题需要离散化</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int N, T, S, E, n;
map&lt;int, int&gt; ids;
int g[1010][1010], ans[1010][1010];
void floyd(int a[][1010], int b[][1010], int c[][1010])&#123;
    static int tmp[1010][1010]; // b 和 c 相乘的结果
    memset(tmp, 0x3f, sizeof(tmp));
    for(int k = 1; k &lt;= n; k++)&#123;
        for(int i = 1; i &lt;= n; i++)&#123;
            for(int j = 1; j &lt;= n; j++)&#123;
                tmp[i][j] = min(tmp[i][j], b[i][k] + c[k][j]);
            &#125;
        &#125;
    &#125;
    memcpy(a, tmp, sizeof(tmp));
&#125;
void qmi()&#123;
    memset(ans, 0x3f, sizeof(ans));
    for(int i = 1; i &lt;= n; i++) ans[i][i] = 0;
    while(N)&#123;
        if(N &amp; 1) floyd(ans, ans, g);
        floyd(g, g, g);
        N &gt;&gt;= 1;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; N &gt;&gt; T &gt;&gt; S &gt;&gt; E;
    memset(g, 0x3f, sizeof(g));

    ids[S] = ++n, ids[E] = ++n;
    S = ids[S], E = ids[E];
    
    for(int i = 1; i &lt;= T; i++)&#123;
        int c, a, b;
        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;
        if(!ids.count(a)) ids[a] = ++n;
        if(!ids.count(b)) ids[b] = ++n;
        a = ids[a], b = ids[b];
        g[a][b] = g[b][a] = min(g[a][b], c);
    &#125;
    qmi();
    cout &lt;&lt; ans[S][E] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul><li>Prim<ul><li>朴素版 $O(n^2)$	–邻接矩阵</li><li>堆优化 <del>被 Kruskal 完爆</del></li><li>证明：当前与外界直接相连的权值最小的一条边，这条边一定可以出现在最优解中<ul><li><span class="exturl" data-url="aHR0cHM6Ly9vaXdpa2kub3JnL2dyYXBoL21zdC8jXzY=">OI Wiki|数学归纳法</span></li></ul></li></ul></li><li>Kruskal<ul><li>$O(mlogn)$，直接存边，三元组</li><li>并查集维护</li><li>证明<ul><li><span class="exturl" data-url="aHR0cHM6Ly9vaXdpa2kub3JnL2dyYXBoL21zdC8jXzQ=">OI Wiki|数学归纳法</span></li></ul></li></ul></li><li>反证法<ul><li>假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会出现一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差</li></ul></li></ul><h3 id="AcWing-最短网络"><a href="#AcWing-最短网络" class="headerlink" title="AcWing|最短网络"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0Mi8=">AcWing|最短网络</span></h3><ul><li>模板题</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
int w[N][N], dist[N];
bool st[N];
int n;
int prim()&#123;
    int ans = 0;
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for(int i = 0; i &lt; n; i++)&#123;
        int t = -1;
        for(int j = 1; j &lt;= n; j++)&#123;
            if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j;
        &#125;
        st[t] = 1;
        ans += dist[t];
        for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], w[t][j]);
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            cin &gt;&gt; w[i][j];
        &#125;
    &#125;
    cout &lt;&lt; prim() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-局域网"><a href="#AcWing-局域网" class="headerlink" title="AcWing|局域网"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0My8=">AcWing|局域网</span></h3><ul><li>相当于在这个图的每个连通块内，求一棵最小生成树</li><li>Prim 一次只能处理一个连通块，所以使用 Kruskal</li><li>将所有边权从小到大排序</li><li>依次枚举每条边 $a, b, w$，如果 $a, b$ 不连通，那么就将当前边加到最小生成树中</li><li>就算没有完成全部的生成树，中间过程已完成的部分也是正确的；从某一段开始做 Kruskal ，也是正确的</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef tuple&lt;int, int, int&gt; TIII;
const int N = 110, M = 210;
TIII e[M];
int p[N];
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, k; cin &gt;&gt; n &gt;&gt; k;
    for(int i = 1; i &lt;= n; i++) p[i] = i;
    for(int i = 1; i &lt;= k; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        e[i] = &#123;c, a, b&#125;;
    &#125;
    sort(e + 1, e + 1 + k);
    int ans = 0;
    for(int i = 1; i &lt;= k; i++)&#123;
        auto [c, a, b] = e[i];
        int x = find(a), y = find(b);
        if(x != y) p[x] = y;
        else ans += c;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-繁忙的都市"><a href="#AcWing-繁忙的都市" class="headerlink" title="AcWing|繁忙的都市"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0NC8=">AcWing|繁忙的都市</span></h3><ul><li>Prim 和 Kruskal 都需要是无向边</li><li>本题中的最小生成树求的是边权最大值最小，即 <strong>瓶颈生成树</strong></li><li>题解<ul><li>将所有边从小到大排序</li><li>从小到大依次枚举每条边，$a, b, w$<ul><li>如果 $a$ 和 $b$ 已经连通，直接跳过</li><li>如果 $a$ 和 $b$ 不连通，就将当前边选出来</li></ul></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef tuple&lt;int, int, int&gt; TIII;
const int N = 310, M = 10010;
TIII g[M];
int p[N];
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) p[i] = i;
    for(int i = 1; i &lt;= m; i++)&#123;
        int u, v, c;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;
        g[i] = &#123;c, u, v&#125;;
    &#125;
    sort(g + 1, g + 1 + m);
    int ans, cnt = 0;
    for(int i = 1; i &lt;= m; i++)&#123;
        auto [c, u, v] = g[i];
        int x = find(u), y = find(v);
        if(x != y)&#123;
            p[x] = y;
            cnt++;
            ans = c;
        &#125;
    &#125;
    cout &lt;&lt; cnt &lt;&lt; &#39; &#39; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-联络员"><a href="#AcWing-联络员" class="headerlink" title="AcWing|联络员"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0NS8=">AcWing|联络员</span></h3><ul><li>必须要连的边先连在一起，当成一个连通块，求各个连通块的最小生成树</li><li>本题不需要缩点</li><li>题解<ul><li>将所有必选边加到并查集中</li><li>将所有非必选边从小到大排序</li><li>从小到大依次枚举每一条非必选边<ul><li>如果 $a$ 和 $b$ 已经连通，直接跳过</li><li>如果 $a$ 和 $b$ 不连通，就将当前边选出来</li></ul></li><li>并查集的祖宗节点即可看成小连通块的编号，可以看作缩点</li><li>在有一定边的基础上做 Kruskal 一样可以求出最小生成树</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef tuple&lt;int, int, int&gt; TIII;
const int N = 2010, M = 10010;
TIII g[M];
int p[N];
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    int ans = 0, cnt = 0;
    for(int i = 1; i &lt;= n; i++) p[i] = i;
    for(int i = 1; i &lt;= m; i++)&#123;
        int type, u, v, w;
        cin &gt;&gt; type &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        if(type == 1)&#123;
            p[find(u)] = find(v);
            ans += w;
        &#125;else&#123;
            g[++cnt] = &#123;w, u, v&#125;;
        &#125;
    &#125;
    sort(g + 1, g + 1 + cnt);
    for(int i = 1; i &lt;= cnt; i++)&#123;
        auto [w, u, v] = g[i];
        int x = find(u), y = find(v);
        if(x != y)&#123;
            p[x] = y;
            ans += w;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-连接格点🌸"><a href="#AcWing-连接格点🌸" class="headerlink" title="AcWing|连接格点🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0Ni8=">AcWing|连接格点</span>🌸</h3><ul><li>每多一条边，花费肯定更多，一共 $n \times m$ 个点，我们最少需要连 $nm - 1$ 条边，转化成最小生成树问题</li><li>其他同上一题</li><li>假如时限紧或者边很多的情况下，由于边权只有 $1$ 和 $2$，可以先建竖向的边再建横向的边，可以减少排序消耗的时间</li><li>将二维转化成一维</li><li>不用特判边是否已经存在，并查集会解决</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef tuple&lt;int, int, int&gt; TIII;
const int N = 1010, M = 1e7 + 10;
int idx[N][N], p[M];
TIII e[M];
int n, m, cnt = 0;
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
void get_edges()&#123;
    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;, dw[4] = &#123;1, 2, 1, 2&#125;;
    for(int z = 0; z &lt; 2; z++)&#123;
        for(int i = 1; i &lt;= n; i++)&#123;
            for(int j = 1; j &lt;= m; j++)&#123;
                for(int k = 0; k &lt; 4; k++)&#123;
                    if(k % 2 == z)&#123;
                        int nx = i + dx[k], ny = j + dy[k], w = dw[k];
                        if(nx &amp;&amp; nx &lt;= n &amp;&amp; ny &amp;&amp; ny &lt;= m)&#123;
                            int x = idx[i][j], y = idx[nx][ny];
                            if(x &lt; y) e[++cnt] = &#123;w, x, y&#125;;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n * m; i++) p[i] = i;
    for(int i = 1, t = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++, t++)&#123;
            idx[i][j] = t;
        &#125;
    &#125;
    int x1, y1, x2, y2;
    while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)&#123;
        int x = idx[x1][y1], y = idx[x2][y2];
        p[find(x)] = find(y);
    &#125;
    get_edges();
    int ans = 0;
    for(int i = 1; i &lt;= cnt; i++)&#123;
        auto [w, x, y] = e[i];
        x = find(x), y = find(y);
        if(x != y)&#123;
            p[x] = y;
            ans += w;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h2 id="最小生成树的扩展应用"><a href="#最小生成树的扩展应用" class="headerlink" title="最小生成树的扩展应用"></a>最小生成树的扩展应用</h2><ul><li>最小生成树的理论基础<ul><li>任意一棵最小生成树一定可以包含无向图中权值最小的边</li><li>给定一张无向图 $G &#x3D; (V, E), n &#x3D; |V|, m &#x3D; |E|$，从 $E$ 中选出 $k &lt; n - 1$ 条边构成 $G$ 的加一个生成森林。若再从剩余的 $m - k$ 条边中选 $n - 1 - k$ 条边添加到生成森林中，使其成为 $G$ 的生成树，并且选出的边的权值之和最小。则该生成树一定<strong>可以</strong>包含 $m - k$ 条边中连接生成森林的两个不连通节点的权值最小的边</li></ul></li><li>次小生成树<ul><li>定义：给一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树，权值严格大于最小生成树</li><li>方法<ol><li>先求最小生成树，再枚举删去最小生成树中的边求解，时间复杂度 $O(mlogm + nm)$，只能求非严格次小生成树</li><li>先求最小生成树，依次枚举非树边，然后将该边加入树中，同时从树中去掉一条边，使得最终的图仍是一棵树，则一定可以求出次小生成树，去掉的边是新边两端点间原路径上边权最大的边</li></ol></li></ul></li><li>设 $T$ 为图 $G$ 的一棵生成树，对于非树边 $a$ 和树边 $b$，插入边 $a$，并删除边 $b$ 的操作记为 $(+a, -b)$。如果 $T + a - b$ 之后，仍然是一棵生成树，称 $(+a, -b)$ 是 $T$ 的一个可行交换</li><li>称由 $T$ 进行一次可行变换所得到的新的生成树的集合称为 $T$ 的邻集</li><li>定理：次小生成树一定在最小生成树的邻集中</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS92aWRlby81Mzcv">相关证明-3.3.2 最小生成树的扩展应用 - AcWing</span></li></ul><h3 id="AcWing-新的开始"><a href="#AcWing-新的开始" class="headerlink" title="AcWing|新的开始"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0OC8=">AcWing|新的开始</span></h3><ul><li>构建虚拟源点，<del>超级发电站</del>，其到每个发电站的边权都是 $v_i$，每个矿井都需要和超级发电站连通，因此可以转化成最小生成树问题</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 310;
int w[N][N], dist[N];
int n;
bool st[N];
int prim()&#123;
    memset(dist, 0x3f, sizeof(dist));
    dist[0] = 0;
    int ans = 0;
    for(int i = 0; i &lt; n + 1; i++)&#123;
        int t = -1;
        for(int j = 0; j &lt;= n; j++)&#123;
            if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;
        &#125;
        st[t] = 1;
        ans += dist[t];
        for(int j = 0; j &lt;= n; j++) dist[j] = min(dist[j], w[t][j]);
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[0][i];
        w[i][0] = w[0][i];
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            cin &gt;&gt; w[i][j];
        &#125;
    &#125;
    cout &lt;&lt; prim() &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-北极通讯网络"><a href="#AcWing-北极通讯网络" class="headerlink" title="AcWing|北极通讯网络"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0Ny8=">AcWing|北极通讯网络</span></h3><ul><li>相当于找一个最小的 $d$ 值，使得将所有权值大于 $d$ 的边删去之后，整个图形的连通块的个数不超过 $k$，每一个连通块需要一个卫星设备</li><li>Kruskal 刚好可以求出 $k$ 个连通块时的结果，不需要用二分来求</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef tuple&lt;double, int, int&gt; TDII;
typedef pair&lt;int, int&gt; PII;
const int N = 510, M = N * N / 2;
PII q[N];
TDII edges[M];
int p[N];
int n, k, m;
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
double get_dist(PII a, PII b)&#123;
    int dx = a.first - b.first;
    int dy = a.second - b.second;
    return sqrt(dx * dx + dy * dy);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cout &lt;&lt; fixed &lt;&lt; setprecision(2);
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 1; i &lt;= n; i++)&#123;
        p[i] = i;
        cin &gt;&gt; q[i].first &gt;&gt; q[i].second;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt; i; j++)&#123;
            edges[++m] = &#123;get_dist(q[i], q[j]), i, j&#125;;
        &#125;
    &#125;
    sort(edges + 1, edges + 1 + m);
    int cnt = n;
    double ans;
    for(int i = 1; i &lt;= m; i++)&#123;
        if(cnt &lt;= k) break;
        auto [w, a, b] = edges[i];
        a = find(a), b = find(b);
        if(a != b)&#123;
            p[a] = b;
            cnt--;
            ans = w;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-走廊泼水节"><a href="#AcWing-走廊泼水节" class="headerlink" title="AcWing|走廊泼水节"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ4Lw==">AcWing|走廊泼水节</span></h3><ul><li>完全图，即任意两个点都可以直达</li><li>按边权从小到大排序，每次合并新加入那条边的两个集合，构造一棵最小生成树，因为不能破坏最小生成树，所以构成完全图的其他边需要大于等于当前连接两个连通块的边权，所以都可以取 $w_i + 1$</li><li>假设 $S_x$ 连通块有 $p$ 个元素，$S_y$ 连通块有 $q$ 个元素，那么新加边的权值是 $(w + 1) \times (p \times q - 1)$</li><li>维护 $size$ 的并查集</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef tuple&lt;double, int, int&gt; TDII;
typedef pair&lt;int, int&gt; PII;
const int N = 6010;
TDII e[N];
int p[N], cnt[N];
int find(int x)&#123;
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
&#125;
void solve()&#123;
    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n - 1; i++)&#123;
        int x, y, z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        e[i] = &#123;z, x, y&#125;;
    &#125;
    sort(e + 1, e + 1 + n - 1);
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        p[i] = i;
        cnt[i] = 1;
    &#125;
    for(int i = 1; i &lt;= n - 1; i++)&#123;
        auto [w, a, b] = e[i];
        a = find(a), b = find(b);
        if(a != b)&#123;
            p[a] = b;
            ans += (cnt[b] * cnt[a] - 1) * (w + 1);
            cnt[b] += cnt[a];
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h3 id="AcWing-秘密的牛奶运输🌖"><a href="#AcWing-秘密的牛奶运输🌖" class="headerlink" title="AcWing|秘密的牛奶运输🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE1MC8=">AcWing|秘密的牛奶运输</span>🌖</h3><ul><li>次小生成树，这里使用朴素做法<ul><li><strong>定理：</strong> 对于一张无向图，如果存在最小生成树和（严格）次小生成树，那么对于任何一棵最小生成树，都存在一棵（严格）次小生成树，使得这两棵树只有一条边不同。</li></ul></li><li>先用 Kruskal 处理出最小生成树，同时建边并标记哪些点不是树上的点</li><li>使用 $dfs$ 预处理出 $d$ 和 $dist2[a][b]$ 分别表示树上 $a$ 到 $b$ 的最大值和次大值（防止与树外边权相同从而找出非严格次小生成树）<ul><li>第二步 $dfs$ 处理的时候应该考虑负权边，因此最大值和次大值的初值都应该为 <code>-1e9</code></li></ul></li><li>枚举每一个 $sum+w-dist[i][j]$ 求最小值</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1010, M = 10010;
struct Edge&#123;
    int a, b, w;
    bool is_tree;
    bool operator &lt; (const Edge &amp;e) const&#123;
        return w &lt; e.w;
    &#125;
&#125;edge[M];
int n, m;
int p[N], dist1[N][N], dist2[N][N]; // 最小值，次小值
int h[N], e[M * 2], ne[M * 2], w[M * 2], idx;
int find(int x)&#123;
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
&#125;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u, int fa, int maxn, int maxv, int dist1[], int dist2[])&#123;
    dist1[u] = maxn, dist2[u] = maxv;
    for(int i = h[u]; i != -1; i = ne[i])&#123;
        int j = e[i];
        if(j != fa)&#123;
            if(w[i] &gt; maxn) dfs(j, u, w[i], maxn, dist1, dist2);
            else if(w[i] &lt; maxn &amp;&amp; w[i] &gt; maxv) dfs(j, u, maxn, w[i], dist1, dist2);
            else dfs(j, u, maxn, maxv, dist1, dist2);
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;
        cin &gt;&gt; edge[i].a &gt;&gt; edge[i].b &gt;&gt; edge[i].w;
    &#125;
    sort(edge + 1, edge + 1 + m);
    for(int i = 1; i &lt;= n; i++) p[i] = i;
    LL sum = 0;
    for(int i = 1; i &lt;= m; i++)&#123;
        auto&amp; [a, b, w, f] = edge[i];
        int pa = find(a), pb = find(b);
        if(pa != pb)&#123;
            p[pa] = pb;
            sum += w;
            f = 1;
            add(a, b, w), add(b, a, w);
        &#125;
    &#125;
    // dfs处理树上任意两点的最大值和次大值
    for(int i = 1; i &lt;= n; i++)&#123;
        dfs(i, -1, -1e9, -1e9, dist1[i], dist2[i]);
    &#125;
    LL ans = 1e18;
    for(int i = 1; i &lt;= m; i++)&#123;
        auto &amp;[a, b, w, f] = edge[i];
        if(!f)&#123;
            if(w &gt; dist1[a][b]) ans = min(ans, sum + w - dist1[a][b]);
            else if(w &gt; dist2[a][b]) ans = min(ans, sum + w - dist2[a][b]);
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h2><ul><li>01 分数规划通常和负环结合一起</li><li>求负环得常用方法，基于 SPFA<ul><li>统计每个点入队的次数，如果某个点入队 $n$ 次，则说明存在负环</li><li>统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于 $n$，则也说明存在环</li></ul></li></ul><h3 id="AcWing-虫洞"><a href="#AcWing-虫洞" class="headerlink" title="AcWing|虫洞"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTA2Lw==">AcWing|虫洞</span></h3><ul><li>spfa 求负环，板子题</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 510, M = 5210;
int n, m1, m2;
int h[N], e[M], w[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool spfa()&#123;
    //memset(dist, 0, sizeof(dist));
    //可以不用初始化
    memset(cnt, 0, sizeof(cnt));
    queue&lt;int&gt; q;
    for(int i = 1; i &lt;= n; i++)&#123;
        q.push(i);
        st[i] = true;
    &#125;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &gt; dist[t] + w[i])&#123;
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] &gt;= n) return 1;
                if(!st[j])&#123;
                    q.push(j);
                    st[j] = true;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
void solve()&#123;
    memset(h, -1, sizeof(h));
    idx = 0;
    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;
    for(int i = 1; i &lt;= m1; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c); add(b, a, c);
    &#125;
    for(int i = 1; i &lt;= m2; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, -c);
    &#125;
    if(spfa()) cout &lt;&lt; &quot;YES\n&quot;;
    else cout &lt;&lt; &quot;NO\n&quot;;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h3 id="AcWing-观光奶牛"><a href="#AcWing-观光奶牛" class="headerlink" title="AcWing|观光奶牛"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzYzLw==">AcWing|观光奶牛</span></h3><ul><li>在图论中形如 $\frac{\sum f_i}{\sum g_i}$ 的问题，称之为 01 分数规划，通用做法，二分</li><li>$\frac{\sum f_i}{\sum g_i}$，就可以转化为 $\sum f_i &gt; Mid \times \sum g_i$，即 $\sum f_i - Mid \times \sum g_i &gt; 0$，求和可以提在括号外，等价于图中<strong>是否有正环</strong></li><li>有向图上的点权可以放在出边上也可以放在入边上</li><li>spfa 算法本身具有一个性质，就是在求解最短路的时候，是可以把点权和边权看做一个整体边权一起更新的，因此我们常常在一些 spfa 的图论问题中，把点权存入边权中进行计算。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1010, M = 5010;
int wf[N], cnt[N];
int h[N], e[M], wt[M], ne[M], idx;
double dist[N];
bool st[N];
int n, m;
void add(int a, int b, int c)&#123;
    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool check(double x)&#123;
    memset(cnt, 0, sizeof(cnt));
    memset(dist, 0, sizeof(dist));
    queue&lt;int&gt; q;
    for(int i = 1; i &lt;= n; i++)&#123;
        q.push(i);
        st[i] = true;
    &#125;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &lt; dist[t] + wf[t] - x * wt[i])&#123;
                dist[j] = dist[t] + wf[t] - x * wt[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] &gt;= n) return 1;
                if(!st[j])&#123;
                    q.push(j);
                    st[j] = true;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; wf[i];
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    &#125;
    double l = 0, r = 1e6;
    while(r - l &gt; 1e-4)&#123;
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    &#125;
    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; l &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-单词环"><a href="#AcWing-单词环" class="headerlink" title="AcWing|单词环"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE2Ni8=">AcWing|单词环</span></h3><ul><li>可以把一个单词看成一个点，但是如此分析，数据会非常大，边会非常多，因此反过来看，把单词看作边</li><li>例如 $ababc$ 就相当于 $ab \to bc$ 边权为 $5$，如此最多只有 $10^5$ 条边，只有 $26 \times 26$ 个点</li><li>其余分析同上题，01 分数规划，可转化成求图中正环</li><li>但是直接这样做会 TLE，该题有个小 trick，当入队的点的总次数超过一定值时，大概率是一定有负环的，<del>所以可以加入该优化</del></li><li>二分精度太高也会 TLE</li><li>将 spfa 中的队列换成栈，可以更快地找到环</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 700, M = 100010;
int n;
int h[N], e[M], w[M], ne[M], idx;
double dist[N];
bool st[N];
int cnt[N];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool check(double mid)&#123;
    memset(cnt, 0, sizeof(cnt));
    queue&lt;int&gt; q;
    for(int i = 0; i &lt; N; i++)&#123;
        q.push(i);
        st[i] = true;
    &#125;
    int count = 0;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &lt; dist[t] + w[i] - mid)&#123;
                dist[j] = dist[t] + w[i] - mid;
                cnt[j] = cnt[t] + 1;
                if(++count &gt; 10000) return 1;
                if(cnt[j] &gt;= N) return 1;
                if(!st[j])&#123;
                    q.push(j);
                    st[j] = true;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
int main()&#123;
    string str;
    while(cin &gt;&gt; n, n)&#123;
        memset(h, -1, sizeof(h));
        idx = 0;
        for(int i = 1; i &lt;= n; i++)&#123;
            cin &gt;&gt; str;
            int len = str.size();
            if(len &gt;= 2)&#123;
                int l = (str[0] - &#39;a&#39;) * 26 + str[1] - &#39;a&#39;;
                int r = (str[len - 2] - &#39;a&#39;) * 26 + str[len - 1] - &#39;a&#39;;
                add(l, r, len);
            &#125;
        &#125;
        if(!check(0)) cout &lt;&lt; &quot;No solution\n&quot;;
        else&#123;
            double l = 0, r = 1000;
            while(r - l &gt; 1e-4)&#123;
                double mid = (l + r) / 2;
                if(check(mid)) l = mid;
                else r = mid;
            &#125;
            cout &lt;&lt; l &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><hr><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><ul><li>偏数学</li><li>求一个不等式组的可行解<ul><li>源点需要满足的条件：从源点出发，一定可以走到所有的边</li><li>步骤<ol><li>先将每个不等式 $x_i \le x_j + c_k$，转化成一条从 $x_j$ 走到 $x_i$，长度为 $c_k$ 的一条边</li><li>找一个虚拟源点，使得该源点一定可以遍历到所有边</li><li>从源点求一遍单源最短路</li></ol></li><li>无解等价于图中存在负环</li></ul></li><li>如何求最大值或者最小值，这里的最值指的是每个变量的最值<ul><li>结论：如果求的是最小值，则应该求最长路；如果求的是最大值，则应该求最短路；</li><li>问题：如何转化 $x_i \le c$ 其中 $c$ 是一个常数，这一类的不等式</li><li>方法：建立一个虚拟源点 $0$，然后建立 $0 \to i$，长度为 $c$ 的边即可</li><li>最大值满足最小上确界原理</li><li>以求 $x_i$ 的最大值为例：求所有从 $x_i$ 出发，构成的不等式链 $x_i ; \le ; x_j + c_1 ; \ge ; x_k + c_2 + c_1 ; \ge ; \cdots ; \ge ; c_1 + c_2 + \cdots$ 所计算出的上界，最终 $x_i$ 的最大值等于所有上界的最小值</li></ul></li><li>每一个差分约束的问题都可以转化成单源最短路问题</li><li><strong>总结</strong><ul><li>以求最长路为例<ul><li>边权无限制 spfa $O(nm)$</li><li>边权非负，可以用强连通分量来解，每个强连通分量内部边权为 $0$，否则无解 $O (n + m)$</li><li>边权 $&gt; 0$ 拓扑排序 $O (n + m)$</li></ul></li></ul></li></ul><h3 id="AcWing-糖果"><a href="#AcWing-糖果" class="headerlink" title="AcWing|糖果"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3MS8=">AcWing|糖果</span></h3><ul><li>几种关系，转化成最长路需要大于等于<ol><li>$A &#x3D; B$ 等价于 $A \ge B, B \ge A$</li><li>$A &lt; B$ 等价于 $B \ge A + 1$</li><li>$A \ge B$</li><li>$A &gt; B$ 等价于 $A \ge B + 1$</li><li>$A \le B$ 等价于 $B \ge A$</li></ol></li><li>建立虚拟源点 $x_0 &#x3D; 0$，最后所有的 $x_i$ 都可以转化成 $x_i \ge x_0 + 1$</li><li>spfa 中用栈，找环效率更高</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010, M = 300010;
int h[N], e[M], ne[M], w[M], idx;
LL dist[N];
int cnt[N];
bool st[N];
int n, m;
void add(int a, int b, int c) &#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool spfa()&#123;
    stack&lt;int&gt; s;
    memset(dist, -0x3f, sizeof(dist));
    dist[0] = 0;
    s.push(0);
    st[0] = true;
    while(s.size())&#123;
        int t = s.top(); s.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &lt; dist[t] + w[i])&#123;
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] &gt;= n + 1) return false;
                if(!st[j])&#123;
                    st[j] = true;
                    s.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    return true;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m;
    while(m--)&#123;
        int x, a, b;
        cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;
        if(x == 1) add(b, a, 0), add(a, b, 0);
        else if(x == 2) add(a, b, 1);
        else if(x == 3) add(b, a, 0);
        else if(x == 4) add(b, a, 1);
        else add(a, b, 0);
    &#125;
    for(int i = 1; i &lt;= n; i++) add(0, i, 1);
    if(!spfa()) cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else&#123;
        LL ans = 0;
        for(int i = 1; i &lt;= n; i++) ans += dist[i];
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-区间"><a href="#AcWing-区间" class="headerlink" title="AcWing|区间"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY0Lw==">AcWing|区间</span></h3><ul><li>因为需要使用前缀和，要把 $0$ 空出来，所以需要将整体 $+1$</li><li>$S_0 &#x3D; 0$，$S_i$ 表示 $1 \sim i$ 中被选出的数的个数，需要求 $S_{50001}$ 的最小值</li><li>条件<ol><li>$S_i \ge S_{i - 1}$, $1 \ge i \ge 50001$</li><li>$S_i - S_{i - 1} \le 1$ 可以转换成 $S_{i - 1} \ge S_i - 1$</li><li>$[a, b]$ 中选 $c$ 个，$S_b - S_{a - 1} \ge c$</li></ol></li><li>保证一定有解，所以不需要判断是否有环</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 50010, M = 150010;
int h[N], e[M], ne[M], w[M], idx;
int dist[N];
bool st[N];
void add(int a, int b, int c) &#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void spfa()&#123;
    queue&lt;int&gt; q;
    memset(dist, -0x3f, sizeof(dist));
    dist[0] = 0;
    q.push(0);
    st[0] = true;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &lt; dist[t] + w[i])&#123;
                dist[j] = dist[t] + w[i];
                if(!st[j])&#123;
                    st[j] = true;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt; N; i++)&#123;
        add(i - 1, i, 0);
        add(i, i - 1, -1);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        a++, b++;
        add(a - 1, b, c);
    &#125;
    spfa();
    cout &lt;&lt; dist[50001] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-排队布局"><a href="#AcWing-排队布局" class="headerlink" title="AcWing|排队布局"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Mi8=">AcWing|排队布局</span></h3><ul><li>条件，$x_i$ 表示第 $i$ 头牛的位置<ol><li>$x_i \le x_{i + 1}$, $1 \le i &lt; n$，每头奶牛按编号排序</li><li>$x_b \le x_a + L$</li><li>$x_a \le x_b - D$</li></ol></li><li>建立虚拟源点 $0$，假定所有牛都在 $\le 0$ 处，因此可以从 $0$ 向任意点连边</li><li>对于第二问，可以直接让 $x_1 &#x3D; 0$，判断该条件下 $x_n$ 能否去无限大的值</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1010, M = 21010;

int h[N], e[M], w[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];
int n, m1, m2;

void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool spfa(int sz)&#123;
    memset(dist, 0x3f, sizeof(dist));
    memset(cnt, 0, sizeof(cnt));
    queue&lt;int&gt; q;
    for(int i = 1; i &lt;= sz; i++)&#123;
        dist[i] = 0;
        q.push(i);
        st[i] = true;
    &#125;
    while(q.size())&#123;
        int t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[j] &gt; dist[t] + w[i])&#123;
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] &gt;= n) return false;
                if(!st[j])&#123;
                    st[j] = true;
                    q.push(j);
                &#125;
            &#125;
        &#125;
    &#125;
    return true;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt; n; i++) add(i + 1, i, 0);
    for(int i = 1; i &lt;= m1; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        if(a &gt; b) swap(a, b);
        add(a, b, c);
    &#125;
    for(int i = 1; i &lt;= m2; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        if(a &gt; b) swap(a, b);
        add(b, a, -c);
    &#125;
    if(!spfa(n)) cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else&#123;
        spfa(1);
        if(dist[n] == 0x3f3f3f3f) cout &lt;&lt; -2 &lt;&lt; &#39;\n&#39;;
        else cout &lt;&lt; dist[n] &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-雇佣收银员"><a href="#AcWing-雇佣收银员" class="headerlink" title="AcWing|雇佣收银员"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk1Lw==">AcWing|雇佣收银员</span></h3><hr><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><ul><li>在一个有根树当中，求两个点最近的一个祖先，点自身也算</li><li>方法<ul><li>向上标记法，$O(n)$</li><li>倍增法（在线做法），$fa[i, j]$ 表示从 $i$ 开始，向上走 $2^j$ 步能走到的节点。 $0 \le j \le logn$，$depth[i]$ 表示深度<ul><li>先将两个点跳到同一层，二进制拼凑</li><li>让两个点同时往上跳，一直跳到他们最近公共祖先的下一层</li><li>预处理 $O(nlogn)$, 查询 $O(logn)$</li><li>哨兵：如果从 $i$ 开始跳 $2^j$ 步会跳过根节点，那么 $fa[i, j] &#x3D; 0$，$depth[0] &#x3D; 0$</li></ul></li><li>Tarjan，离线求 LCA，$O(n + m)$<ul><li>在深度优先遍历时，将所有点分成三大类：<ol><li>已经遍历过，且回溯过的点</li><li>正在搜索的分支</li><li>还未搜索到的点</li></ol></li></ul></li><li>RMQ</li></ul></li></ul><h3 id="AcWing-祖孙询问"><a href="#AcWing-祖孙询问" class="headerlink" title="AcWing|祖孙询问"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3NC8=">AcWing|祖孙询问</span></h3><ul><li>倍增 LCA</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 400010, M = N * 2;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][16];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void bfs(int root)&#123;
    memset(depth, 0x3f, sizeof(depth));
    queue&lt;int&gt; q;
    depth[root] = 1, depth[0] = 0;
    q.push(root);
    while(q.size())&#123;
        int t = q.front(); q.pop();
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(depth[j] &gt; depth[t] + 1)&#123;
                depth[j] = depth[t] + 1;
                fa[j][0] = t;
                q.push(j);
                for(int k = 1; k &lt;= 15; k++)&#123;
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int lca(int a, int b)&#123;
    if(depth[a] &lt; depth[b]) swap(a, b);
    for(int i = 15; i &gt;= 0; i--)&#123;
        if(depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i];
    &#125;
    if(a == b) return a;
    for(int i = 15; i &gt;= 0; i--)&#123;
        if(fa[a][i] != fa[b][i])&#123;
            a = fa[a][i];
            b = fa[b][i];
        &#125;
    &#125;
    return fa[a][0];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n;
    int root = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        if(b == -1) root = a;
        else add(a, b), add(b, a);
    &#125;
    bfs(root);
    cin &gt;&gt; m;
    while(m--)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        int p = lca(a, b);
        if(p == a) cout &lt;&lt; &quot;1\n&quot;;
        else if(p == b) cout &lt;&lt; &quot;2\n&quot;;
        else cout &lt;&lt; &quot;0\n&quot;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-距离"><a href="#AcWing-距离" class="headerlink" title="AcWing|距离"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3My8=">AcWing|距离</span></h3><ul><li>targan 离线求 LCA</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 20010, M = N * 2;
int n, m;
int h[N], e[M], w[M], ne[M], idx;
int dist[N], p[N], ans[N], st[N];
vector&lt;PII&gt; query[N];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
void dfs(int u, int fa)&#123;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa) continue;
        dist[j] = dist[u] + w[i];
        dfs(j, u);
    &#125;
&#125;
void tarjan(int u)&#123;
    st[u] = 1;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!st[j])&#123;
            tarjan(j);
            p[j] = u;
        &#125;
    &#125;
    for(auto [v, id] : query[u])&#123;
        if(st[v] == 2)&#123;
            int anc = find(v);
            ans[id] = dist[v] + dist[u] - 2 * dist[anc];
        &#125;
    &#125;
    st[u] = 2;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n - 1; i += 1)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
        add(b, a, c);
    &#125;
    for(int i = 0; i &lt; m; i += 1)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        if(a != b)&#123;
            query[a].push_back(&#123;b, i&#125;);
            query[b].push_back(&#123;a, i&#125;);
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++) p[i] = i;
    dfs(1, -1);
    tarjan(1);
    for(int i = 0; i &lt; m; i++) cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-次小生成树🌖"><a href="#AcWing-次小生成树🌖" class="headerlink" title="AcWing|次小生成树🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzU4Lw==">AcWing|次小生成树</span>🌖</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzI0NjA5Lw==">(kruskal+lca+证明)</span></li><li>倍增 LCA $O(logn)$ 求新加入非树边边的两点 $a, b$ 间的最大边和次大边</li><li>预处理每个点 $i$ 跳 $2^j$ 后的父节点 $fa[i][j]$<ul><li>在 $x$ 和 $y$ 向 $lca[x][y]$ 跳的过程中维护各自路径中的最大值 $d1[x \to lca], d1[y \to lca]$ 和次大值 $d2[x \to lca], d2[y \to lca]$</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010, M = 300010, INF = 0x3f3f3f3f;
int n, m;
struct Edge&#123;
    int a, b, w;
    bool f;
    bool operator &lt; (const Edge &amp;t) const&#123;
        return w &lt; t.w;
    &#125;
&#125;edges[M];
int p[N];
int h[N], e[M], ne[M], w[M], idx;
int depth[N], fa[N][17], d1[N][17], d2[N][17];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int find(int x)&#123;
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
&#125;
LL kruskal()&#123;
    for(int i = 1; i &lt;= n; i++) p[i] = i;
    sort(edges, edges + m);
    LL ans = 0;
    for(int i = 0; i &lt; m; i++)&#123;
        int a = find(edges[i].a), b = find(edges[i].b), w = edges[i].w;
        if(a != b)&#123;
            p[a] = b;
            ans += w;
            edges[i].f = 1;
        &#125;
    &#125;
    return ans;
&#125;
void build()&#123;
    for(int i = 0; i &lt; m; i++)&#123;
        if(edges[i].f)&#123;
            auto [a, b, w, _] = edges[i];
            add(a, b, w), add(b, a, w);
        &#125;
    &#125;
&#125;
void bfs()&#123;
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0, depth[1] = 1;
    queue&lt;int&gt; q;
    q.push(1);
    while(q.size())&#123;
        int t = q.front(); q.pop();
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(depth[j] &gt; depth[t] + 1)&#123;
                depth[j] = depth[t] + 1;
                q.push(j);
                fa[j][0] = t;
                d1[j][0] = w[i], d2[j][0] = -INF;
                for(int k = 1; k &lt;= 16; k++)&#123;
                    int anc = fa[j][k - 1];
                    fa[j][k] = fa[anc][k - 1];
                    int d[4] = &#123;d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]&#125;;
                    d1[j][k] = d2[j][k] = -INF;
                    for(int u = 0; u &lt; 4; u++)&#123;
                        int dis = d[u];
                        if(dis &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = dis;
                        else if(dis != d1[j][k] &amp;&amp; dis &gt; d2[j][k]) d2[j][k] = dis;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
int lca(int a, int b, int w)&#123;
    static int dist[N * 2];
    int cnt = 0;
    if(depth[a] &lt; depth[b]) swap(a, b);
    for(int k = 16; k &gt;= 0; k--)&#123;
        if(depth[fa[a][k]] &gt;= depth[b])&#123;
            dist[cnt++] = d1[a][k];
            dist[cnt++] = d2[a][k];
            a = fa[a][k];
        &#125;
    &#125;
    if(a != b)&#123;
        for(int k = 16; k &gt;= 0; k--)&#123;
            if(fa[a][k] != fa[b][k])&#123;
                dist[cnt++] = d1[a][k];
                dist[cnt++] = d2[a][k];
                dist[cnt++] = d1[b][k];
                dist[cnt++] = d2[b][k];
                a = fa[a][k], b = fa[b][k];
            &#125;
        &#125;
        dist[cnt++] = d1[a][0];
        dist[cnt++] = d1[b][0];
    &#125;
    int dist1 = -INF, dist2 = -INF;
    for(int i = 0; i &lt; cnt; i++)&#123;
        int d = dist[i];
        if(d &gt; dist1) dist2 = dist1, dist1 = d;
        else if(d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;
    &#125;
    if(w &gt; dist1) return w - dist1;
    if(w &gt; dist2) return w - dist2;
    return INF;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        edges[i] = &#123;a, b, c&#125;;
    &#125;
    LL sum = kruskal();
    build();
    bfs();
    LL ans = 1e18;
    for(int i = 0; i &lt; m; i++)&#123;
        if(!edges[i].f)&#123;
            auto [a, b, c, _] = edges[i];
            ans = min(ans, sum + lca(a, b, c));
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h2><ul><li>对于一个有向图，连通分量：对于分量中任意两点 $u，v$，必然可以从 $u$ 走到 $v$，且从 $v$ 走到 $u$</li><li>强连通分量：极大连通分量</li><li>有向图通过缩点成为一个有向无环图（DAG），（拓扑图）<ul><li>缩点：将所有连通分量缩成一个点</li></ul></li><li>通常将一个图，对其求强连通分量，缩点成一个拓扑图方便求解</li><li>强连通分量的求法<ul><li>DFS，将边分为四类<ul><li>树枝边，前向边，后向边，横叉边 （连向已被 DFS 的其他树枝的边）</li></ul></li><li>判断是否在强连通分量中<ul><li>存在后向边指向祖先节点</li><li>先走到横叉边再走到祖先节点</li></ul></li><li>Tarjan 算法求强连通分量（SCC）<ul><li>引入时间戳，对每个点定义两个时间戳：$dfn[u]$ 表示遍历到 $u$ 的时间戳，$low[u]$ 表示从 $u$ 开始走，所能遍历到的最小时间戳是什么</li><li>$u$ 是其所在的强连通分量的最高点，等价于 $dfn[u] &#x3D; low[u]$</li><li>缩点，遍历所有点，再遍历所有邻点，如果 $i$ 和 $j$ 不在同一个连通分量中就加一条新边 $id_i \to id_j$</li><li>连通分量编号递减的顺序一定是拓扑序</li></ul></li></ul></li><li>模板</li></ul><pre><code class="cpp">void tarjan(int u)&#123;
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = true;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j);
            low[u] = min(low[u], low[j]);
        &#125;else if(in_stk[j])&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    
    if(dfn[u] == low[u])&#123;
        int y;
        ++scc_cnt;
        do&#123;
            y = stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;
        &#125;while(y != u);
    &#125;
&#125;
</code></pre><h3 id="AcWing-受欢迎的牛"><a href="#AcWing-受欢迎的牛" class="headerlink" title="AcWing|受欢迎的牛"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Ni8=">AcWing|受欢迎的牛</span></h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzIwNjc4Lw==">详细题解</span></li><li>在拓扑图中只要存在两个及以上出度为 $0$ 的点，则无解，若只存在一个出度为 $0$ 的点，则所有点都可以到达它，故该题可求强连通分量，找到那个出度为 $0$ 的点，其连通分量中点的个数即为答案</li></ul><pre><code class="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010, M = 50010;
int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, sz[N];
int dout[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u)&#123;
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = true;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j);
            low[u] = min(low[u], low[j]);
        &#125;else if(in_stk[j])&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    if(dfn[u] == low[u])&#123;
        ++scc_cnt;
        int y;
        do&#123;
            y = stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;
            sz[scc_cnt]++;
        &#125;while(y != u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    while(m--)&#123;
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!dfn[i]) tarjan(i);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = h[i]; ~j; j = ne[j])&#123;
            int k = e[j];
            int a = id[i], b = id[k];
            if(a != b) dout[a]++;
        &#125;
    &#125;
    int zeros = 0, sum = 0;
    for(int i = 1; i &lt;= scc_cnt; i++)&#123;
        if(!dout[i])&#123;
            zeros++;
            sum += sz[i];
            if(zeros &gt; 1)&#123;
                sum = 0;
                break;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; sum &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-学校网络"><a href="#AcWing-学校网络" class="headerlink" title="AcWing|学校网络"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY5Lw==">AcWing|学校网络</span></h3><ul><li>第一问，缩点后求入度为 $0$ 的起点的个数</li><li>第二问，入度为 $0$ 和出度为 $0$ 的点的个数的最大值，因为强连通分量内部任意一点都可以到达，如果整个图是一个强连通分量，则不需要连边<ul><li>证明<ul><li>起点和终点可以对称看，故只证明一边，不妨设 $|P| \le |Q|$</li><li>如果 $|P| &#x3D; 1$，在有限步之内，每一个终点都可以被走到，因此只需要从每一个终点连一条到起点的边</li><li>如果 $|P| &gt; 1$，则一定至少有 $P_1 \to Q_1, P_2 \to Q_2$，考虑反证法，如果找不到这样的两个点，所有的起点都只能走到一个终点，而其他的终点必然能够找到一个起点，故矛盾。同时，只要连一条边，就可以让原先起点和终点两个集合中的点数都减一</li></ul></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110, M = 50010;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt;
int din[N], dout[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u)&#123;
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u;
    in_stk[u] = true;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j);
            low[u] = min(low[u], low[j]);
        &#125;else if(in_stk[j])&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    if(dfn[u] == low[u])&#123;
        int y;
        ++scc_cnt;
        do&#123;
            y = stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;
        &#125;while(y != u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    int n; cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        while(cin &gt;&gt; x, x)&#123;
            add(i, x);
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!dfn[i]) tarjan(i);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = h[i]; ~j; j = ne[j])&#123;
            int k = e[j];
            int a = id[i], b = id[k];
            if(a != b)&#123;
                dout[a]++;
                din[b]++;
            &#125;
        &#125;
    &#125;
    int cnt1 = 0, cnt2 = 0;
    for(int i = 1; i &lt;= scc_cnt; i++)&#123;
        if(!dout[i]) cnt2++;
        if(!din[i]) cnt1++;
    &#125;
    cout &lt;&lt; cnt1 &lt;&lt; &#39;\n&#39;;
    if(scc_cnt == 1) cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
    else cout &lt;&lt; max(cnt1, cnt2) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-最大半连通子图"><a href="#AcWing-最大半连通子图" class="headerlink" title="AcWing|最大半连通子图"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Ny8=">AcWing|最大半连通子图</span></h3><ul><li>强连通分量一定是半连通</li><li>tarjan，缩点，建图（给边排重），之后按照拓扑序递推（节点编号倒着即为拓扑序）</li><li>求 <strong>最大半连通子图</strong> 等价于求 <strong>最长无分叉链</strong> ，链上权重是连通分量里的节点数</li><li>求 <strong>最长链方案数</strong> 等价于 <strong>拓扑图求最长路</strong> （权重是结点数），与背包问题求方案数相类似</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010, M = 2000010;
int n, m, mod;
int h[N], hs[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, sz[N];
int f[N], g[N];
void add(int h[], int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u)&#123;
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = true;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j);
            low[u] = min(low[u], low[j]);
        &#125;else if(in_stk[j])&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    if(dfn[u] == low[u])&#123;
        ++scc_cnt;
        int y;
        do&#123;
            y = stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;
            sz[scc_cnt]++;
        &#125;while(y != u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;
    memset(h, -1, sizeof(h));
    memset(hs, -1, sizeof(hs));
    while(m--)&#123;
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        add(h, a, b);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!dfn[i]) tarjan(i);
    &#125;
    unordered_set&lt;LL&gt; st; // (u, v) -&gt; u * 1000000 + v;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = h[i]; ~j; j = ne[j])&#123;
            int k = e[j];
            int a = id[i], b = id[k];
            LL tmp = a * 1000000ll + b;
            if(a != b &amp;&amp; !st.count(tmp))&#123;
                st.insert(tmp);
                add(hs, a, b);
            &#125;
        &#125;
    &#125;
    for(int i = scc_cnt; i; i--)&#123;
        if(!f[i])&#123;
            f[i] = sz[i];
            g[i] = 1;
        &#125;
        for(int j = hs[i]; ~j; j = ne[j])&#123;
            int k = e[j];
            if(f[k] &lt; f[i] + sz[k])&#123;
                f[k] = f[i] + sz[k];
                g[k] = g[i];
            &#125;else if(f[k] == f[i] + sz[k])&#123;
                g[k] = (g[k] + g[i]) % mod;
            &#125;
        &#125;
    &#125;
    int maxf = 0, sum = 0;
    for(int i = 1; i &lt;= scc_cnt; i++)&#123;
        if(maxf &lt; f[i])&#123;
            maxf = f[i];
            sum = g[i];
        &#125;else if(maxf == f[i])&#123;
            sum = (sum + g[i]) % mod;
        &#125;
    &#125;
    cout &lt;&lt; maxf &lt;&lt; &#39;\n&#39; &lt;&lt; sum &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-银河"><a href="#AcWing-银河" class="headerlink" title="AcWing|银河"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzcwLw==">AcWing|银河</span></h3><ul><li>与差分约束-糖果类似，这里使用强连通分量解法，求最小值转化成求最长路</li><li>强连通分量时间复杂度稳定线性</li><li>所以边权大于等于 $0$ ，判断是否存在正环，故可以使用强连通分量解，对于强连通分量中任意两点，只要边权大于 $0$ 则必定存在正环</li><li>tarjan，缩点建图，拓扑序递推求最长路</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010, M = 600010;
int n, m;
int h[N], hs[N], e[M], ne[M], w[M], idx;
int dfn[N], low[N], timestamp;
bool in_stk[N];
int stk[N], top;
int id[N], scc_cnt, sz[N];
int dist[N];
void add(int h[], int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u)&#123;
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = true;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j);
            low[u] = min(low[u], low[j]);
        &#125;else if(in_stk[j])&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    if(dfn[u] == low[u])&#123;
        ++scc_cnt;
        int y;
        do&#123;
            y = stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;
            sz[scc_cnt]++;
        &#125;while(y != u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    memset(hs, -1, sizeof(hs));
    for(int i = 1; i &lt;= n; i++)&#123;
        add(h, 0, i, 1);
    &#125;
    while(m--)&#123;
        int t, a, b;
        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;
        if(t == 1) add(h, a, b, 0), add(h, b, a, 0);
        else if(t == 2) add(h, a, b, 1);
        else if(t == 3) add(h, b, a, 0);
        else if(t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    &#125;
    tarjan(0);
    bool ok = 1;
    for(int i = 0; i &lt;= n; i++)&#123;
        for(int j = h[i]; ~j; j = ne[j])&#123;
            int k = e[j];
            int a = id[i], b = id[k];
            if(a == b)&#123;
                if(w[j] &gt; 0)&#123;
                    ok = 0;
                    break;
                &#125;
            &#125;else&#123;
                add(hs, a, b, w[j]);
            &#125;
        &#125;
        if(!ok) break; 
    &#125;
    if(!ok) cout &lt;&lt; &quot;-1\n&quot;;
    else&#123;
        for(int i = scc_cnt; i; i--)&#123;
            for(int j = hs[i]; ~j; j = ne[j])&#123;
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            &#125;
        &#125;
        LL ans = 0;
        for(int i = 1; i &lt;= scc_cnt; i++)&#123;
            ans += 1ll * dist[i] * sz[i];
        &#125;
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><hr><h2 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h2><ul><li>别称：重连通分量 （Tarjan 发明）</li><li>双连通分量<ol><li>边双连通分量 e-DCC<ul><li>不含有桥的连通区域，不管删掉哪条边，这个图都还是连通的</li><li>在一个边的双连通分量里，任意两点间都包含两个不相交的路径，即没有公共边</li><li>极大的不包括桥的连通块</li></ul></li><li>点双连通分量 v-DCC<ul><li>割点：一个图中删掉一个点后变成不连通图，这个点被称为割点</li><li>极大的不包括割点的连通块</li><li>每个割点至少属于两个点双连通分量</li></ul></li></ol></li><li>Tarjan 算法<ul><li>边双连通分量<ul><li>引入时间戳，对每个点定义两个时间戳：$dfn[u]$ 表示遍历到 $u$ 的时间戳，$low[u]$ 表示从 $u$ 开始走，所能遍历到的最小时间戳是什么</li><li>无横叉边</li><li>如何找到桥<ul><li>桥 $(x&#x2F;leftrightarrow y)$ $&#x2F;leftrightarrow$ $dfn[x] &lt; low[y]$</li></ul></li><li>如何找到所有边的双连通分量<ul><li>将所有桥删掉</li><li>stack $dfn[x] &#x3D; low[x]$</li></ul></li></ul></li><li>点双连通分量<ul><li>引入时间戳，对每个点定义两个时间戳：$dfn[u]$ 表示遍历到 $u$ 的时间戳，$low[u]$ 表示从 $u$ 开始走，所能遍历到的最小时间戳是什么引入时间戳</li><li>如何找到割点<ul><li>$dfn[x] \le low[y]$<ol><li>$x$ 不是根节点，那么 $x$ 是割点</li><li>$x$ 是根节点，至少有两个子节点 $y_i$，$dfn[x] \le low[y_i]$</li></ol></li></ul></li><li>如何求点双连通分量<pre><code class="cpp">stk[]
if(dfn[x] &lt;= low[y])&#123;
    cnt++;
    if(x != root || cnt &gt; 1) x为割点
    stk.pop(j) while(j != y) 将栈中元素弹出至 y 为止
    且 x 也属于该双连通分量
&#125;
</code></pre></li></ul></li></ul></li></ul><h3 id="AcWing-冗余路径"><a href="#AcWing-冗余路径" class="headerlink" title="AcWing|冗余路径"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk3Lw==">AcWing|冗余路径</span></h3><ul><li>给定一个无向连通图，问最少加几条边，可以将其变成一个边双连通分量</li><li>对双连通分量做完缩点后只剩桥和点，可以发现对左右两个叶子节点连通后，根节点连向左右叶子节点的边就可以删去了</li><li>(cnt + 1) &#x2F; 2 向下取整</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 5010, M = 20010;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
int d[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u, int from)&#123;
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if(dfn[u] &lt; low[j])&#123;
                is_bridge[i] = is_bridge[i ^ 1] = 1;
            &#125;
        &#125;else if(i != (from ^ 1))&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    if(dfn[u] == low[u])&#123;
        int y;
        ++dcc_cnt;
        do&#123;
            y = stk[top--];
            id[y] = dcc_cnt;
        &#125;while(y != u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    while(m--)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
        add(b, a);
    &#125;
    tarjan(1, -1);
    for(int i = 0; i &lt; idx; i++)&#123;
        if(is_bridge[i])&#123;
            d[id[e[i]]]++;
        &#125;
    &#125;
    int cnt = 0;
    for(int i = 1; i &lt;= dcc_cnt; i++)&#123;
        if(d[i] == 1) cnt++;
    &#125;
    cout &lt;&lt; (cnt + 1) / 2 &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h3 id="AcWing-电力"><a href="#AcWing-电力" class="headerlink" title="AcWing|电力"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE4NS8=">AcWing|电力</span></h3><ul><li>统计连通块个数</li><li>枚举从哪个块中删除某个点能分成多少块</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010, M = 30010;
int dfn[N], low[N], timestamp;
int h[N], e[M], ne[M], idx;
int ans;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u, int root)&#123;
    dfn[u] = low[u] = ++timestamp;
    int cnt = 0;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j, root);
            low[u] = min(low[u], low[j]);
            if(dfn[u] &lt;= low[j])&#123;
                cnt++;
            &#125;
        &#125;else&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
    if(u != root)&#123;
        cnt++;
    &#125;
    ans = max(ans, cnt);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m)&#123;
        if(!n &amp;&amp; !m) break;
        memset(h, -1, sizeof(h));
        memset(dfn, 0, sizeof(dfn));
        idx = timestamp = 0;
        while(m--)&#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            add(a, b);
            add(b, a);
        &#125;
        ans = 0;
        int cnt = 0;
        for(int root = 0; root &lt; n; root++)&#123;
            if(!dfn[root])&#123;
                tarjan(root, root);
                cnt++;
            &#125;
        &#125;
        cout &lt;&lt; ans + cnt - 1 &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-矿场搭建-🌖🌖"><a href="#AcWing-矿场搭建-🌖🌖" class="headerlink" title="AcWing|矿场搭建 🌖🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk4Lw==">AcWing|矿场搭建</span> 🌖🌖</h3><ul><li>给定一个无向图，问最少在几个点上设置出口，可以使得任意一点坍塌，其余所有点都可以与某个出口连通</li><li>出口数量 $\ge 2$</li><li>分别看每个连通块<ul><li>无割点，$C_{cnt}^2$ 种出口方案</li><li>有割点，缩点，先将每个割点单独作为一个点，从每个 v-DCC 向其所包含的每个割点连个边<ul><li>v-DCC 度数为 1，需要在该分量内部（非割点）放一个出口</li><li>v-DCC 度数 $&gt; 1$ 无需设置出口</li></ul></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 510, M = 1010;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int dcc_cnt;
vector&lt;int&gt; dcc[N];
bool cut[N];
int root;

void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void tarjan(int u)&#123;
    low[u] = dfn[u] = ++timestamp;
    stk[++top] = u;
    // 1. u 是孤立点
    if(u == root &amp;&amp; h[u] == -1)&#123;
        dcc_cnt++;
        dcc[dcc_cnt].push_back(u);
        return ;
    &#125;
    // 2. u 不是孤立点
    int cnt = 0;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(!dfn[j])&#123;
            tarjan(j);
            low[u] = min(low[u], low[j]);
            // 看 j 是不是能连到比 u 还高的地方
            if(dfn[u] &lt;= low[j])&#123;   // j 是 u 的新分支
                cnt++;
                if(u != root || cnt &gt; 1)&#123;
                    cut[u] = true;
                &#125;
                ++dcc_cnt;
                int y;
                do&#123;
                    y = stk[top--];
                    dcc[dcc_cnt].push_back(y);
                &#125;while(y != j); // 弹出到 j 为止
                // 🔺 开新分支 == u 一定和新分支 j 组成一个 dcc 也和旧连通块组成 dcc
                // 那么当前最高点 u 还要被用在更高的包含 u 的旧连通块
                // 所以如果这个时候出栈了 回溯到比 u 高的点的时候 u 就加不进旧连通块里
                dcc[dcc_cnt].push_back(u);
            &#125;
        &#125;else&#123;
            low[u] = min(low[u], dfn[j]);
        &#125;
    &#125;
&#125;

int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int T = 1, n, m;
    while(cin &gt;&gt; m, m)&#123;
        for(int i = 1; i &lt;= dcc_cnt; i++)&#123;
            dcc[i].clear();
        &#125;
        idx = timestamp = n = top = dcc_cnt = 0;
        memset(h, -1, sizeof(h));
        memset(dfn, 0, sizeof(dfn));
        memset(low, 0, sizeof(low));
        memset(cut, 0, sizeof(cut));
        while(m--)&#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            n = max(&#123;n, a, b&#125;);
            add(a, b);
            add(b, a);
        &#125;
        for(root = 1; root &lt;= n; root++)&#123;
            if(!dfn[root])&#123;
                tarjan(root);
            &#125;
        &#125;
        int ans = 0;
        ULL num = 1;
        for(int i = 1; i &lt;= dcc_cnt; i++)&#123;
            int cnt = 0;
            for(int j = 0; j &lt; dcc[i].size(); j++)&#123;
                if(cut[dcc[i][j]])&#123;
                    cnt++;
                &#125;
            &#125;
            if(cnt == 0)&#123;
                if(dcc[i].size() &gt; 1) ans += 2, num *= dcc[i].size() * (dcc[i].size() - 1) / 2;
                else ans++;
            &#125;else if(cnt == 1)&#123;
                ans++;
                num *= dcc[i].size() - 1;
            &#125;
        &#125;
        cout &lt;&lt; &quot;Case &quot; &lt;&lt; T++ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul><li><p>二分图，不存在奇数环，染色法不存在矛盾</p></li><li><p>匈牙利算法，匹配、最大匹配、匹配点、增广路径</p><ul><li>增广路径：非匹配点走，通过非匹配边，匹配边，非匹配边 … 再走到另一块的非匹配点</li><li>最大匹配等价于不存在增广路径</li></ul></li><li><p>最小点覆盖、最大独立集、最小路径点覆盖、最小路径重复点覆盖</p><ul><li>最大匹配数 &#x3D; 最小点覆盖 &#x3D; 总点数 - 最大独立集 &#x3D; 总点数 - 最小路径覆盖</li><li>在二分图中，最小点覆盖 &#x3D; 最大匹配数，<em>证明待看</em></li><li>最大独立集，选出最多的点，使得选出的点之间没有边。在二分图中，求一个最大独立集，等价于去掉最少的点，将所有边都破坏掉，也就是找到最小点覆盖，即找最大匹配</li></ul></li><li><p>最优匹配，KM</p></li><li><p>多重匹配，（最大流</p></li></ul><h3 id="AcWing-关押罪犯"><a href="#AcWing-关押罪犯" class="headerlink" title="AcWing|关押罪犯"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU5Lw==">AcWing|关押罪犯</span></h3><ul><li>二分 + 染色法判断二分图（无向图）</li><li>将罪犯当作点，罪犯之间的仇恨关系当做点与点之间的无向边，边的权重是罪犯之间的仇恨值。那么原问题变成：将所有点分成两组，使得各组内边的权重的最大值尽可能小</li><li>$color$ 数组中，$0$ 表示未染色，$1$ 表示染白色，$2$ 表示染黑色</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20010, M = 200010;
int h[N], e[M], ne[M], w[M], idx;
int color[N];
int n, m;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
bool dfs(int u, int c, int mid)&#123;
    color[u] = c;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        if(w[i] &lt;= mid) continue;
        int j = e[i];
        if(color[j] == c) return false;
        if(!color[j] &amp;&amp; !dfs(j, 3 - c, mid)) return false;
    &#125;
    return true;
&#125;
bool check(int limit)&#123;
    memset(color, 0, sizeof(color));
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!color[i])&#123;
            if(!dfs(i, 1, limit)) return false;
        &#125;
    &#125;
    return true;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    cin &gt;&gt; n &gt;&gt; m;
    while(m--)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c), add(b, a, c);
    &#125;
    int l = 0, r = 1e9;
    while(l &lt; r)&#123;
        int mid = (l + r) &gt;&gt; 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    &#125;
    cout &lt;&lt; l &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-棋盘覆盖"><a href="#AcWing-棋盘覆盖" class="headerlink" title="AcWing|棋盘覆盖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzc0Lw==">AcWing|棋盘覆盖</span></h3><ul><li>把一个骨牌看作一条边，所占的两个格子看作点，因此可以将问题转化成一个棋盘可以最多取多少条边，且所有选出的边无公共点</li><li>用最大匹配来做，经典黑白二分图</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
typedef pair&lt;int, int&gt; PII;
bool g[N][N], st[N][N];
PII match[N][N];
int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;
int n, t;
bool find(int x, int y)&#123;
    for(int i = 0; i &lt; 4; i++)&#123;
        int nx = x + dx[i], ny = y + dy[i];
        if(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; n) continue;
        if(st[nx][ny] || g[nx][ny]) continue;
        st[nx][ny] = true;
        PII t = match[nx][ny];
        if(t.first == -1 || find(t.first, t.second))&#123;
            match[nx][ny] = &#123;x, y&#125;;
            return true;
        &#125;
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; t;
    while(t--)&#123;
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        g[a][b] = true;
    &#125;
    memset(match, -1, sizeof(match));
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            if((i + j) % 2 &amp;&amp; !g[i][j])&#123;
                memset(st, 0, sizeof(st));
                if(find(i, j)) ans++;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-机器任务"><a href="#AcWing-机器任务" class="headerlink" title="AcWing|机器任务"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzc4Lw==">AcWing|机器任务</span></h3><ul><li>$a[i] &#x3D; 0 || b[i] &#x3D; 0$ 时可以跳过</li><li>一个任务 $i$ 可以在两种状态下完成，因此可以将一个任务看成一条边，两种状态看成两个端点，要完成一个任务就要从这两个点中选一个点，对于所有任务来说，就是从 $N + M - 2$ （不包含初始状态）中选出最少的点，覆盖所有的边（任务），问题就变成求最小点覆盖问题</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
int match[N];
bool st[N], g[N][N];
int n, m, k;
bool find(int x)&#123;
    for(int i = 1; i &lt; m; i++)&#123;
        if(g[x][i] &amp;&amp; !st[i])&#123;
            st[i] = true;
            if(match[i] == -1 || find(match[i]))&#123;
                match[i] = x;
                return true;
            &#125;
        &#125;
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    while(cin &gt;&gt; n, n)&#123;
        cin &gt;&gt; m &gt;&gt; k;
        memset(g, 0, sizeof(g));
        while(k--)&#123;
            int op, a, b;
            cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
            g[a][b] = true;
        &#125;
        memset(match, -1, sizeof(match));
        int ans = 0;
        for(int i = 1; i &lt; n; i++)&#123;
            memset(st, 0, sizeof(st));
            if(find(i)) ans++;
        &#125;
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-骑士放置"><a href="#AcWing-骑士放置" class="headerlink" title="AcWing|骑士放置"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTg1Lw==">AcWing|骑士放置</span></h3><ul><li>每个不禁止放的点是一个图节点，每两个可以通过日字形走到的点连一条边，问题为选出最多的点，使得选出来的点之间不能通过日字形走到，可以转化成选出最多的点，使得选出来的点之间没有边</li><li>即为最大独立集问题，可以转化成求最大匹配，且满足二分图，因此可以使用匈牙利算法<ul><li>从白点通过日字形只能走到黑点，因此这是个二分图</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 110;
bool g[N][N], st[N][N];
PII match[N][N];
int n, m, t;
int dx[8] = &#123;-2, -1, 1, 2, -2, -1, 1, 2&#125;, dy[8] = &#123;-1, -2, -2, -1, 1, 2, 2, 1&#125;;
bool find(int x, int y)&#123;
    for(int i = 0; i &lt; 8; i++)&#123;
        int nx = x + dx[i], ny = y + dy[i];
        if(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; m) continue;
        if(g[nx][ny] || st[nx][ny]) continue;
        st[nx][ny] = true;
        PII t = match[nx][ny];
        if(t.first == -1 || find(t.first, t.second))&#123;
            match[nx][ny] = &#123;x, y&#125;;
            return true;
        &#125;
    &#125;
    return false;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;
    for(int i = 1; i &lt;= t; i++)&#123;
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        g[a][b] = true;
    &#125;
    memset(match, -1, sizeof(match));
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            if((i + j) % 2 || g[i][j]) continue;
            memset(st, 0, sizeof(st));
            if(find(i, j)) ans++;
        &#125;
    &#125;
    cout &lt;&lt; n * m - ans - t &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-捉迷藏"><a href="#AcWing-捉迷藏" class="headerlink" title="AcWing|捉迷藏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzgxLw==">AcWing|捉迷藏</span></h3><hr><h2 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h2><ul><li>欧拉路径问题，每条边走一次<ul><li>经典问题：哥尼斯堡七桥问题</li><li>起点的度数和终点的度数都是奇数，途径点的度数都是偶数</li></ul></li><li>对于无向图，所有边都是连通的<ul><li>存在欧拉路径的充分必要条件：度数为奇数的点只能有 0 或 2 个</li><li>存在欧拉回路的充分必要条件：度数为奇数的点只能有 0 个</li></ul></li><li>对于有向图，所有边都是连通的<ul><li>存在欧拉路径的充分必要条件：要么所有点的出度均等于入度，要么除了两个点之外，其余所有点的出度等于入度，剩余的两个点：一个满足出度比入度多 1（起点），另一个满足入度比出度多 1（终点）</li><li>存在欧拉回路的充分必要条件：所有点的出度均等于入度</li></ul></li></ul><h3 id="AcWing-铲雪车"><a href="#AcWing-铲雪车" class="headerlink" title="AcWing|铲雪车"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyNS8=">AcWing|铲雪车</span></h3><ul><li>每条路要铲两个方向，就当作是有向图做，必然存在欧拉回路</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()&#123;
    double x1, y1, x2, y2;
    cin &gt;&gt; x1 &gt;&gt; y1;
    double sum = 0;
    while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)&#123;
        double dx = x2 - x1, dy = y2 - y1;
        sum += sqrt(dx * dx + dy * dy) * 2;
    &#125;
    int minutes = round(sum / 1000 / 20 * 60);
    int hours = minutes / 60;
    minutes %= 60;
    cout &lt;&lt; hours &lt;&lt; &quot;:&quot; &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; minutes &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-欧拉回路"><a href="#AcWing-欧拉回路" class="headerlink" title="AcWing|欧拉回路"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE4Ni8=">AcWing|欧拉回路</span></h3><ul><li>无向图<ul><li>所有点的度数必须是偶数</li><li>所有边连通</li></ul></li><li>有向图<ul><li>所有点的入度等于出度</li><li>所有边连通</li></ul></li><li><img data-src="https://cdn.acwing.com/media/article/image/2021/06/16/42785_76564c8cce-QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE20210616101308.png" alt="img"></li><li><img data-src="https://cdn.acwing.com/media/article/image/2021/06/16/42785_57cbd99cce-QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE20210616102633.png" alt="img"></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, M = 400010;
int h[N], e[M], ne[M], idx;
bool used[M];
int ans[M], cnt;
int din[N], dout[N];
int type;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u)&#123;
    // 使用引用, 可以直接在i=ne[i]中, 将边删掉
    for(int &amp;i = h[u]; ~i; )&#123;
        if(used[i])&#123;
            i = ne[i];
            continue;
        &#125;
        used[i] = 1;
        if(type == 1) used[i ^ 1] = 1;

        int t;
        if(type == 1)&#123;
            t = i / 2 + 1;      // 边的编号
            if(i &amp; 1) t = -t;   // 反向边
        &#125;else&#123;
            t = i + 1;
        &#125;
        int j = e[i];
        i = ne[i];              // 边用过之后直接删了
        dfs(j);
        ans[++cnt] = t;         // 从下往上将点输入到路径中,因为从上往下的过程中,可能边路有些环并没有被顾虑到
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; type &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 0; i &lt; m; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
        if(type == 1)&#123;
            add(b, a);
        &#125;
        din[b]++, dout[a]++;
    &#125;
    if(type == 1)&#123;
        for(int i = 1; i &lt;= n; i++)&#123;
            if(din[i] + dout[i] &amp; 1)&#123;
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;
        &#125;
    &#125;else&#123;
        for(int i = 1; i &lt;= n; i++)&#123;
            if(din[i] != dout[i])&#123;
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;
        &#125;
    &#125;
    // 遍历时可能有孤立点--找一个包含边的起点
    for(int i = 1; i &lt;= n; i++)&#123;
        if(h[i] != -1)&#123;
            dfs(i);
            break;
        &#125;
    &#125;

    if(cnt &lt; m)&#123;
        cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;
    &#125;else&#123;
        cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;
        for(int i = cnt; i &gt;= 1; i--)&#123;
            cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-骑马修栅栏"><a href="#AcWing-骑马修栅栏" class="headerlink" title="AcWing|骑马修栅栏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyNi8=">AcWing|骑马修栅栏</span></h3><ul><li>要求字典序最小<ul><li>只需要从小往大枚举即可</li><li>先遍历 1 号点（编号从 1 到 n），则 1 号点一定最后被加入欧拉路径。因此只要按照从小到大的点的序号搜，就可以得到字典序最小的欧拉路径（最后逆序输出，最小的点会最后加入 ans)</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 510;
int n = 500, m;
int g[N][N];
int ans[1110], cnt;
int d[N];
void dfs(int u)&#123;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(g[u][i])&#123;
            g[u][i]--, g[i][u]--;
            dfs(i);
        &#125;
    &#125;
    ans[++cnt] = u;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; m;
    while(m--)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        g[a][b]++, g[b][a]++;
        d[a]++, d[b]++;
    &#125;
    int st = 1;
    while(!d[st]) st++;
    for(int i = 1; i &lt;= 500; i++)&#123;
        if(d[i] % 2)&#123;
            st = i;
            break;
        &#125;
    &#125;
    dfs(st);
    for(int i = cnt; i &gt;= 1; i--)&#123;
        cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-单词游戏"><a href="#AcWing-单词游戏" class="headerlink" title="AcWing|单词游戏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE4Ny8=">AcWing|单词游戏</span></h3><ul><li>每个单词可以当作一条有向边，第一个字母连到最后一个字母</li><li>因此本题转换成有向图是否存在欧拉路径</li><li>判断是否连通采用并查集维护<ul><li>度数满足的情况下，如果又是都在同一个集合中，则一定存在欧拉路径</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 30;
int p[N], din[N], dout[N];
bool st[N];
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    string s;
    int t;
    cin &gt;&gt; t;
    while(t--)&#123;
        int n;
        cin &gt;&gt; n;
        memset(din, 0, sizeof(din));
        memset(dout, 0, sizeof(dout));
        memset(st, 0, sizeof(st));
        for(int i = 0; i &lt; 26; i++)&#123;
            p[i] = i;
        &#125;
        for(int i = 1; i &lt;= n; i++)&#123;
            cin &gt;&gt; s;
            int a = s[0] - &#39;a&#39;, b = s[s.size() - 1] - &#39;a&#39;;
            st[a] = st[b] = 1;
            dout[a]++, din[b]++;
            p[find(a)] = find(b);
        &#125;

        int start = 0, end = 0;
        bool ok = 1;
        for(int i = 0; i &lt; 26; i++)&#123;
            if(din[i] != dout[i])&#123;
                if(din[i] == dout[i] + 1) end++;
                else if(dout[i] == din[i] + 1) start++;
                else&#123;
                    ok = 0;
                    break;
                &#125;
            &#125;
        &#125;
        if(ok &amp;&amp; !(!start &amp;&amp; !end || start == 1 &amp;&amp; end == 1))&#123;
            ok = 0;
        &#125;
        // 判断连通
        int rep = -1;
        for(int i = 0; i &lt; 26; i++)&#123;
            if(st[i])&#123;
                if(rep == -1) rep = find(i);
                else if(rep != find(i))&#123;
                    ok = 0;
                    break;
                &#125;
            &#125;
        &#125;
        if(ok) cout &lt;&lt; &quot;Ordering is possible.\n&quot;;
        else cout &lt;&lt; &quot;The door cannot be opened.\n&quot;;
    &#125;
&#125;
</code></pre><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li>对有向图来说, 如果有环必然不存在拓扑排序，拓扑图等价于有向无环图（DAG）</li><li>先将所有入度为 0 的点入队</li><li>宽搜框架，将每次更新完入度为 0 的点入队</li><li>要求字典序最小的时候，可以将队列换成小根堆</li></ul><h3 id="AcWing-家谱树"><a href="#AcWing-家谱树" class="headerlink" title="AcWing|家谱树"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE5Mw==">AcWing|家谱树</span></h3><ul><li>队列中的顺序即为拓扑序</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110, M = N * N / 2;
int h[N], e[M], ne[M], idx;
int din[N], n;
int q[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void toposort()&#123;
    int hh = 0, tt = -1;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!din[i])&#123;
            q[++tt] = i;
        &#125;
    &#125;
    while(hh &lt;= tt)&#123;
        int t = q[hh++];
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            din[j]--;
            if(!din[j])&#123;
                q[++tt] = j;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        while(cin &gt;&gt; x, x)&#123;
            add(i, x);
            din[x]++;
        &#125;
    &#125;
    toposort();
    for(int i = 0; i &lt; n; i++)&#123;
        cout &lt;&lt; q[i] &lt;&lt; &quot; &quot;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-奖金"><a href="#AcWing-奖金" class="headerlink" title="AcWing|奖金"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE5NC8=">AcWing|奖金</span></h3><ul><li>差分约束简化版</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20010;
int h[N], e[N], ne[N], idx;
int deg[N];
int dist[N];
int n, m, cnt;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void toposort()&#123;
    queue&lt;int&gt; q;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!deg[i])&#123;
            q.push(i);
            dist[i] = 100;
        &#125;
    &#125;
    while(!q.empty())&#123;
        int t = q.front();
        q.pop();
        cnt++;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            deg[j]--;
            if(!deg[j])&#123;
                q.push(j);
                dist[j] = dist[t] + 1;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(b, a);
        deg[a]++;
    &#125;
    toposort();
    if(cnt &lt; n) cout &lt;&lt; &quot;Poor Xed\n&quot;;
    else&#123;
        int res = 0;
        for(int i = 1; i &lt;= cnt; i++)&#123;
            res += dist[i];
        &#125;
        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-可达性统计"><a href="#AcWing-可达性统计" class="headerlink" title="AcWing|可达性统计"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY2Lw==">AcWing|可达性统计</span></h3><ul><li>有向无环图，因此可以 dp</li><li>先拓扑排序，再倒着推</li><li>集合用二进制表示</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 30010, M = 30010;
int h[N], e[M], ne[M], idx;
int deg[N];
int q[N];
int n, m;
bitset&lt;N&gt; f[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void toposort()&#123;
    int hh = 0, tt = -1;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!deg[i])&#123;
            q[++tt] = i;
        &#125;
    &#125;
    while(hh &lt;= tt)&#123;
        int t = q[hh++];
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            deg[j]--;
            if(!deg[j])&#123;
                q[++tt] = j;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
        deg[b]++;
    &#125;
    toposort();
    for(int i = n - 1; i &gt;= 0; i--)&#123;
        int j = q[i];
        f[j][j] = 1;
        for(int k = h[j]; ~k; k = ne[k])&#123;
            int l = e[k];
            f[j] |= f[l];
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        cout &lt;&lt; f[i].count() &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-车站分级"><a href="#AcWing-车站分级" class="headerlink" title="AcWing|车站分级"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDU4">AcWing|车站分级</span></h3><ul><li>建立虚拟节点，将边数减少，再拓扑排序解决，同上《奖杯》</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2010, M = 1000010;
int n, m;
int h[N], e[M], ne[M], w[M], idx;
int deg[N], vis[N];
int q[N];
int dist[N];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
    deg[b]++;
&#125;
void toposort()&#123;
    int hh = 0, tt = -1;
    for(int i = 1; i &lt;= n + m; i++)&#123;
        if(!deg[i])&#123;
            q[++tt] = i;
        &#125;
        // if(tt == N) tt = 0;
    &#125;
    while(hh &lt;= tt)&#123;
        int t = q[hh++];
        // if(hh == N) hh = 0;
        for(int i = h[t]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(--deg[j] == 0)&#123;
                q[++tt] = j;
                // if(tt == N) tt = 0;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt;= m; i++)&#123;
        int s;
        cin &gt;&gt; s;
        memset(vis, 0, sizeof(vis));
        int stop, start = n, end = 1;
        while(s--)&#123;
            cin &gt;&gt; stop;
            vis[stop] = 1;
            start = min(start, stop);
            end = max(end, stop);
        &#125;
        int ver = n + i;
        for(int j = start; j &lt;= end; j++)&#123;
            if(!vis[j])&#123;
                add(j, ver, 0);
            &#125;else&#123;
                add(ver, j, 1);
            &#125;
        &#125;
    &#125;

    toposort();
    for(int i = 1; i &lt;= n; i++)&#123;
        dist[i] = 1;
    &#125;
    for(int i = 0; i &lt; n + m; i++)&#123;
        int j = q[i];
        for(int k = h[j]; ~k; k = ne[k])&#123;
            int l = e[k];
            dist[l] = max(dist[l], dist[j] + w[k]);
        &#125;
    &#125;
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        ans = max(ans, dist[i]);
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E9%A2%98%E9%9B%86/" rel="tag"><i class="ic i-tag"></i> 题集</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-08-31 07:15:27" itemprop="dateModified" datetime="2022-08-31T07:15:27+08:00">2022-08-31</time> </span><span id="post/图论题集.html" class="item leancloud_visitors" data-flag-title="图论题集" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" title="图论题集">https://asterzc19.github.io/post/图论题集.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;0ff0506797b60902.jpg" title="搜索题集"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>搜索题集</h3></a></div><div class="item right"><a href="/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;06&#x2F;0f4de4af64f8d166.jpg" title="高级数据结构题集"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>高级数据结构题集</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">单源最短路的建图方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%83%AD%E6%B5%AA"><span class="toc-number">1.1.</span> <span class="toc-text">AcWing|热浪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E4%BF%A1%E4%BD%BF"><span class="toc-number">1.2.</span> <span class="toc-text">AcWing|信使</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%A6%99%E7%94%9C%E7%9A%84%E9%BB%84%E6%B2%B9"><span class="toc-number">1.3.</span> <span class="toc-text">AcWing|香甜的黄油</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9"><span class="toc-number">1.4.</span> <span class="toc-text">AcWing|最小花费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E4%BC%98%E4%B9%98%E8%BD%A6"><span class="toc-number">1.5.</span> <span class="toc-text">AcWing|最优乘车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC"><span class="toc-number">1.6.</span> <span class="toc-text">AcWing|昂贵的聘礼</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">单源最短路的综合应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%96%B0%E5%B9%B4%E5%A5%BD"><span class="toc-number">2.1.</span> <span class="toc-text">AcWing|新年好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF"><span class="toc-number">2.2.</span> <span class="toc-text">AcWing|通信线路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%81%93%E8%B7%AF%E4%B8%8E%E8%88%AA%E7%BA%BF%F0%9F%8C%96%F0%9F%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">AcWing|道路与航线🌖🌖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93"><span class="toc-number">2.4.</span> <span class="toc-text">AcWing|最优贸易</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">单源最短路的扩展应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E8%B7%AF%E7%BA%BF"><span class="toc-number">3.1.</span> <span class="toc-text">AcWing|选择最佳路线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%8B%AF%E6%95%91%E5%A4%A7%E5%85%B5%E7%91%9E%E6%81%A9%F0%9F%8C%96%F0%9F%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">AcWing|拯救大兵瑞恩🌖🌖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0%F0%9F%8C%B8"><span class="toc-number">3.3.</span> <span class="toc-text">AcWing|最短路计数🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%A7%82%E5%85%89%F0%9F%8C%B8"><span class="toc-number">3.4.</span> <span class="toc-text">AcWing|观光🌸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Floyd-%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">Floyd 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%89%9B%E7%9A%84%E6%97%85%E8%A1%8C"><span class="toc-number">4.1.</span> <span class="toc-text">AcWing|牛的旅行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%8E%92%E5%BA%8F%F0%9F%8C%B8"><span class="toc-number">4.2.</span> <span class="toc-text">AcWing|排序🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%A7%82%E5%85%89%E4%B9%8B%E6%97%85%F0%9F%8C%B8"><span class="toc-number">4.3.</span> <span class="toc-text">AcWing|观光之旅🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%89%9B%E7%AB%99%F0%9F%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">AcWing|牛站🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E7%9F%AD%E7%BD%91%E7%BB%9C"><span class="toc-number">5.1.</span> <span class="toc-text">AcWing|最短网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">5.2.</span> <span class="toc-text">AcWing|局域网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82"><span class="toc-number">5.3.</span> <span class="toc-text">AcWing|繁忙的都市</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%81%94%E7%BB%9C%E5%91%98"><span class="toc-number">5.4.</span> <span class="toc-text">AcWing|联络员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%BF%9E%E6%8E%A5%E6%A0%BC%E7%82%B9%F0%9F%8C%B8"><span class="toc-number">5.5.</span> <span class="toc-text">AcWing|连接格点🌸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">最小生成树的扩展应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-number">6.1.</span> <span class="toc-text">AcWing|新的开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C"><span class="toc-number">6.2.</span> <span class="toc-text">AcWing|北极通讯网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82"><span class="toc-number">6.3.</span> <span class="toc-text">AcWing|走廊泼水节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%A7%98%E5%AF%86%E7%9A%84%E7%89%9B%E5%A5%B6%E8%BF%90%E8%BE%93%F0%9F%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">AcWing|秘密的牛奶运输🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E7%8E%AF"><span class="toc-number">7.</span> <span class="toc-text">负环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%99%AB%E6%B4%9E"><span class="toc-number">7.1.</span> <span class="toc-text">AcWing|虫洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%A7%82%E5%85%89%E5%A5%B6%E7%89%9B"><span class="toc-number">7.2.</span> <span class="toc-text">AcWing|观光奶牛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8D%95%E8%AF%8D%E7%8E%AF"><span class="toc-number">7.3.</span> <span class="toc-text">AcWing|单词环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.</span> <span class="toc-text">差分约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%B3%96%E6%9E%9C"><span class="toc-number">8.1.</span> <span class="toc-text">AcWing|糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8C%BA%E9%97%B4"><span class="toc-number">8.2.</span> <span class="toc-text">AcWing|区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%8E%92%E9%98%9F%E5%B8%83%E5%B1%80"><span class="toc-number">8.3.</span> <span class="toc-text">AcWing|排队布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%9B%87%E4%BD%A3%E6%94%B6%E9%93%B6%E5%91%98"><span class="toc-number">8.4.</span> <span class="toc-text">AcWing|雇佣收银员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">9.</span> <span class="toc-text">最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%A5%96%E5%AD%99%E8%AF%A2%E9%97%AE"><span class="toc-number">9.1.</span> <span class="toc-text">AcWing|祖孙询问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%B7%9D%E7%A6%BB"><span class="toc-number">9.2.</span> <span class="toc-text">AcWing|距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%F0%9F%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">AcWing|次小生成树🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">10.</span> <span class="toc-text">有向图的强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B"><span class="toc-number">10.1.</span> <span class="toc-text">AcWing|受欢迎的牛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%BB%9C"><span class="toc-number">10.2.</span> <span class="toc-text">AcWing|学校网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E5%A4%A7%E5%8D%8A%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE"><span class="toc-number">10.3.</span> <span class="toc-text">AcWing|最大半连通子图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%93%B6%E6%B2%B3"><span class="toc-number">10.4.</span> <span class="toc-text">AcWing|银河</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">无向图的双连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84"><span class="toc-number">11.1.</span> <span class="toc-text">AcWing|冗余路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%94%B5%E5%8A%9B"><span class="toc-number">11.2.</span> <span class="toc-text">AcWing|电力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA-%F0%9F%8C%96%F0%9F%8C%96"><span class="toc-number">11.3.</span> <span class="toc-text">AcWing|矿场搭建 🌖🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">12.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF"><span class="toc-number">12.1.</span> <span class="toc-text">AcWing|关押罪犯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96"><span class="toc-number">12.2.</span> <span class="toc-text">AcWing|棋盘覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%BA%E5%99%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">12.3.</span> <span class="toc-text">AcWing|机器任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%AA%91%E5%A3%AB%E6%94%BE%E7%BD%AE"><span class="toc-number">12.4.</span> <span class="toc-text">AcWing|骑士放置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%8D%89%E8%BF%B7%E8%97%8F"><span class="toc-number">12.5.</span> <span class="toc-text">AcWing|捉迷藏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84"><span class="toc-number">13.</span> <span class="toc-text">欧拉回路和欧拉路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%93%B2%E9%9B%AA%E8%BD%A6"><span class="toc-number">13.1.</span> <span class="toc-text">AcWing|铲雪车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">13.2.</span> <span class="toc-text">AcWing|欧拉回路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%AA%91%E9%A9%AC%E4%BF%AE%E6%A0%85%E6%A0%8F"><span class="toc-number">13.3.</span> <span class="toc-text">AcWing|骑马修栅栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F"><span class="toc-number">13.4.</span> <span class="toc-text">AcWing|单词游戏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">14.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%AE%B6%E8%B0%B1%E6%A0%91"><span class="toc-number">14.1.</span> <span class="toc-text">AcWing|家谱树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%A5%96%E9%87%91"><span class="toc-number">14.2.</span> <span class="toc-text">AcWing|奖金</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1"><span class="toc-number">14.3.</span> <span class="toc-text">AcWing|可达性统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7"><span class="toc-number">14.4.</span> <span class="toc-text">AcWing|车站分级</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" title="高级数据结构题集">高级数据结构题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" title="搜索题集">搜索题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" title="图论题集">图论题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/STL%E7%AE%80%E4%BB%8B.html" title="STL 简介">STL 简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%96%87%E7%AB%A0/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/CodeForces/" title="分类于 CodeForces">CodeForces</a> <i class="ic i-angle-right"></i> <a href="/categories/AtCoder/" title="分类于 AtCoder">AtCoder</a></div><span><a href="/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" title="题目小集">题目小集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html" title="数学知识">数学知识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" title="网络流">网络流</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">274k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:09</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/图论题集.html",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->