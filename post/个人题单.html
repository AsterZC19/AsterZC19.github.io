<!-- build time:Tue Sep 06 2022 07:01:19 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="题解,题单"><link rel="canonical" href="https://asterzc19.github.io/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>题目小集 - AtCoder - CodeForces - 数据结构 - 算法 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">题目小集</h1><div class="meta"><span class="item" title="创建时间：2022-02-12 18:00:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-12T18:00:20+08:00">2022-02-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/17ec9c377d1b2c89.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/0f4de4af64f8d166.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/0ff0506797b60902.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="item" rel="index" title="分类于 算法"><span itemprop="name">算法</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CodeForces/" itemprop="item" rel="index" title="分类于 CodeForces"><span itemprop="name">CodeForces</span></a><meta itemprop="position" content="3"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/AtCoder/" itemprop="item" rel="index" title="分类于 AtCoder"><span itemprop="name">AtCoder</span></a><meta itemprop="position" content="4"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><p>打算按题型分大类，然后选取相关的题目。</p><p>*部分题目可能也会随着时间流逝，被我删除（</p><p>以下题目相关题解部分来自</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9wenItODQvcG9zdHM=">知乎 | pzr</span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jYWRlLTc0LTEwL3Bvc3Rz">知乎 | Ander</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sdW9ndS5jb20uY24v">洛谷</span></p><h2 id="自然数列全排列（大概意思）"><a href="#自然数列全排列（大概意思）" class="headerlink" title="自然数列全排列（大概意思）"></a>自然数列全排列（大概意思）</h2><h3 id="CodeForces-1617C-Paprika-and-Permutation"><a href="#CodeForces-1617C-Paprika-and-Permutation" class="headerlink" title="CodeForces|1617C. Paprika and Permutation"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTcvcHJvYmxlbS9D">CodeForces|1617C. Paprika and Permutation</span></h3><ul><li><p>题意</p><ul><li>有一个长度为 $n$ 的数组 $a_1, a_2, … , a_n$ 。每次操作你可以选择数组中的一个元素 $a_i$ 和 $x$ ，然后将 $a_i$ 替换为 $a_i ; mod ; x$。</li><li>求至少要多少次操作才能够将数组 $a$ 变为一个 $1$ 到 $n$ 的排列。如果无法实现，输出 <code>-1</code>。</li><li>$t$ 组数据。</li></ul></li><li><p>题解</p></li><li><p>可以发现，对 $a_i$ 进行一次操作，$a_i$ 的值将是 $\left[ 1 , a_i - a_i &#x2F; 2 \right) \cup \left { a_i \right } $ 之间的一个数。而 $a_i \to a_i$ 没有什么意义，所以认为一次操作是将 $a_i$ 变为 $\left[ 1 , a_i - a_i &#x2F; 2 \right)$ 中的一个数。</p><ul><li>考虑这组样例：</li></ul></li></ul><pre><code class="cpp">9
1 2 3 4 18 19 5 6 7
</code></pre><ul><li>这提示我们，如果原来有某个 $a_i$ 已经在 $\left[ 1, n \right ]$ 之间，最好不要对它进行任何操作。（当然，如果 $a_i$ 这个数出现了多次，我们选择其中一个数，不对它进行任何操作。）这样的策略是明智的，假设我们现在令 $a_i \to x$ ，但为了形成排列，现在没有数等于 $a_i$ ，一定又需要对某个 $y : y - y&#x2F;2 &gt; a_i$ 进行操作使得 $y \to a_i$ 。这样一来花费了 $2$ 的代价，还不如直接令 $y \to x$ 。</li><li>接下来我们令 $i &#x3D; 1 … n$ 循环，如果原数组中没有任何数等于 $i$ ，则需要找一个数变化到 $i$ 。此时贪心地将较小的数变化到 $i$ 是比较合适的。例如：</li></ul><pre><code class="cpp">5
1 3 3 4 7
</code></pre><ul><li><p>考虑 $3 \to 2, 7 \to 5$ 是比较合适的。如果 $3$ 不能变化到 $2$ ，显然更不能变化到 $5$ 或更大的数，直接输出 $-1$ 即可。</p></li><li><p>代码</p></li></ul><pre><code class="cpp">void solve()&#123;
    int n;
    cin &gt;&gt; n;
    multiset&lt;int&gt; s;
    int vis[n + 1] = &#123;0&#125;;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        if(x &lt;= n &amp;&amp; !vis[x])&#123;
            vis[x] = 1;
            continue;
        &#125;
        s.insert(x);
    &#125;
    int cnt = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(vis[i])&#123;
            continue;
        &#125;
        if(*s.begin() - *s.begin()/2 &gt; i)&#123;
            s.erase(s.begin());
            cnt++;
        &#125;else&#123;
            cout &lt;&lt; -1 &lt;&lt; endl;
            return;
        &#125;
    &#125;
    cout &lt;&lt; cnt &lt;&lt; endl;
&#125;
</code></pre><h3 id="CodeForces-1624C-Division-by-Two-and-Permutation"><a href="#CodeForces-1624C-Division-by-Two-and-Permutation" class="headerlink" title="CodeForces|1624C. Division by Two and Permutation"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MjQvcHJvYmxlbS9D">CodeForces|1624C. Division by Two and Permutation</span></h3><ul><li>题意<ul><li>有一个长度为 $n$ 的数组 $a$。你可以对其中的数进行以下操作：<ul><li>不断除以 $2$ ，并向下取整。</li></ul></li><li>问能否在若干次操作后，使得 $a$ 数组变成一个 $1 \sim n$ 的全排列。</li></ul></li><li>题解<ul><li>当这个数大于 $n$ 时，要进行上述操作。</li><li>当全排列中出现了重复数字，该重复数字需要进行上述操作。</li></ul></li><li>代码</li></ul><pre><code class="cpp">void solve()&#123;
    int n;
    memset(cnt, 0, sizeof(cnt));
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        while(x &gt; n || (x &lt;= n &amp;&amp; cnt[x] &amp;&amp; x / 2 &gt; 0)) x /= 2;
        cnt[x]++;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!cnt[i])&#123;
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
            return ;
        &#125;
    &#125;
    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="CodeForces-1613C-Poisoned-Dagger"><a href="#CodeForces-1613C-Poisoned-Dagger" class="headerlink" title="CodeForces|1613C. Poisoned Dagger"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTMvcHJvYmxlbS9D">CodeForces|1613C. Poisoned Dagger</span></h3><ul><li><p>题意</p><ul><li>勇士在第 $a_1, a_2, … , a_n$ 秒使恶龙中毒，中毒属性至多持续 $k$ 秒，每秒将造成一点伤害。问 $k$ 至少是多少，才能造成 $h$ 点或以上的伤害？</li></ul></li><li><p>题解</p><ul><li>可以二分答案寻找 $k$ 。</li></ul></li><li><p>代码</p></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
// binary_search
void solve()&#123;
    LL n, h;
    cin &gt;&gt; n &gt;&gt; h;
    LL a[n + 1];
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
    &#125;
    LL l = 1, r = h;
    while(l &lt; r)&#123;
        LL mid = (l + r) &gt;&gt; 1;
        LL res = h - mid;
        for(int i = 2; i &lt;= n; i++)&#123;
            if(res &lt;= 0) break;
            res -= min(a[i] - a[i - 1], mid);
        &#125;
        if(res &lt;= 0) r = mid;
        else l = mid + 1;
    &#125;
    cout &lt;&lt; l &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre><h3 id="CodeForces-1624D-Palindromes-Coloring"><a href="#CodeForces-1624D-Palindromes-Coloring" class="headerlink" title="CodeForces|1624D. Palindromes Coloring"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MjQvcHJvYmxlbS9E">CodeForces|1624D. Palindromes Coloring</span></h3><ul><li>题意<ul><li>给定一个长度为 $n$ 的字符串，可以给其中一些字符染色（可以不染），颜色种类不超过 $k$。然后将同种颜色的字符进行任意交换。</li><li>定义一个颜色串为，所有染上此颜色的字符按照 <strong>原串顺序（可以为交换后）</strong> 组成的字符串。</li><li>你要使得所有颜色串均为回文串，并且所有颜色串长度的最小值最大。求这个最大值。</li><li>多组测试</li></ul></li><li>题解<ul><li>由要求的 <strong>最小值最大</strong> 可知，该题可以使用二分，下证：</li><li>假设现在颜色串长度的最小值为 $len$ ，那么所有长度 $&gt; len$ 的颜色串一定可以通过删除某些字符（相当于不染一些字符），变成一个长度为 $len$ 的回文串。</li><li>也就是说，我们只需判断是否存在 $k$ 个长度为 $len$ 的回文颜色串即可。</li><li>同理，如果颜色串长度为 $len$ 可以，那么 $len - 1$ 也可以。这就说明了 $len$ 具有单调性，故可以使用二分。</li><li>又发现我们可以不限次数地交换同颜色字符。这说明我们可以将颜色串字符的顺序进行任意变换，得到我们想要的颜色串。</li><li>所以，我们只需知道同颜色的字符有哪些，就可以快速判断它是否为回文串。统计出每个字符出现的次数，如果它是回文串，要么出现的次数均为偶数（颜色串长度为偶数），要么只有一个奇数（颜色串长度为奇数）。</li><li>据此，我们可以使用一个桶记录下整个字符串中各个字符出现的次数。<ul><li>若 $len$ 为偶数，我们就要为 $k$ 种不同颜色串提供 $\frac{len}{2}$ 对相同字符，总共就是 $k \times \frac{len}{2}$ 对。直接判断 $\sum_{i &#x3D; 1}^{26} \left \lfloor \frac{cnt_i}{2} \right \rfloor $ 是否大于等于 $k \times \frac{len}{2}$ 即可。</li><li>若 $len$ 为奇数，同理，先判断 $\sum_{i &#x3D; 1}^{26} \left \lfloor \frac{cnt_i}{2} \right \rfloor $ 是否大于等于 $k \times \left \lfloor \frac{len}{2} \right \rfloor$，因为长度为奇数的回文串还有中间一个落单的字符，所以还需判断剩下未使用的字符是否大于等于 $k$。</li></ul></li><li>时间复杂度 $O(26n log n)$</li></ul></li><li>代码</li></ul><pre><code class="cpp">bool check(LL x)&#123;
    LL cnt[27];
    memset(cnt, 0, sizeof(cnt));
    for(int i = 1; i &lt;= n; i++)&#123; // 桶计数
        cnt[str[i-1] - &#39;a&#39; + 1]++;
    &#125;
    LL tmp = x/2, tot = 0;  // tmp表示需要多少对相同字符
    for(int i = 1; i &lt;= 26; i++)&#123;   // 计算最多有多少对相同字符
        tot += cnt[i]/2;
    &#125;
    if(tot &lt; tmp * k) return 0; // 数量不够的话直接返回 false
    if(x % 2 == 0) return 1;
    tot = 0;
    for(int i = 1; i &lt;= 26; i++)&#123;   // 长度为奇数时，计算总字符个数
        tot += cnt[i];
    &#125;
    return tot &gt;= x * k;
&#125;
</code></pre><h3 id="CodeForces-1610C-Keshi-Is-Throwing-a-Party"><a href="#CodeForces-1610C-Keshi-Is-Throwing-a-Party" class="headerlink" title="CodeForces|1610C. Keshi Is Throwing a Party"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTAvcHJvYmxlbS9D">CodeForces|1610C. Keshi Is Throwing a Party</span></h3><ul><li>题意<ul><li>有 $n$ 个人，第 $i$ 个人有 $i$ 元。现在要邀请若干个人参加聚会若<ul><li>钱数大于 $i$ 的人的个数小于等于 $a_i$。</li><li>钱数小于 $i$ 的人的个数小于等于 $b_i$。</li></ul></li><li>则这个人会高兴，求 <strong>最多</strong> 邀请多少个人使得每个参加宴会的人都会高兴。</li></ul></li><li>题解<ul><li>题意中出现了 <strong>最多</strong>，故考虑二分。</li><li>假设存在邀请 $k$ 个人的方案，那么邀请 $k - 1, k - 2 … 1$ 个人都一定可以。反过来如果 $k$ 个人的方案不行，那么 $k + 1, k + 2 … n$ 个人的方案一定都不行。</li><li>因此该题可以对 <em>能够邀请的人数</em> 进行二分。</li><li>之后考虑贪心判断人数是否可行。</li><li>现在的目标是根据已选的总人数判断我们可以选出的最多人数。</li><li>对于第 $i$ 个人，如果 $b_i \ge cnt$ 并且 $a_i \le sum - cnt - 1$，此时如果邀请 $i$ ，他会很开心，所以我们一定会邀请他。因此扫一遍所有人，我们就得到了实际选择的人数，最后将其与 $sum$ 比较即可。</li></ul></li></ul><pre><code class="cpp">bool check(int sum)&#123;
    int cnt = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(b[i] &gt;= cnt &amp;&amp; a[i] &gt;= (sum - cnt - 1)) cnt++;
    &#125;
    return (cnt &gt;= sum);
&#125;
void solve()&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];
    int l = 1, r = n;
    while(l &lt; r)&#123;
        int mid = (l + r + 1) &gt;&gt; 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    &#125;
    cout &lt;&lt; l &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="CodeForces-1613D-MEX-Sequences"><a href="#CodeForces-1613D-MEX-Sequences" class="headerlink" title="CodeForces|1613D. MEX Sequences"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTMvcHJvYmxlbS9E">CodeForces|1613D. MEX Sequences</span></h3><ul><li><p>题意：求满足以下条件的子序列 $(a_1, … , a_n)$ 的数量。</p><ul><li>对任意的 $a_i$ ，有 $| a_i - MEX(a_1, a_2, … , a_i)| \le 1$ 。</li></ul></li><li><p>题解</p><ul><li>我们考虑子序列如何拓展。</li><li>设 $1.$ 类子序列满足以下条件：最大值为 $x$ ，且包含了 $[0, x]$ 中的所有整数。则其下一个数可选 $x, x + 1, x + 2$ 。如果选前两个，则其仍然是 $1.$ 类子序列。如果选择 $x + 2$ ，则转化为另一类子序列。<ul><li>空序列是 $1.$ 类子序列。</li></ul></li><li>设 $2.$ 类子序列满足以下条件：最大值为 $x$ ，且包含了 $[0, x - 2]$ 的所有整数，却不包含 $x - 1$ 。则其下一个数可选 $x - 2$ 或 $x$ 。无论选择哪一个，其 $MEX$ 值均不改变。</li><li>所以，所有满足条件的序列都可以分为这两类。</li><li>设 <strong>$dp[x][0&#x2F;1]$</strong> 是最大值为 $x$ 的 $1. &#x2F; 2.$ 类子序列的数量，则可以进行状态转移。</li></ul></li><li><p>代码</p></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int MOD = 998244353;
void solve()&#123;
    int n;
    cin &gt;&gt; n;
    LL dp[n + 4][2] = &#123;0&#125;;
    dp[0][0] = 1;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        x++;
        dp[x][0] += dp[x][0] + dp[x - 1][0];
        dp[x][1] += dp[x][1];
        dp[x + 2][1] += dp[x + 2][1];
        if(x &gt; 1) dp[x][1] += dp[x - 2][0];
        dp[x][0] %= MOD; dp[x][1] %= MOD; dp[x + 2][1] %= MOD;
    &#125;
    LL ans = 0;
    for(int i = 1; i &lt;= n + 1; i++)&#123;
        ans += dp[i][0] + dp[i][1];
        ans %= MOD;
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre><h3 id="CodeForces-1637D-Yet-Another-Minimization-Problem"><a href="#CodeForces-1637D-Yet-Another-Minimization-Problem" class="headerlink" title="CodeForces|1637D. Yet Another Minimization Problem"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MzcvcHJvYmxlbS9E">CodeForces|1637D. Yet Another Minimization Problem</span></h3><ul><li>题意<ul><li>给定等长的 $a, b$ 数组，你可以多次交换 $a, b$ ，请最小化 $\sum_{i &#x3D; 1}^{n} \sum_{j &#x3D; i + 1}^{n} (a_i + a_j)^2 + \sum_{i &#x3D; 1}^{n} \sum_{j &#x3D; i + 1}^{n} (b_i + b_j)^2$</li></ul></li><li>题解<ul><li>这个等式可以转换成 $(a_1 + a_2 + … + a_n)^2 +(b_1 + b_2 + … + b_n)^2 + (n - 2)(a_1^{2} + a_2^{2} + … + a_n^{2}) + (n - 2)(b_1^{2} + b_2^{2} + … + b_n^{2})$</li><li>因为该式子右边部分是固定的，所以只需要考虑左边。合理地交换 $a_i, b_i$ 使得左边部分最小即可。</li><li>又因为本题数据很小，可以当成分组背包问题看，算出 $a_1 + a_2 + … + a_n$ 能取到的最小值即可。</li><li>时间复杂度 $O(n(\sum {a_i} + \sum {b_i}))$</li></ul></li><li>代码</li></ul><pre><code class="cpp">void solve()&#123;
    int n;
    cin &gt;&gt; n;
    long long total = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i], total += a[i];
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; b[i], total += b[i];
    &#125;
    int dp[n + 1][total + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt;= total; j++)&#123;
            if(j &gt;= a[i] &amp;&amp; dp[i - 1][j - a[i]]) dp[i][j] = 1;
            if(j &gt;= b[i] &amp;&amp; dp[i - 1][j - b[i]]) dp[i][j] = 1;
        &#125;
    &#125;
    long long ans = 1e17;
    for(int i = 0; i &lt;= total; i++)&#123;    // 求 a的和 b的和的 平方的最小值
        if(dp[n][i]) ans = min(ans, i * i + (total - i) * (total - i));
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        ans += (n - 2) * (a[i] * a[i] + b[i] * b[i]);
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="CodeForces-1638C-Inversion-Graph"><a href="#CodeForces-1638C-Inversion-Graph" class="headerlink" title="CodeForces|1638C. Inversion Graph"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MzgvcHJvYmxlbS9D">CodeForces|1638C. Inversion Graph</span></h4><ul><li>题意<ul><li>给定排序 $p$，对于逆序对 $(p_i, p_j)$，连接一条 $i\longleftrightarrow j$ 的双向边。求整个图的连通块数量。</li><li>多组测试。</li></ul></li><li>题解<ul><li>考虑单调栈，<strong>栈内的每一个元素代表一个独立的连通块（中的元素最大值）</strong>。</li><li>维护方法如下<ul><li>枚举 $i &#x3D; 1 \sim n$ 入栈。</li><li>如果 $a_i$ 小于栈内的某些元素 $t_1, t_2, … , t_x$ ，说明这些元素包括 $a_i$ 同属于一个连通块，故弹出这些元素，以该连通块中的一个最大元素代表这个连通块。</li><li>如果当前 $a_i$ 大于栈内所有的元素，则认为其与前面的连通块之间没有任何直接连边，可认为其为当前状态下是一个最大元素为 $a_i$ 的新的连通块。</li></ul></li><li>时间复杂度为 $O(n)$。</li></ul></li><li>代码</li></ul><pre><code class="cpp">void solve()&#123;
    int n;
    cin &gt;&gt; n;
    stack&lt;int&gt; q;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        if(q.empty())&#123;
            q.push(x);
            continue;
        &#125;
        if(x &gt; q.top()) q.push(x);
        else&#123;
            auto t = q.top();
            while(!q.empty() &amp;&amp; q.top() &gt; x) q.pop();
            q.push(t);
        &#125;
    &#125;
    cout &lt;&lt; q.size() &lt;&lt; endl;
&#125;
</code></pre><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="CodeForces-1562B-Scenes-From-a-Memory"><a href="#CodeForces-1562B-Scenes-From-a-Memory" class="headerlink" title="CodeForces|1562B. Scenes From a Memory"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE1NjIvcHJvYmxlbS9C">CodeForces|1562B. Scenes From a Memory</span></h4><ul><li><p>题意</p><ul><li>给定一个 $k$ 位数，要求对其删除若干位后使其是一个 <strong>非质数</strong> （等于 $1$ 或是一个合数），该数中不含 $0$。</li><li>多组测试。保证有解。</li></ul></li><li><p>题解</p><ul><li><strong>引理</strong> 对于一个三位数 $n$ ，你总可以找到一种方案，删掉至少 $1$ 位，使其剩下最多 $2$ 位且是一个 <strong>非质数</strong>。</li><li><strong>证明</strong> 注意到可以分成以下几种情况考虑：<ol><li>$n$ 中本身含有 $1, 4, 6, 8, 9$ 之一，只保留这一位即可。</li><li>$n$ 中第 $i(i &gt; 1)$ 位是 $2, 5$ 之一，保留第 $1, i$ 位即可。</li><li>$n$ 中有两个相同的数，只保留这两个相同的数即可。</li><li>$n$ 中第 $1$ 位是 $2, 5$ 之一，第 $i(i &gt; 1)$ 位是 $7$，保留第 $1, i$ 位即可。</li></ol></li><li>运用数学归纳法可以把该 <strong>引理</strong> 拓展至 $k$ 位数。</li><li>同时，根据数据范围来看，只需要特判个位数，两位数只需要遍历一遍，判断是否为合数即可，故在此预处理 $100$ 以内的所有数。</li></ul></li><li><p>代码</p></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
int primes[N], cnt;
bool st[N];
void get_primes(int n)
&#123;
    st[1] = true;
    for (int i = 2; i &lt;= n; i++)&#123;
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] &lt;= n / i; j++)&#123;
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
         &#125;
    &#125;
&#125;
void solve()&#123;
    int n, ans = 0;
    cin &gt;&gt; n;
    string s, t;
    cin &gt;&gt; s;
    for(int i = 0; i &lt;= n - 1; i++)&#123;
        int c = s[i] - &#39;0&#39;;
        if(c == 1 || c == 4 || c == 6 || c == 8 || c == 9)&#123;
            ans = c;
            break;
        &#125;
    &#125;
    if(ans)&#123;
        cout &lt;&lt; 1 &lt;&lt; endl;
        cout &lt;&lt; ans &lt;&lt; endl;
        return ;
    &#125;
    for(int i = 0; i &lt;= n - 1; i++)&#123;
        for(int j = i + 1; j &lt;= n - 1; j++)&#123;
            t = s[i];
            t += s[j];
            if(st[stoi(t)])&#123;
                ans = stoi(t);
                cout &lt;&lt; 2 &lt;&lt; endl;
                cout &lt;&lt; ans &lt;&lt; endl;
                return ;
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    get_primes(100);
    int t;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre><h4 id="CodeForces-1635D-Infinite-Set"><a href="#CodeForces-1635D-Infinite-Set" class="headerlink" title="CodeForces|1635D. Infinite Set"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MzUvcHJvYmxlbS9E">CodeForces|1635D. Infinite Set</span></h4><ul><li><p>题意</p></li><li><p>题解</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzAwMDQzMjg=">知乎|pzr</span></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int mod = 1e9 + 7;
void solve()&#123;
    int n, p;
    cin &gt;&gt; n &gt;&gt; p;
    map&lt;LL, bool&gt; mp;
    LL a[n + 1], fib[p + 1] = &#123;0&#125;, pre[p + 1] = &#123;0&#125;;
    fib[0] = 1, fib[1] = 1;
    pre[0] = 1, pre[1] = 2;
    for(int i = 2; i &lt;= p; i++)&#123;
        fib[i] = (fib[i - 1] + fib[i - 2]) % mod;
        pre[i] = (pre[i - 1] + fib[i]) % mod;
    &#125;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], mp[a[i]] = true;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x = a[i];
        while(x)&#123;
            if(x % 2 == 0 &amp;&amp; x % 4 != 0) break;
            if(x % 4 == 0) x /= 4;
            else x /= 2;
            if(mp.find(x) != mp.end())&#123;
                mp.erase(mp.find(a[i]));
                break;
            &#125;
            // x 通过 *(2 + 1), *4 变化到 a[i] 等同于 a[i] 能通过 /2, /4 变化到 x
        &#125;
    &#125;
    LL ans = 0;
    for(auto [num, _] : mp)&#123;
        int w = 64 - __builtin_clzll(num); // 返回前导 0 的个数
        if(w &gt; p) continue;
        ans = (ans + pre[p - w]) % mod;
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    solve();
&#125;
</code></pre><h4 id="CodeForces-1602C-Array-Elimination"><a href="#CodeForces-1602C-Array-Elimination" class="headerlink" title="CodeForces|1602C. Array Elimination"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MDIvcHJvYmxlbS9D">CodeForces|1602C. Array Elimination</span></h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NrX0hvbG1ld2VpL2FydGljbGUvZGV0YWlscy8xMjA5NjQ0NzY=">题解</span></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int gcd(int a, int b)&#123;
    if(b == 0) return a;
    return gcd(b, a % b);
&#125;
void solve()&#123;
    int n;
    cin &gt;&gt; n;
    int _bits[32] = &#123;0&#125;;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        for(int j = 0; j &lt; 31; j++)&#123;
            _bits[j] += (1 &amp; (x &gt;&gt; j));
        &#125;
    &#125;
    int k = _bits[0];
    for(int j = 0; j &lt;= 31; j++) k = gcd(k, _bits[j]);
    if(k == 0)&#123;
        for(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    &#125;else&#123;
        for(int i = 1; i &lt;= k; i++)&#123;
            if(k % i == 0) cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
    cout &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre><h4 id="CodeForces-1656D-K-good"><a href="#CodeForces-1656D-K-good" class="headerlink" title="CodeForces|1656D. K-good"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2NTYvcHJvYmxlbS9E">CodeForces|1656D. K-good</span></h4><ul><li>题意<ul><li>$n$ 能否分为 $k$ 个正整数的和，且这 $k$ 个正整数对 $k$ 的余数两两不同。</li></ul></li><li>分析<ul><li>题意即 $n - k(k + 1) &#x2F; 2 \equiv 0 \quad (mod ; k)$ 且 $n - k(k + 1)&#x2F;2 \ge 0$</li><li>显然，若 $k$ 是偶数，则 $k &#x2F; 2$ 是 $n$ 的因子；若 $k$ 是奇数，则 $k$ 是 $n$ 的因子，所以我们需要对 $n$ 进行一定的因数分解。</li><li>将 $n$ 分解成 $2^t \times s$ 的形式（$s$ 是奇数）。现在取因子的方案大致分为：<ol><li>取 $2^x$，看看 $k &#x3D; 2^{x + 1}$ 是否符合要求。容易证明只有取因子 $2^t ; (k &#x3D; 2^{t + 1})$ 才能满足同余的要求，若此时又有 $n - k(k + 1)&#x2F;2 \ge 0$，输出即可。</li><li>取 $s$ ，只要 $n - s(s + 1)&#x2F;2 \ge 0$ 即可。当然，$k &#x3D; s &#x3D; 1$ 是无法满足要求的。</li><li>其他方案不需要考虑</li></ol></li><li>下证 <em>上 3</em><ul><li>设 $q &#x3D; 2^t , n &#x3D; qs$，其中 $2q(2q + 1)&#x2F;2 &gt; n$ 和 $s(s + 1)&#x2F;2 &gt; n$ 不可能同时满足</li><li>将 $n &#x3D; qs$ 代入即有 $2q + 1 &gt; s, s + 1 &gt; 2q$，即 $s - 1 &lt; 2q &lt; s + 1$，即 $2q &#x3D; s$，这与 $s$ 是奇数矛盾。</li></ul></li><li>所以，以上过程中，$2^t$ 和 $s \ne 1$ 至少有一个满足条件。特殊的是，若 $s &#x3D; 1$，显然我们只能取 $2$ 的幂次，按以上讨论不能满足题意，应输出 <code>-1</code></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
void solve()&#123;
    LL n; cin &gt;&gt; n;
    LL s = n, q = 1;
    while(s % 2 == 0)&#123;
        s /= 2;
        q *= 2;
    &#125;
    
    if(q &lt;= 1e9 &amp;&amp; q * (2 * q + 1) &lt;= n)&#123;
        cout &lt;&lt; 2 * q &lt;&lt; endl;
        return ;
    &#125;
    if(s != 1 &amp;&amp; s &lt;= 2e9 &amp;&amp; s * (s + 1) / 2 &lt;= n)&#123;
        cout &lt;&lt; s &lt;&lt; endl;
        return ;
    &#125;
    cout &lt;&lt; -1 &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h4 id="CodeForces-1436C-Binary-Search"><a href="#CodeForces-1436C-Binary-Search" class="headerlink" title="CodeForces|1436C. Binary Search"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0MzYvcHJvYmxlbS9D">CodeForces|1436C. Binary Search</span></h4><ul><li>题意<ul><li>给定三个正整数 $n, x, pos$，请你求出满足以下条件的数组 $a$ 的个数<ul><li>数组 $a$ 是正整数 $1 \sim n$ 的一种排列，且 $a_{pos} &#x3D; x$ （下标从 $0$ 开始）</li><li>对于数组 $a$ 运行如上代码，其返回值为 <code>true</code></li></ul></li></ul></li><li>分析<ul><li>首先想一下二分查找的过程，如果我们知道了 $x$ 的位置 $pos$，实际上就能确定出来需要找几次了，因为二分查找的前提是满足序列单调性，虽然排列不是单调的，但这个排列的下标是单调的（即 $1, 2, 3, 4, \cdots, n$），不管是按什么二分，折返点的位置是固定的，因此我们直接对下标 $pos$ 二分查找，在这个过程中记录比 $pos$ 大的下标的个数以及比 $pos$ 小的下标的个数，这实际上也就是在最终要构造出来的序列中二分转折点上比 $x$ 大的数的个数以及比 $x$ 小的数的个数。个数确定后就是排列组合问题了，对于这两部分先选再排，剩下的数求全排列，把这些乘起来即可。</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e4 + 10;
const int mod = 1e9 + 7;
LL fact[N], infact[N];
int qmi(int a, int k, int p)&#123;    // 快速幂模板
    int res = 1;
    while (k)&#123;
        if (k &amp; 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k &gt;&gt;= 1;
    &#125;
    return res;
&#125;
LL C(LL n, LL m)&#123;
    return (fact[n] * infact[m] % mod * infact[n - m] % mod);
&#125;
LL A(LL n, LL m)&#123;
    LL ans = 1;
    for(LL i = n; i &gt;= n - m + 1; i--)&#123;
        ans = (ans * i) % mod;
    &#125;
    return ans;
&#125;
int main()&#123;
    int n, x, pos;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; pos;
    int l = 0, r = n;
    LL smaller = 0, bigger = 0;
    while(l &lt; r)&#123;
        int mid = (l + r) &gt;&gt; 1;
        if(mid &gt; pos)&#123;
            r = mid;
            bigger++;
        &#125;else&#123;
            l = mid + 1;
            if(mid &lt; pos) smaller++;
        &#125;
    &#125;
    // 预处理阶乘的余数和阶乘逆元的余数
    fact[0] = infact[0] = 1;
    for (int i = 1; i &lt; N; i++)&#123;
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    &#125;
    LL ans = C(n - x, bigger) * A(bigger, bigger) % mod * C(x - 1, smaller) % mod * A(smaller, smaller) % mod * A(1LL * n - smaller - bigger - 1, 1LL * n - smaller - bigger - 1) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><div class="tags"><a href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag"><i class="ic i-tag"></i> 题解</a> <a href="/tags/%E9%A2%98%E5%8D%95/" rel="tag"><i class="ic i-tag"></i> 题单</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-05 14:22:58" itemprop="dateModified" datetime="2022-09-05T14:22:58+08:00">2022-09-05</time> </span><span id="post/个人题单.html" class="item leancloud_visitors" data-flag-title="题目小集" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" title="题目小集">https://asterzc19.github.io/post/个人题单.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;44d29b2c5b4e40c8.jpg" title="基础算法模板"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 算法</span><h3>基础算法模板</h3></a></div><div class="item right"><a href="/post/STL%E7%AE%80%E4%BB%8B.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;9d2607c6eedc2a1d.jpg" title="STL 简介"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 算法</span><h3>STL 简介</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E6%95%B0%E5%88%97%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E5%A4%A7%E6%A6%82%E6%84%8F%E6%80%9D%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">自然数列全排列（大概意思）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1617C-Paprika-and-Permutation"><span class="toc-number">1.1.</span> <span class="toc-text">CodeForces|1617C. Paprika and Permutation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1624C-Division-by-Two-and-Permutation"><span class="toc-number">1.2.</span> <span class="toc-text">CodeForces|1624C. Division by Two and Permutation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1613C-Poisoned-Dagger"><span class="toc-number">2.1.</span> <span class="toc-text">CodeForces|1613C. Poisoned Dagger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1624D-Palindromes-Coloring"><span class="toc-number">2.2.</span> <span class="toc-text">CodeForces|1624D. Palindromes Coloring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1610C-Keshi-Is-Throwing-a-Party"><span class="toc-number">2.3.</span> <span class="toc-text">CodeForces|1610C. Keshi Is Throwing a Party</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1613D-MEX-Sequences"><span class="toc-number">3.1.</span> <span class="toc-text">CodeForces|1613D. MEX Sequences</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeForces-1637D-Yet-Another-Minimization-Problem"><span class="toc-number">3.2.</span> <span class="toc-text">CodeForces|1637D. Yet Another Minimization Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">杂题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">4.1.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeForces-1638C-Inversion-Graph"><span class="toc-number">4.1.1.</span> <span class="toc-text">CodeForces|1638C. Inversion Graph</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">4.2.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeForces-1562B-Scenes-From-a-Memory"><span class="toc-number">4.2.1.</span> <span class="toc-text">CodeForces|1562B. Scenes From a Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeForces-1635D-Infinite-Set"><span class="toc-number">4.2.2.</span> <span class="toc-text">CodeForces|1635D. Infinite Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeForces-1602C-Array-Elimination"><span class="toc-number">4.2.3.</span> <span class="toc-text">CodeForces|1602C. Array Elimination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeForces-1656D-K-good"><span class="toc-number">4.2.4.</span> <span class="toc-text">CodeForces|1656D. K-good</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeForces-1436C-Binary-Search"><span class="toc-number">4.2.5.</span> <span class="toc-text">CodeForces|1436C. Binary Search</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" rel="bookmark" title="题目小集">题目小集</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/post/STL%E7%AE%80%E4%BB%8B.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html" title="数学知识">数学知识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF.html" title="基础数据结构模板">基础数据结构模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html" title="位运算合集">位运算合集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%96%87%E7%AB%A0/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" title="Flyme 更新日志">Flyme 更新日志</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" title="搜索题集">搜索题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/STL%E7%AE%80%E4%BB%8B.html" title="STL 简介">STL 简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" title="基础算法模板">基础算法模板</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">274k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:09</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/个人题单.html",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->