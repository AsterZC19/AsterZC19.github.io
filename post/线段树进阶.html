<!-- build time:Mon Sep 12 2022 21:42:04 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,题集"><link rel="canonical" href="https://asterzc19.github.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>线段树进阶 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">线段树进阶</h1><div class="meta"><span class="item" title="创建时间：2022-09-06 07:46:22"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-06T07:46:22+08:00">2022-09-06</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>32k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>29 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/17ec9c377d1b2c89.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/5c235cc1bbf7c128.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/40c7bc0e06dce5f2.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2ed81611f053c81c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/21bbfe021cfceec4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/79181978dd20d35c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/848d77945ce37428.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2b1d828f5ff26065.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/7f6edf1d98b0d8a0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/adf69ad6a75c5594.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/0ff0506797b60902.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/a67b0e59dd863077.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/9259140c0ac4c203.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/4203257a6c65e036.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/04b816dd3c5c9934.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/05ac51bc092a5a09.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/9d2607c6eedc2a1d.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/b545cd4703efa0d4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/6cde4a47e73d00cf.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/93a7b0f96c0166ce.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/728c619db3847842.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/a655408706100f86.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/82a4dfcddf3ba7e0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/958c3bf3cd3a0db5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/85da8357bdceba73.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/e82f196e980a63f5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/ff4c0e1d1c41cedd.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p>单开一篇新的文章，结合洛谷题单。</p></blockquote><span id="more"></span><h1 id="普通线段树"><a href="#普通线段树" class="headerlink" title="普通线段树"></a>普通线段树</h1><h2 id="CF240F-TorCoder"><a href="#CF240F-TorCoder" class="headerlink" title="CF240F | TorCoder"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YyNDBG">CF240F | TorCoder</span></h2><ul><li>题意<ul><li>给定一个长为 $n$ 的由 $a$ 到 $z$ 组成的字符串,有 $m$ 次操作，每次操作将 $[l,r]$ 这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法操作就不进行。</li><li>求 $m$ 次操作后的字符串。</li></ul></li><li>分析<ul><li>考虑开 26 棵线段树。每棵线段树维护它对应的字母在这个字符串中的出现情况。</li><li>这个区间中，出现的任何字母的出现次数<strong>要么都为偶数，要么只有一个奇数，其余都是偶数</strong>时，这个区间可以通过字母重排变为一个回文串。所以每棵线段树都需要支持区间求和以查询区间中特定字母的出现次数。</li><li>字典序越小的字母，我们优先把它放前面就可以了。</li><li>具体来说，如果字母的出现次数中有一个奇数，那么先把出现了奇数次的这个字母单拎出来扔到中间。然后，为了保证字典序最小，我们从 $a$ 到 $z$ ，从两边到中间放即可。对于每个字母，一边放一半。因此我们的每棵线段树需要支持区间赋值的操作。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e5 + 10;
struct Node&#123;
    int l, r;
    int sum, tag;
&#125;tr[26][N &lt;&lt; 2];
string s;
inline void pushup(int u, int p)&#123;
    tr[u][p].sum = tr[u][p &lt;&lt; 1].sum + tr[u][p &lt;&lt; 1 | 1].sum;
&#125;
inline void pushdown(int u, int p)&#123;
    if(tr[u][p].tag != -1)&#123;
        tr[u][p &lt;&lt; 1].tag = tr[u][p].tag;
        tr[u][p &lt;&lt; 1 | 1].tag = tr[u][p].tag;
        tr[u][p &lt;&lt; 1].sum = tr[u][p].tag * (tr[u][p &lt;&lt; 1].r - tr[u][p &lt;&lt; 1].l + 1);
        tr[u][p &lt;&lt; 1 | 1].sum = tr[u][p].tag * (tr[u][p &lt;&lt; 1 | 1].r - tr[u][p &lt;&lt; 1 | 1].l + 1);
        tr[u][p].tag = -1;
    &#125;
&#125;
inline void build(int u, int p, int l, int r)&#123;
    tr[u][p] = &#123;l, r, 0, -1&#125;;
    if(l == r)&#123;
        tr[u][p].sum = (s[l] - &#39;a&#39;) == u;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u, p &lt;&lt; 1, l, mid);
    build(u, p &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u, p);
&#125;
inline void modify(int u, int p, int l, int r, int v)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        tr[u][p].tag = v;
        tr[u][p].sum = v * (tr[u][p].r - tr[u][p].l + 1);
        return;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u, p &lt;&lt; 1, l, r, v);
    if(r &gt; mid) modify(u, p &lt;&lt; 1 | 1, l, r, v);
    pushup(u, p);
&#125;
inline int query(int u, int p, int l, int r)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        return tr[u][p].sum;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    int ans = 0;
    if(l &lt;= mid) ans += query(u, p &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query(u, p &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    s = &quot; &quot; + s;
    for(int i = 0; i &lt; 26; i++)&#123;
        build(i, 1, 1, n);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        vector&lt;int&gt; cnt(26);
        int odd = 0, need = -1;
        for(int j = 0; j &lt; 26; j++)&#123;
            cnt[j] = query(j, 1, l, r);
            if(cnt[j] &amp; 1) odd++, need = j;
        &#125;
        if(odd &gt; 1) continue;
        for(int j = 0; j &lt; 26; j++)&#123;
            modify(j, 1, l, r, 0);
        &#125;
        if(odd)&#123;
            --cnt[need];
            modify(need, 1, (l + r) &gt;&gt; 1, (l + r) &gt;&gt; 1, 1);
        &#125;
        int nl = l, nr = r;
        for(int j = 0; j &lt; 26; j++)&#123;
            if(cnt[j])&#123;
                modify(j, 1, nl, nl + cnt[j] / 2 - 1, 1);
                modify(j, 1, nr - cnt[j] / 2 + 1, nr, 1);
                nl += cnt[j] / 2;
                nr -= cnt[j] / 2;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt; 26; j++)&#123;
            if(query(j, 1, i, i))&#123;
                cout &lt;&lt; (char)(j + &#39;a&#39;);
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF242E-XOR-on-Segment"><a href="#CF242E-XOR-on-Segment" class="headerlink" title="CF242E | XOR on Segment"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YyNDJF">CF242E | XOR on Segment</span></h2><ul><li>题意<ul><li>给定 $n$ 个数的序列 $a$，$m$ 次操作，有以下两种操作：<ol><li>求 $\sum_{i &#x3D; l}^{r} a_i$。</li><li>把 $[l, r]$ 区间内每一个值都异或上 $x$。</li></ol></li></ul></li><li>分析<ul><li>平常的线段树都是动态区间询问和或者最值，但是这一道题将修改操作改成了区间异或，显然，我们无法像普通线段树一样操作。</li><li>如果和 $0$ 异或，那么 $1$ 的个数不变；</li><li>如果和 $1$ 异或，相当于将<strong>区间取反</strong>，那么 $1$ 的个数为原来 $0$ 的个数，即 $1$ 的个数为 序列长度 - 1的个数。</li><li>因此将每个数转成二进制，又因为 $a_i \le 10^6$ ，因此只需要开 20 棵线段树，每棵树维护某一位所有数的第 $i$ 进制位为 $1$ 的个数。</li><li>时间复杂度 $O(20nlogn)$。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
typedef long long LL;
struct Node&#123;
    int l, r;
    int sum, tag;
&#125;tr[21][N &lt;&lt; 2];
int pre[21], a[N];
inline void pushup(int u, int p)&#123;
    tr[u][p].sum = tr[u][p &lt;&lt; 1].sum + tr[u][p &lt;&lt; 1 | 1].sum;
&#125;
inline void pushdown(int u, int p)&#123;
    if(tr[u][p].tag)&#123;
        tr[u][p &lt;&lt; 1].sum = (tr[u][p &lt;&lt; 1].r - tr[u][p &lt;&lt; 1].l + 1) - tr[u][p &lt;&lt; 1].sum;
        tr[u][p &lt;&lt; 1].tag ^= tr[u][p].tag;
        tr[u][p &lt;&lt; 1 | 1].sum = (tr[u][p &lt;&lt; 1 | 1].r - tr[u][p &lt;&lt; 1 | 1].l + 1) - tr[u][p &lt;&lt; 1 | 1].sum;
        tr[u][p &lt;&lt; 1 | 1].tag ^= tr[u][p].tag;
        tr[u][p].tag = 0;
    &#125;
&#125;
inline void build(int u, int p, int l, int r)&#123;
    tr[u][p] = &#123;l, r, 0, 0&#125;;
    if(l == r)&#123;
        tr[u][p].sum = (pre[u] &amp; a[l]) != 0;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u, p &lt;&lt; 1, l, mid);
    build(u, p &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u, p);
&#125;
inline void modify(int u, int p, int l, int r)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        tr[u][p].tag ^= 1;
        tr[u][p].sum = (tr[u][p].r - tr[u][p].l + 1) - tr[u][p].sum;
        return;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u, p &lt;&lt; 1, l, r);
    if(r &gt; mid) modify(u, p &lt;&lt; 1 | 1, l, r);
    pushup(u, p);
&#125;
inline int query(int u, int p, int l, int r)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        return tr[u][p].sum;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    int ans = 0;
    if(l &lt;= mid) ans += query(u, p &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query(u, p &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; 20; i++)&#123;
        pre[i] = (1 &lt;&lt; i);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
    &#125;
    for(int i = 0; i &lt; 20; i++)&#123;
        build(i, 1, 1, n);
    &#125;
    cin &gt;&gt; m;
    while(m--)&#123;
        int op, l, r;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op == 1)&#123;
            LL ans = 0;
            for(int i = 0; i &lt; 20; i++)&#123;
                ans += 1ll * pre[i] * query(i, 1, l, r);
            &#125;
            cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
        &#125;else&#123;
            int x;
            cin &gt;&gt; x;
            for(int i = 0; i &lt; 20; i++)&#123;
                if(x &amp; pre[i])&#123;
                    modify(i, 1, l, r);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF438D-The-Child-and-Sequence"><a href="#CF438D-The-Child-and-Sequence" class="headerlink" title="CF438D | The Child and Sequence"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y0MzhE">CF438D | The Child and Sequence</span></h2><ul><li>题意<ul><li>给定序列，需要完成以下三种操作：<ol><li>查询区间和。</li><li>区间取模。</li><li>单点修改。</li></ol></li></ul></li><li>分析<ul><li>与给区间开根号的操作类似，当给区间开根号的时候，一个数只要变成 1 就不用再进行操作了，最多只需要开7、8次根号就不变了。</li><li>而当变成区间取模的时候，因为 $x ; mod ; p &lt; \frac{x}{2} ; (p &lt; x)$ ，所以取模最多也是 $log ; x$ 次，我们不妨记录区间最大值，如果最大值小于 $p$ 直接返回。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e5 + 10;
struct Node&#123;
    int l, r;
    LL sum, maxv;
&#125;tr[N &lt;&lt; 2];
LL w[N];
void pushup(int u)&#123;
    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    tr[u].maxv = max(tr[u &lt;&lt; 1].maxv, tr[u &lt;&lt; 1 | 1].maxv);
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r, 0, 0&#125;;
    if(l == r)&#123;
        tr[u].sum = tr[u].maxv = w[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
void modify_mod(int u, int l, int r, LL x)&#123;
    if(tr[u].maxv &lt; x) return;
    if(tr[u].l == tr[u].r)&#123;
        tr[u].sum %= x;
        tr[u].maxv %= x;
        return;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if(l &lt;= mid) modify_mod(u &lt;&lt; 1, l, r, x);
    if(r &gt; mid) modify_mod(u &lt;&lt; 1 | 1, l, r, x);
    pushup(u);
&#125;
void modify(int u, int l, int r, LL x)&#123;
    if(tr[u].l == tr[u].r)&#123;
        tr[u].sum = tr[u].maxv = x;
        return;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, x);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x);
    pushup(u);
&#125;
LL query(int u, int l, int r)&#123;
    if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    LL ans = 0;
    if(l &lt;= mid) ans += query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query(u &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
    &#125;
    build(1, 1, n);
    while(m--)&#123;
        int op;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; query(1, l, r) &lt;&lt; &#39;\n&#39;;
        &#125;else if(op == 2)&#123;
            int l, r, x;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
            modify_mod(1, l, r, x);
        &#125;else&#123;
            int k, x;
            cin &gt;&gt; k &gt;&gt; x;
            modify(1, k, k, x);
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF558E-A-Simple-Task"><a href="#CF558E-A-Simple-Task" class="headerlink" title="CF558E | A Simple Task"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y1NThF">CF558E | A Simple Task</span></h2><ul><li>题意<ul><li>对区间 $[l, r]$ 的字符串进行排序，1 为升序，0 为降序。</li></ul></li><li>分析<ul><li>经典操作，开 26 棵线段树，分别维护区间内每个字母的个数，开一个区间覆盖标记。</li><li>代码使用结构体封装的线段树。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
string s;
int n, m;

struct SegTree&#123;
    char letter;
    struct Node&#123;
        int l, r;
        int cov, sum;
    &#125;tr[N &lt;&lt; 2];

    void pushup(Node&amp; u, Node&amp; l, Node&amp; r)&#123;
        u.sum = l.sum + r.sum;
    &#125;
    void pushup(int u)&#123;
        pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);
    &#125;
    void build(int u, int l, int r)&#123;
        tr[u] = &#123;l, r, -1, s[l] == letter&#125;;
        if(l == r) return;
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid);
        build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
    void pushdown(int u)&#123;
        auto &amp;rt = tr[u], &amp;l = tr[u &lt;&lt; 1], &amp;r = tr[u &lt;&lt; 1 | 1];
        if(~rt.cov)&#123;
            l.cov = r.cov = rt.cov;
            l.sum = (l.r - l.l + 1) * rt.cov;
            r.sum = (r.r - r.l + 1) * rt.cov;
            rt.cov = -1;
        &#125;
    &#125;
    void modify(int u, int l, int r, int v)&#123;
        if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
            tr[u].cov = v;
            tr[u].sum = (tr[u].r - tr[u].l + 1) * v;
            return;
        &#125;
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
        pushup(u);
    &#125;
    int query(int u, int l, int r)&#123;
        if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        int ans = 0;
        if(l &lt;= mid) ans += query(u &lt;&lt; 1, l, r);
        if(r &gt; mid) ans += query(u &lt;&lt; 1 | 1, l, r);
        return ans;
    &#125;
&#125;tr[26];

void build(int l, int r)&#123;
    for(int i = 0; i &lt; 26; i++)&#123;
        tr[i].letter = &#39;a&#39; + i;
        tr[i].build(1, l, r);
    &#125;
&#125;

void sort(int l, int r, int op)&#123;
    vector&lt;pair&lt;char, int&gt;&gt; letters;
    for(int i = 0; i &lt; 26; i++)&#123;
        int cnt = tr[i].query(1, l, r);
        letters.push_back(&#123;i, cnt&#125;);
        tr[i].modify(1, l, r, 0);
    &#125;
    if(op == 0) reverse(letters.begin(), letters.end());
    int cur = l;
    for(auto range : letters)&#123;
        if(range.second == 0) continue;
        tr[range.first].modify(1, cur, cur + range.second - 1, 1);
        cur += range.second;
    &#125;
&#125;

int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    cin &gt;&gt; s;
    s = &quot; &quot; + s;
    build(1, n);
    while(m--)&#123;
        int l, r, op;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;
        sort(l, r, op);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt; 26; j++)&#123;
            if(tr[j].query(1, i, i))&#123;
                cout &lt;&lt; (char)(&#39;a&#39; + j);
                break;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre><h2 id="CF620E-New-Year-Tree"><a href="#CF620E-New-Year-Tree" class="headerlink" title="CF620E | New Year Tree"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y2MjBF">CF620E | New Year Tree</span></h2><ul><li>题意<ul><li>给出一棵 $n$ 个节点的树，根节点为 $1$。每个节点上有一种颜色 $c_i$。$m$ 次操作。操作有两种：<ol><li><code>1 u c</code>：将以 $u$ 为根的子树上的所有节点的颜色改为 $c$。</li><li><code>2 u</code>：询问以 $u$ 为根的子树上的所有节点的颜色数量。</li></ol></li></ul></li><li>分析<ul><li>因为空间有限，选择只开一颗线段树，运用状态压缩，以一个数表示区间内颜色。</li><li>又由于需要在树上操作子树，所以我们需要 dfs 一遍获得每个节点的 dfn，并且记录以 $x$ 为根的子树的 dfn 区间。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 4e5 + 10;
int h[N], e[N &lt;&lt; 1], ne[N &lt;&lt; 1], idx;
int in[N], out[N], dfn[N], cnt;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u, int fa)&#123;
    in[u] = ++cnt;
    dfn[cnt] = u;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa) continue;
        dfs(j, u);
    &#125;
    out[u] = cnt;
&#125;

struct Node&#123;
    int l, r;
    LL sum, add;
&#125;tr[N &lt;&lt; 2];
int c[N];
void pushup(int u)&#123;
    tr[u].sum = tr[u &lt;&lt; 1].sum | tr[u &lt;&lt; 1 | 1].sum;
&#125;
void pushdown(int u)&#123;
    if(tr[u].add)&#123;
        tr[u &lt;&lt; 1].add = tr[u].add;
        tr[u &lt;&lt; 1 | 1].add = tr[u].add;
        tr[u &lt;&lt; 1].sum = tr[u].add;
        tr[u &lt;&lt; 1 | 1].sum = tr[u].add;
        tr[u].add = 0;
    &#125;
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r)&#123;
        tr[u].sum = 1ll &lt;&lt; c[dfn[l]];
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
void modify(int u, int l, int r, LL v)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        tr[u].sum = v;
        tr[u].add = v;
        return;
    &#125;
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
    pushup(u);
&#125;
LL query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        return tr[u].sum;
    &#125;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    pushdown(u);
    LL res = 0;
    if(l &lt;= mid) res |= query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) res |= query(u &lt;&lt; 1 | 1, l, r);
    return res;
&#125;
LL lowbit(LL x)&#123;
    return x &amp; -x;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i];
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b), add(b, a);
    &#125;
    dfs(1, 0);
    build(1, 1, n);
    while(m--)&#123;
        int op;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            modify(1, in[a], out[a], 1ll &lt;&lt; b);
        &#125;else&#123;
            int a;
            cin &gt;&gt; a;
            LL res = query(1, in[a], out[a]);
            int ans = 0;
            while(res)&#123;
                res -= lowbit(res);
                ans++;
            &#125;
            cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="P2184-贪婪大陆"><a href="#P2184-贪婪大陆" class="headerlink" title="P2184 | 贪婪大陆"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxODQ=">P2184 | 贪婪大陆</span></h2><ul><li>题意<ul><li>有一个长为 $n$ 的战壕，操作一可以在 $[l, r]$ 区间内埋上独特的一种地雷，操作二询问 $[l, r]$ 区间内地雷的种类数。</li></ul></li><li>分析<ul><li>假如维护当前区间最大值的话，修改区间的时候需要修改每一个叶节点，时间复杂度过大。</li><li>考虑运用差分思想，区间维护两个值：开始埋雷的数量，结束埋雷的数量，在 $[l, r]$ 区间内埋雷可以看作是在 $l$ 点处埋雷，在 $r$ 点处结束埋雷。</li><li>查询的时候只需要分别求一下 $[1, l - 1]$ 开始埋雷的个数减掉 $[1, r]$ 结束埋雷的个数即为 $[l, r]$ 内地雷的种类数。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
struct Seg&#123;
    int l, r;
    int st, ed;
&#125;tr[N &lt;&lt; 2];
void pushup(int u)&#123;
    tr[u].st = tr[u &lt;&lt; 1].st + tr[u &lt;&lt; 1 | 1].st;
    tr[u].ed = tr[u &lt;&lt; 1].ed + tr[u &lt;&lt; 1 | 1].ed;
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
&#125;
void modify(int u, int l, int r, int tag)&#123;
    if(tr[u].l == tr[u].r)&#123;
        if(tag == 1) tr[u].st++;
        else tr[u].ed++;
        return ;
    &#125;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, tag);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, tag);
    pushup(u);
&#125;
pair&lt;int, int&gt; query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; r &gt;= tr[u].r)&#123;
        return &#123;tr[u].st, tr[u].ed&#125;;
    &#125;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    int ans1 = 0, ans2 = 0;
    if(l &lt;= mid)&#123;
        auto t = query(u &lt;&lt; 1, l, r);
        ans1 += t.first;
        ans2 += t.second;
    &#125;
    if(r &gt; mid)&#123;
        auto t = query(u &lt;&lt; 1 | 1, l, r);
        ans1 += t.first;
        ans2 += t.second;
    &#125;
    return &#123;ans1, ans2&#125;;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    build(1, 1, n);
    while(m--)&#123;
        int q, l, r;
        cin &gt;&gt; q &gt;&gt; l &gt;&gt; r;
        if(q == 1) modify(1, l, l, 1), modify(1, r, r, -1);
        else&#123;
            auto [st, _] = query(1, 1, r);
            auto [__, ed] = query(1, 1, l - 1);
            cout &lt;&lt; st - ed &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF992E-Nastya-and-King-Shamans"><a href="#CF992E-Nastya-and-King-Shamans" class="headerlink" title="CF992E | Nastya and King-Shamans"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y5OTJF">CF992E | Nastya and King-Shamans</span></h2><ul><li>题意<ul><li>给定一个序列 $a_i$ ，记其前缀和序列为 $s_i$ ，有 $q$ 个询问，每次单点修改，询问是否存在一个 $i$ 满足 $a_i&#x3D;s_{i-1}$ ，有多解输出任意一个，无解输出 <code>-1</code>。</li></ul></li><li>分析<ul><li>首先想最原始的暴力。直接维护原数组 $a$ 和前缀数组 $s$，每次修改的时候就暴力在 $a$ 的一个单点和 $s$ 的一个区间上改值。查询的时候暴力枚举所有的 $i$，判断 $a_i-s_{i-1}$ 是否为 $0$。</li><li>先考虑这样一件事：对于所有的 $i$，满足条件的一定不超过 $log s_n$ 个。为什么呢？若 $i$ 满足条件，即 $a_i-s_{i-1}\ge0$，可得 $s_i \ge 2s_{i-1}$。也就是说，每有一个 $i$ 满足条件，$s$ 值就会翻倍，那么总共的满足条件的 $i$ 的个数不超过 $log s_n$。</li><li>考虑优化。由于涉及到大量区间的操作，我们不妨建立线段树维护 $a_i-s_{i-1}$的区间 $max$。为什么这么做？因为查询的时候我们只需要递归区间 $max$ 大于等于 0 的区间，结合上面说的性质，我们一共找的的叶子总数不会超过 $log s_n$，复杂度正确。</li><li>再想如何进行修改操作。我们假设把 $a_x$ 增加了 $y$（注意题目说的是修改，这里说的是增加），首先 $x$ 位置单点加 $y$ 不必多说。再考虑哪些 $s$ 值受到了影响：应该是区间 $[x+1,n]$。又因为 $a_i-s_{i-1}$ 的 $s$ 前面带个减号，我们对区间 $[x+1,n]$ 进行区间加 $-y$。（注意 $x&#x3D;n$ 造成越界）。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
struct Node &#123;
    int l, r;
    LL mx, add;
&#125;tr[N &lt;&lt; 2];
int n, q;
LL a[N], s[N];

void pushup(int u) &#123;
    tr[u].mx = max(tr[u &lt;&lt; 1].mx, tr[u &lt;&lt; 1 | 1].mx);
&#125;

void build(int u, int l, int r) &#123;
    tr[u].l = l, tr[u].r = r;
    if (l == r) &#123;
        tr[u].mx = a[l] - s[l - 1];
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;

void pushdown(int u) &#123;
    if (tr[u].add) &#123;
        tr[u &lt;&lt; 1].add += tr[u].add, tr[u &lt;&lt; 1].mx += tr[u].add;
        tr[u &lt;&lt; 1 | 1].add += tr[u].add, tr[u &lt;&lt; 1 | 1].mx += tr[u].add;
        tr[u].add = 0;
    &#125;
&#125;

void modify(int u, int l, int r, int v) &#123;
    if (l &gt; r) return;
    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;
        tr[u].mx += v, tr[u].add += v;
        return;
    &#125;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    pushdown(u);
    if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
    if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
    pushup(u);
&#125;

void query(int u, int&amp; res) &#123;
    if (res != -1) return;
    if (tr[u].mx &lt; 0) return;
    if (tr[u].l == tr[u].r) &#123;
        if (tr[u].mx == 0) res = tr[u].l;
        return;
    &#125;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    pushdown(u);
    query(u &lt;&lt; 1, res);
    query(u &lt;&lt; 1 | 1, res);
&#125;

int main() &#123;
    cin.tie(0), cout.tie(0)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], s[i] = a[i] + s[i - 1];
    build(1, 1, n);
    while (q--) &#123;
        LL x, y;
        cin &gt;&gt; x &gt;&gt; y;
        modify(1, x, x, y - a[x]);
        modify(1, x + 1, n, a[x] - y);
        a[x] = y;
        int res = -1;
        query(1, res);
        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre><hr><h1 id="跨节点维护线段树"><a href="#跨节点维护线段树" class="headerlink" title="跨节点维护线段树"></a>跨节点维护线段树</h1><ul><li>有些线段树需要维护每个区间的前缀、后缀、区间内的一些值，笔者暂且称之为需要跨节点维护的线段树。</li></ul><h2 id="P2894-USACO08FEB-Hotel-G"><a href="#P2894-USACO08FEB-Hotel-G" class="headerlink" title="P2894 | [USACO08FEB]Hotel G"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI4OTQ=">P2894 | [USACO08FEB]Hotel G</span></h2><ul><li>题意<ul><li>给定 $n$ 个房间，以及 $m$ 个操作，房间初始均为空房间。</li><li>共有两种操作：<ol><li>查询所有房间中是否有长度为 $x$ 的连续空房，输出这连续 $x$ 个房间中最左端的房间号，尽量让这个房间号最小，若找不到，则输出 <code>0</code> ，若找得到，则这 $x$ 个房间都住人。</li><li>让区间 $x \sim x + d - 1$ 内的人都退房。</li></ol></li></ul></li><li>分析<ul><li>维护区间内最大连续空房的数量，同时维护每个区间最大前缀连续空房数量以及区间最大后缀连续空房数量，因为会有跨区间的连续空房出现。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 50010;
struct Seg&#123;
    int l, r;
    int tmax, lmax, rmax;
    int tag;
&#125;tr[N &lt;&lt; 2];
void pushup(int u)&#123;
    if(tr[u &lt;&lt; 1].tmax == tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1)&#123;
        tr[u].lmax = tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1 + tr[u &lt;&lt; 1 | 1].lmax;
    &#125;else&#123;
        tr[u].lmax = tr[u &lt;&lt; 1].lmax;
    &#125;
    if(tr[u &lt;&lt; 1 | 1].tmax == tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1)&#123;
        tr[u].rmax = tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1 + tr[u &lt;&lt; 1].rmax;
    &#125;else&#123;
        tr[u].rmax = tr[u &lt;&lt; 1 | 1].rmax;
    &#125;
    tr[u].tmax = max(&#123;tr[u &lt;&lt; 1].tmax, tr[u &lt;&lt; 1 | 1].tmax, tr[u &lt;&lt; 1].rmax + tr[u &lt;&lt; 1 | 1].lmax&#125;);
&#125;
void pushdown(int u)&#123;
    if(tr[u].tag == 1)&#123;
        tr[u &lt;&lt; 1].tag = tr[u &lt;&lt; 1 | 1].tag = 1;
        tr[u &lt;&lt; 1].tmax = tr[u &lt;&lt; 1].lmax = tr[u &lt;&lt; 1].rmax = 0;
        tr[u &lt;&lt; 1 | 1].tmax = tr[u &lt;&lt; 1 | 1].lmax = tr[u &lt;&lt; 1 | 1].rmax = 0;
        tr[u].tag = 0;
    &#125;else if(tr[u].tag == 2)&#123;
        tr[u &lt;&lt; 1].tag = tr[u &lt;&lt; 1 | 1].tag = 2;
        tr[u &lt;&lt; 1].tmax = tr[u &lt;&lt; 1].lmax = tr[u &lt;&lt; 1].rmax = tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1;
        tr[u &lt;&lt; 1 | 1].tmax = tr[u &lt;&lt; 1 | 1].lmax = tr[u &lt;&lt; 1 | 1].rmax = tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1;
        tr[u].tag = 0;
    &#125;
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r)&#123;
        tr[u].tmax = tr[u].lmax = tr[u].rmax = 1;
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
// 1 开房 2 退房
void modify(int u, int l, int r, int tag)&#123;
    if(tr[u].l &gt;= l &amp;&amp; r &gt;= tr[u].r)&#123;
        if(tag == 1) tr[u].tmax = tr[u].lmax = tr[u].rmax = 0;
        else tr[u].tmax = tr[u].lmax = tr[u].rmax = tr[u].r - tr[u].l + 1;
        tr[u].tag = tag;
        return;
    &#125;
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, tag);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, tag);
    pushup(u);
&#125;
int query(int u, int l, int r, int len)&#123;
    if(tr[u].l == tr[u].r) return tr[u].l;
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if(tr[u &lt;&lt; 1].tmax &gt;= len) return query(u &lt;&lt; 1, l, r, len);
    if(tr[u &lt;&lt; 1].rmax + tr[u &lt;&lt; 1 | 1].lmax &gt;= len) return tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].rmax + 1;
    else return query(u &lt;&lt; 1 | 1, l, r, len);
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    build(1, 1, n);
    for(int i = 1; i &lt;= m; i++)&#123;
        int op;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            int x;
            cin &gt;&gt; x;
            if(tr[1].tmax &gt;= x)&#123;
                int l = query(1, 1, n, x);
                cout &lt;&lt; l &lt;&lt; &quot;\n&quot;;
                modify(1, l, l + x - 1, 1);
            &#125;else&#123;
                cout &lt;&lt; &quot;0\n&quot;;
            &#125;
        &#125;else&#123;
            int x, y;
            cin &gt;&gt; x &gt;&gt; y;
            modify(1, x, x + y - 1, 2);
        &#125;
    &#125;
&#125;
</code></pre><h2 id="P6492-COCI2010-2011-6-STEP"><a href="#P6492-COCI2010-2011-6-STEP" class="headerlink" title="P6492 | [COCI2010-2011#6] STEP"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDY0OTI=">P6492 | [COCI2010-2011#6] STEP</span></h2><ul><li>题意<ul><li>给定一个长度为 $n$ 的字符序列 $a$，初始时序列中全部都是字符 <code>L</code>。</li><li>有 $q$ 次修改，每次给定一个 $x$，若 $a_x$ 为 <code>L</code>，则将 $a_x$  修改成 <code>R</code>，否则将 $a_x$ 修改成 <code>L</code>。</li><li>对于一个只含字符 <code>L</code>，<code>R</code> 的字符串 $s$，若其中不存在连续的 <code>L</code> 和 <code>R</code>，则称 $s$ 满足要求。</li><li>每次修改后，请输出当前序列 $a$ 中最长的满足要求的连续子串的长度。</li></ul></li><li>分析<ul><li>维护区间内最大满足要求的字串长度，最大前缀长度以及最大后缀长度。</li><li><code>pushup</code> 操作与上题有些不同，需要判断可以合并的条件，因此需要单开一个数组维护当前节点的值，我们将 <code>L</code> 视作 <code>0</code> ，<code>R</code> 视作 <code>1</code> 。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
struct Seg&#123;
    int l, r;
    int val;
    int tmax, lmax, rmax;
&#125;tr[N &lt;&lt; 2];
int w[N];
void pushup(int u)&#123;
    if(w[tr[u &lt;&lt; 1].r] ^ w[tr[u &lt;&lt; 1 | 1].l])&#123;
        if(tr[u &lt;&lt; 1].tmax == tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1)&#123;
            tr[u].lmax = tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1 + tr[u &lt;&lt; 1 | 1].lmax;
        &#125;else&#123;
            tr[u].lmax = tr[u &lt;&lt; 1].lmax;
        &#125;
        if(tr[u &lt;&lt; 1 | 1].tmax == tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1)&#123;
            tr[u].rmax = tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1 + tr[u &lt;&lt; 1].rmax;
        &#125;else&#123;
            tr[u].rmax = tr[u &lt;&lt; 1 | 1].rmax;
        &#125;
        tr[u].tmax = max(&#123;tr[u &lt;&lt; 1].tmax, tr[u &lt;&lt; 1 | 1].tmax, tr[u &lt;&lt; 1].rmax + tr[u &lt;&lt; 1 | 1].lmax&#125;);
    &#125;else&#123;
        tr[u].lmax = tr[u &lt;&lt; 1].lmax;
        tr[u].rmax = tr[u &lt;&lt; 1 | 1].rmax;
        tr[u].tmax = max(tr[u &lt;&lt; 1].tmax, tr[u &lt;&lt; 1 | 1].tmax);
    &#125;
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r)&#123;
        tr[u].val = tr[u].tmax = tr[u].lmax = tr[u].rmax = 1;
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
void modify(int u, int l, int r)&#123;
    if(tr[u].l == tr[u].r) return;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r);
    pushup(u);
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    build(1, 1, n);
    while(m--)&#123;
        int x;
        cin &gt;&gt; x;
        w[x] ^= 1;
        modify(1, x, x);
        cout &lt;&lt; tr[1].tmax &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;
</code></pre><hr><h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><ul><li>通常来说，线段树占用空间是总区间长 $n$ 的常数倍，空间复杂度是 $O(n)$。然而，有时候 $n$ 很巨大，而我们又不需要使用所有的节点，这时便可以动态开点——不再一次性建好树，而是一边修改、查询一边建立。设总查询次数为 $m$，则这样的总空间复杂度为 $O(m;log;n)$。</li><li>比起普通线段树，动态开点线段树有一个优势，它能够处理零或负数位置。此时，求 $mid$ 时不能用 $(cl + cr) &#x2F; 2$，而要用 $(cl + cr - 1) &#x2F; 2$。</li><li>通常用在没有提供初始数据的场合（例如初始全0），这时更能显示出优势。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
#define val(x) tr[x].val
#define mark(x) tr[x].mark
// N 一般能开多大开多大，例如内存限制 128M 时可以开到八百万左右
const int N = 8e6;
int L = 1, R = 1e5, cnt = 1;
struct Node&#123;
    int ls, rs;
    LL val, mark;
&#125;tr[N];
void push_down(int p, int len)&#123;
    if(len &lt;= 1) return;
    if(!ls(p)) ls(p) = ++cnt;
    if(!rs(p)) rs(p) = ++cnt;
    val(ls(p)) += mark(p) * (len / 2);
    mark(ls(p)) += mark(p);
    val(rs(p)) += mark(p) * (len - len / 2);
    mark(rs(p)) += mark(p);
    mark(p) = 0;
&#125;
LL query(int u, int l, int r, int cl = L, int cr = R)&#123;
    if(cl &gt;= l &amp;&amp; cr &lt;= r) return val(u);
    push_down(u, cr - cl + 1);
    LL mid = (cl + cr - 1) / 2, ans = 0;
    if(l &lt;= mid) ans += query(ls(u), l, r, cl, mid);
    if(r &gt; mid) ans += query(rs(u), l, r, mid + 1, cr);
    return ans;
&#125;
void update(int l, int r, int d, int u = 1, int cl = L, int cr = R)&#123;
    if(cl &gt;= l &amp;&amp; cr &lt;= r)&#123;
        val(u) += d * (cr - cl + 1);
        mark(u) += d;
        return;
    &#125;
    push_down(u, cr - cl + 1);
    LL mid = (cl + cr - 1) / 2;
    if(l &lt;= mid) update(l, r, d, ls(u), cl, mid);
    if(r &gt; mid) update(l, r, d, rs(u), mid + 1, cr);
    val(u) = val(ls(u)) + val(rs(u));
&#125;
</code></pre><h2 id="CF431E-Chemistry-Experiment"><a href="#CF431E-Chemistry-Experiment" class="headerlink" title="CF431E | Chemistry Experiment"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y0MzFF">CF431E | Chemistry Experiment</span></h2><ul><li>题目中第二种操作需要将 $v$ 体积的水任意分配到 $n$ 支试管里，最小化有水的试管中的最大体积，输出这个最小值，该操作不会造成影响。</li><li>最小化最大值，考虑二分答案，因为只能往小于等于 $mid$ 的试管里面灌，也就是说我们要统计出所有高度小于等于 $mid$ 的试管的数量 $num$，同时也要统计这些试管里面水银的体积 $sum$。如果 $num \times mid - sum \ge v$ 这个 $mid$ 就是可行的（自行画图体会）。</li><li>又由于没有区间限制，而且 mid 值不确定，果断上权值线段树 + 动态开点。</li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int INF = 1e9;
const int N = 1e5 + 10;
const double eps = 1e-5;
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
#define val(x) tr[x].val
#define sum(x) tr[x].sum
#define sz(x) tr[x].sz
struct Node&#123;
    int ls, rs;
    LL sz, sum;
&#125;tr[N &lt;&lt; 6];
int idx, root;
int w[N];
int n, q, m = 1e9 + 10;
void pushup(Node&amp; u, Node&amp; l, Node&amp; r)&#123;
    u.sz = l.sz + r.sz;
    u.sum = l.sum + r.sum;
&#125;
void modify(int&amp; u, int l, int r, int x, int v)&#123;
    if(!u) u = ++idx;
    tr[u].sz += v, tr[u].sum += x * v;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    if(x &lt;= mid) modify(ls(u), l, mid, x, v);
    else modify(rs(u), mid + 1, r, x, v);
&#125;
Node query(int u, int l, int r, int ql, int qr)&#123;
    if(!u) return &#123;0, 0, 0, 0&#125;;
    if(ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u];
    int mid = (l + r) &gt;&gt; 1;
    if(qr &lt;= mid) return query(ls(u), l, mid, ql, qr);
    if(ql &gt; mid) return query(rs(u), mid + 1, r, ql, qr);
    Node res, left = query(ls(u), l, mid, ql, qr), right = query(rs(u), mid + 1, r, ql, qr);
    pushup(res, left, right);
    return res;
&#125;

bool check(double mid, LL v)&#123;
    LL up = floor(mid);
    if(up &gt; m) up = m;
    Node ans = query(root, 0, m, 0, up);
    double remain = 1.0 * ans.sz * mid - ans.sum - v;
    return remain &gt;= eps;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cout &lt;&lt; fixed &lt;&lt; setprecision(5);
    cin &gt;&gt; n &gt;&gt; q;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        modify(root, 0, m, w[i], 1);
    &#125;
    while(q--)&#123;
        int op;
        LL a, b;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            cin &gt;&gt; a &gt;&gt; b;
            modify(root, 0, m, w[a], -1);
            w[a] = b;
            modify(root, 0, m, w[a], 1);
        &#125;else&#123;
            cin &gt;&gt; a;
            double l = 0, r = 1e15;
            while(r - l &gt; eps)&#123;
                double mid = (l + r) / 2;
                if(check(mid, a)) r = mid;
                else l = mid;
            &#125;
            cout &lt;&lt; l &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF911G-Mass-Change-Queries"><a href="#CF911G-Mass-Change-Queries" class="headerlink" title="CF911G | Mass Change Queries"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y5MTFH">CF911G | Mass Change Queries</span></h2><ul><li>题意<ul><li>给出一个数列，有 $q$ 个操作,每种操作是把区间 $[l,r]$ 中等于 $x$ 的数改成 $y$ 。输出 $q$ 步操作完的数列。</li></ul></li><li>分析<ul><li>对一个序列进行操作，最常见的方法就是用线段树了。虽然序列很长，对整个序列用线段树维护比较困难，但是不同的权值最多只有 100 种。因此，如果我们对不同的权值开线段树，最多也不过 100 棵线段树。</li><li>现在考虑对每个权值建一棵线段树。我们可以用是否存在儿子节点来表示某区间内是否有该权值。具体来说，若在权值 $x$ 的线段树内，对于一个区间 $[l, r]$ 所对应的节点，如果这棵树内有该节点，说明该区间内有权值 $x$ ；反之若该节点不存在（为空），说明该区间内无权值 $x$ 。这样，我们可以往下递推到区间 $[l, r]$ ，此时区间变成一个点，如果该节点存在，就说明序列中 $l$ 处权值为 $x$ 。</li><li>当我们需要进行一次操作时，就相当于把 $x$ 的线段树中区间 $[l,r]$ 中的节点分裂出来，再合并到 $y$ 的线段树中，由于序列中同一位置在某一时刻有且仅有一个权值，不会产生 $y$ 中也有对应节点的冲突。</li><li>最后，我们对100棵线段树都扫一遍，就可以得到最终序列了。</li><li>包含线段树分裂以及线段树合并。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N * 150];
int w[N], root[N], ans[N];
int idx;

void pushup(int u)&#123;
    tr[u].cnt = tr[tr[u].l].cnt + tr[tr[u].r].cnt;
&#125;
void modify(int&amp; p, int l, int r, int x)&#123;
    if(!p) p = ++idx;
    tr[p].cnt++;
    if(l == r) return;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) modify(tr[p].l, l, mid, x);
    else modify(tr[p].r, mid + 1, r, x);
&#125;
int merge(int p, int&amp; q, int l, int r)&#123;
    if(!p || !q) return p | q;
    if(l == r)&#123;
        tr[p].cnt += tr[q].cnt;
        q = 0;
        return p;
    &#125;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = merge(tr[p].l, tr[q].l, l, mid);
    tr[p].r = merge(tr[p].r, tr[q].r, mid + 1, r);
    pushup(p); pushup(q);
    return p;
&#125;
int split(int&amp; p, int l, int r, int ql, int qr)&#123;
    int q = ++idx;
    if(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;
        tr[q] = tr[p];
        p = 0;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(ql &lt;= mid) tr[q].l = split(tr[p].l, l, mid, ql, qr);
    if(qr &gt; mid) tr[q].r = split(tr[p].r, mid + 1, r, ql, qr);
    pushup(p); pushup(q);
    return q;
&#125;
void dfs(int num, int p, int l, int r)&#123;
    if(!p) return;
    if(!tr[p].cnt) return;
    if(l == r)&#123;
        ans[l] = num;
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    dfs(num, tr[p].l, l, mid);
    dfs(num, tr[p].r, mid + 1, r);
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        modify(root[w[i]], 1, n, i);
    &#125;
    cin &gt;&gt; m;
    int rt;
    while(m--)&#123;
        int l, r, x, y;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y;
        rt = split(root[x], 1, n, l, r);
        root[y] = merge(root[y], rt, 1, n);
    &#125;
    for(int i = 1; i &lt;= 100; i++)&#123;
        dfs(i, root[i], 1, n);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
    &#125;
&#125;
</code></pre><hr><h1 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h1><ul><li>例题：区间 k 个数最大和</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010, M = 20010;
int n, m, k, x;
int a[N];
vector&lt;int&gt; nums;
struct Node&#123;
    int l, r, cnt;
    LL sum, val;        // cnt 记录出现次数，sum 记录和，val 记录值
&#125;tr[N * 40];
int root[N], idx;

int find(int x)&#123;
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
&#125;
int build(int l, int r)&#123;
    int p = ++idx;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
&#125;
int insert(int p, int l, int r, int x, int val)&#123;
    int q = ++idx;
    tr[q] = tr[p];
    tr[q].cnt++, tr[q].sum += val;
    if(l == r)&#123;
        tr[q].val = val;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x, val);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x, val);
    return q;
&#125;
// 查询前 k 大值，因为节点存的是值，所以找大的，先从右边找。
LL query(int q, int p, int l, int r, int k)&#123;
    if(l == r) return tr[q].val * k;    // 因为一个值可能出现多次，那么计算答案的时候要把他们都算上
    int cnt = tr[tr[q].r].cnt - tr[tr[p].r].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[q].r, tr[p].r, mid + 1, r, k);
    else return query(tr[q].l, tr[p].l, l, mid, k - cnt) + tr[tr[q].r].sum - tr[tr[p].r].sum;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;
    for(int i = 1; i &lt; nums.size(); i++)&#123;
        nums[i] += nums[i - 1];
    &#125;
/*     sort(nums.begin(), nums.end());
    nums.resize(unique(nums.begin(), nums.end()) - nums.begin()); */
    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i++)&#123;
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]), a[i]);
    &#125;
    while(m--)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        if(nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &gt;= x)&#123;
            cout &lt;&lt; &quot;Y\n&quot;;
        &#125;else&#123;
            cout &lt;&lt; &quot;N\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU3Lw==">第k小数</span></h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUxNDU2Lw==">题解</span></li><li>可持久化线段树<ul><li>难以进行区间修改操作</li></ul></li><li>离散化</li><li>在数值上建立线段树，维护每个数值区间中一共有多少个数</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, M = 10010;
int n, m;
int a[N];
vector&lt;int&gt; nums;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N * 4 + N * 17];
int root[N], idx;

int find(int x)&#123;
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
&#125;
int build(int l, int r)&#123;
    int p = ++idx;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
&#125;
int insert(int p, int l, int r, int x)&#123;
    int q = ++idx;
    tr[q] = tr[p];
    if(l == r)&#123;
        tr[q].cnt++;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
&#125;
int query(int q, int p, int l, int r, int k)&#123;
    if(l == r) return r;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k);
    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;
    sort(nums.begin(), nums.end());
    nums.resize(unique(nums.begin(), nums.end()) - nums.begin());
    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i++)&#123;
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));
    &#125;
    while(m--)&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl;
    &#125;
&#125;
</code></pre><hr><h1 id="动态开点可持久化线段树"><a href="#动态开点可持久化线段树" class="headerlink" title="动态开点可持久化线段树"></a>动态开点可持久化线段树</h1><ul><li>例题为 区间第 k 小</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, INF = 1e9;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N &lt;&lt; 5];
int n, m, idx , root[N], a[N];

void insert(int &amp;u, int v, int l, int r, int x)&#123;
    u = ++ idx;
    tr[u] = tr[v];
    tr[u].cnt ++ ;
    if(l == r) return ;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) insert(tr[u].l, tr[v].l, l, mid, x);
    else insert(tr[u].r, tr[v].r, mid + 1, r, x);
&#125;

int query(int p, int q, int l, int r, int k)&#123;
    if(l == r) return l;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[p].l, tr[q].l, l, mid, k);
    if(k &gt; cnt) return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
&#125;

int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1 ; i &lt;= n ; i ++ )&#123;
        cin &gt;&gt; a[i];
        insert(root[i], root[i - 1], -INF, INF, a[i]);
    &#125;
    for(int i = 1 ; i &lt;= m ; i ++ )&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; query(root[l - 1], root[r], -INF, INF, k) &lt;&lt; endl;
    &#125;
    
    return 0;
&#125;
</code></pre><h2 id="CF840D-Destiny"><a href="#CF840D-Destiny" class="headerlink" title="CF840D | Destiny"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y4NDBE">CF840D | Destiny</span></h2><ul><li>题意<ul><li>给定 $n$ 个元素，$m$ 次询问。</li><li>每次给出三个参数 $l,r,k$，询问区间 $[l,r]$ 内是否存在出现次数严格大于 $\frac{r-l+1}{k}$ 的数。如果存在就输出最小的那个 $ans$，否则输出 -1.</li></ul></li><li>分析<ul><li>考虑求的是区间出现个数大于 $\frac{r-l+1}{k}$ 的最小值，因此可以将区间排序然后分成 $k$ 段，并依次查询，取最小值。</li><li>左边的权值一定比右边的权值小，如果左边的出现个数大于 $\lfloor \frac{r-l+1}{k} \rfloor$ 那么很显然这边是有可能的，暴力找下试试看，如果不行的话，向右找，如果可以的话，这样依次找，直到找到了，一定是最小值，如果变成最大值的话，就从右边开始取。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 3e5 + 10;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N &lt;&lt; 5];
int idx, root[N], w[N];
void insert(int&amp; u, int v, int l, int r, int x)&#123;
    u = ++idx;
    tr[u] = tr[v];
    tr[u].cnt++;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    if(x &lt;= mid) insert(tr[u].l, tr[v].l, l, mid, x);
    else insert(tr[u].r, tr[v].r, mid + 1, r, x);
&#125;
int query(int p, int q, int l, int r, int k)&#123;
    if(l == r) return l;
    int cnt1 = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int cnt2 = tr[tr[q].r].cnt - tr[tr[p].r].cnt;
    int mid = l + r &gt;&gt; 1, ans = -1;
    if(cnt1 &gt; k)&#123;
        ans = query(tr[p].l, tr[q].l, l, mid, k);
    &#125;
    if(~ans) return ans;
    if(cnt2 &gt; k)&#123;
        ans = query(tr[p].r, tr[q].r, mid + 1, r, k);
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        insert(root[i], root[i - 1], 1, n, w[i]);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        k = (r - l + 1) / k;
        cout &lt;&lt; query(root[l - 1], root[r], 1, n, k) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h2 id="CF1000F-One-Occurrence"><a href="#CF1000F-One-Occurrence" class="headerlink" title="CF1000F | One Occurrence"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YxMDAwRg==">CF1000F | One Occurrence</span></h2><ul><li>题意<ul><li>给定一个长度为 $n$ 序列，$m$ 个询问，每次询问给定一个区间 $[l,r]$，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出 <code>0</code>。</li></ul></li><li>分析<ul><li>对于每个数维护它的最近出现的位置和上一次出现的位置。只有当一个属最近出现的位置在所查询的区间内并且它上次出现的位置不在这个区间里，这个数就只会出现一次。</li><li>所以我们需要对每个数出现的位置维护一个区间最小值和最小值的数值，假如区间最小值小于查询的左端点，那么该区间内就有数只出现一次。</li><li>用可持久化线段树维护每个版本的最小值。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 5e5 + 10, INF = 0x3f3f3f3f;
int a[N], pre[N];
struct Seg&#123;
    int l, r;
    int val, pos;
&#125;tr[N * 50];
int idx, root[N];

void build(int&amp; p, int l, int r)&#123;
    tr[p = ++idx].val = INF;    // 表示没有出现过
    if(l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(tr[p].l, l, mid);
    build(tr[p].r, mid + 1, r);
&#125;
void pushup(Seg&amp; u, Seg&amp; l, Seg&amp; r)&#123;
    if(l.val &lt; r.val)&#123;
        u.val = l.val;
        u.pos = l.pos;
    &#125;else&#123;
        u.val = r.val;
        u.pos = r.pos;
    &#125;
&#125;
void modify(int p, int&amp; q, int l, int r, int x, int v)&#123;
    tr[q = ++idx] = tr[p];
    if(l == r)&#123;
        tr[q].val = v;
        tr[q].pos = x;
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) modify(tr[p].l, tr[q].l, l, mid, x, v);
    else modify(tr[p].r, tr[q].r, mid + 1, r, x, v);
    pushup(tr[q], tr[tr[q].l], tr[tr[q].r]);
&#125;
Seg query(int p, int l, int r, int ql, int qr)&#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) return tr[p];
    int mid = l + r &gt;&gt; 1;
    if(qr &lt;= mid) return query(tr[p].l, l, mid, ql, qr);
    if(ql &gt; mid) return query(tr[p].r, mid + 1, r, ql, qr);
    Seg ans, left = query(tr[p].l, l, mid, ql, qr), right = query(tr[p].r, mid + 1, r, ql, qr);
    pushup(ans, left, right);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n;
    build(root[0], 0, n);
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        modify(root[i - 1], root[i], 0, n, pre[a[i]], INF);
        modify(root[i], root[i], 0, n, i, pre[a[i]]);
        pre[a[i]] = i;
    &#125;
    cin &gt;&gt; m;
    while(m--)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        Seg ans = query(root[r], 0, n, l, r);
        cout &lt;&lt; (ans.val &lt; l ? a[ans.pos] : 0) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E9%A2%98%E9%9B%86/" rel="tag"><i class="ic i-tag"></i> 题集</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-11 08:37:28" itemprop="dateModified" datetime="2022-09-11T08:37:28+08:00">2022-09-11</time> </span><span id="post/线段树进阶.html" class="item leancloud_visitors" data-flag-title="线段树进阶" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html" title="线段树进阶">https://asterzc19.github.io/post/线段树进阶.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;44d29b2c5b4e40c8.jpg" title="网络流"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>网络流</h3></a></div><div class="item right"><a href="/post/%E8%AE%AD%E7%BB%83%E9%A2%98%E9%9B%86.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;07&#x2F;adf69ad6a75c5594.jpg" title="训练题集"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>训练题集</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">普通线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CF240F-TorCoder"><span class="toc-number">1.1.</span> <span class="toc-text">CF240F | TorCoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF242E-XOR-on-Segment"><span class="toc-number">1.2.</span> <span class="toc-text">CF242E | XOR on Segment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF438D-The-Child-and-Sequence"><span class="toc-number">1.3.</span> <span class="toc-text">CF438D | The Child and Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF558E-A-Simple-Task"><span class="toc-number">1.4.</span> <span class="toc-text">CF558E | A Simple Task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF620E-New-Year-Tree"><span class="toc-number">1.5.</span> <span class="toc-text">CF620E | New Year Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P2184-%E8%B4%AA%E5%A9%AA%E5%A4%A7%E9%99%86"><span class="toc-number">1.6.</span> <span class="toc-text">P2184 | 贪婪大陆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF992E-Nastya-and-King-Shamans"><span class="toc-number">1.7.</span> <span class="toc-text">CF992E | Nastya and King-Shamans</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E8%8A%82%E7%82%B9%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">跨节点维护线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#P2894-USACO08FEB-Hotel-G"><span class="toc-number">2.1.</span> <span class="toc-text">P2894 | [USACO08FEB]Hotel G</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P6492-COCI2010-2011-6-STEP"><span class="toc-number">2.2.</span> <span class="toc-text">P6492 | [COCI2010-2011#6] STEP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">动态开点线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CF431E-Chemistry-Experiment"><span class="toc-number">3.1.</span> <span class="toc-text">CF431E | Chemistry Experiment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF911G-Mass-Change-Queries"><span class="toc-number">3.2.</span> <span class="toc-text">CF911G | Mass Change Queries</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%ACk%E5%B0%8F%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">第k小数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">动态开点可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CF840D-Destiny"><span class="toc-number">5.1.</span> <span class="toc-text">CF840D | Destiny</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF1000F-One-Occurrence"><span class="toc-number">5.2.</span> <span class="toc-text">CF1000F | One Occurrence</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/post/%E8%AE%AD%E7%BB%83%E9%A2%98%E9%9B%86.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E8%AE%AD%E7%BB%83%E9%A2%98%E9%9B%86.html" title="训练题集">训练题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/data-structures/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a></div><span><a href="/post/STL%E7%AE%80%E4%BB%8B.html" title="STL 简介">STL 简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a></div><span><a href="/post/algorithm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" title="基础算法模板">基础算法模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" title="高级数据结构题集">高级数据结构题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a></div><span><a href="/post/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html" title="位运算合集">位运算合集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/algorithm/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html" title="数学知识">数学知识</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" title="搜索题集">搜索题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/article/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">308k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:40</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/线段树进阶.html",favicon:{show:"嗨~",hide:"呜呜呜"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->