<!-- build time:Wed Sep 07 2022 10:36:31 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,题集"><link rel="canonical" href="https://asterzc19.github.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>线段树进阶 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">线段树进阶</h1><div class="meta"><span class="item" title="创建时间：2022-09-06 07:46:22"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-06T07:46:22+08:00">2022-09-06</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/e82f196e980a63f5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/adf69ad6a75c5594.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/5c235cc1bbf7c128.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/848d77945ce37428.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/c262304a9abc9a8f.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/db894a8df07c1517.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/9d2607c6eedc2a1d.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/7f6edf1d98b0d8a0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/a655408706100f86.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/21bbfe021cfceec4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/0ff0506797b60902.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/372deb0eedb17ea9.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/4203257a6c65e036.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/728c619db3847842.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/0f4de4af64f8d166.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/40c7bc0e06dce5f2.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/a67b0e59dd863077.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/8e1dc72d6a2cd665.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/958c3bf3cd3a0db5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/04b816dd3c5c9934.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/17ec9c377d1b2c89.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/82a4dfcddf3ba7e0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/93a7b0f96c0166ce.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/05ac51bc092a5a09.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/9259140c0ac4c203.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/b545cd4703efa0d4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/79181978dd20d35c.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p>单开一篇新的文章，结合洛谷题单。</p></blockquote><span id="more"></span><h1 id="普通线段树"><a href="#普通线段树" class="headerlink" title="普通线段树"></a>普通线段树</h1><h2 id="CF240F-TorCoder"><a href="#CF240F-TorCoder" class="headerlink" title="CF240F | TorCoder"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YyNDBG">CF240F | TorCoder</span></h2><ul><li>题意<ul><li>给定一个长为 $n$ 的由 $a$ 到 $z$ 组成的字符串,有 $m$ 次操作，每次操作将 $[l,r]$ 这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法操作就不进行。</li><li>求 $m$ 次操作后的字符串。</li></ul></li><li>分析<ul><li>考虑开 26 棵线段树。每棵线段树维护它对应的字母在这个字符串中的出现情况。</li><li>这个区间中，出现的任何字母的出现次数<strong>要么都为偶数，要么只有一个奇数，其余都是偶数</strong>时，这个区间可以通过字母重排变为一个回文串。所以每棵线段树都需要支持区间求和以查询区间中特定字母的出现次数。</li><li>字典序越小的字母，我们优先把它放前面就可以了。</li><li>具体来说，如果字母的出现次数中有一个奇数，那么先把出现了奇数次的这个字母单拎出来扔到中间。然后，为了保证字典序最小，我们从 $a$ 到 $z$ ，从两边到中间放即可。对于每个字母，一边放一半。因此我们的每棵线段树需要支持区间赋值的操作。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e5 + 10;
struct Node&#123;
    int l, r;
    int sum, tag;
&#125;tr[26][N &lt;&lt; 2];
string s;
inline void pushup(int u, int p)&#123;
    tr[u][p].sum = tr[u][p &lt;&lt; 1].sum + tr[u][p &lt;&lt; 1 | 1].sum;
&#125;
inline void pushdown(int u, int p)&#123;
    if(tr[u][p].tag != -1)&#123;
        tr[u][p &lt;&lt; 1].tag = tr[u][p].tag;
        tr[u][p &lt;&lt; 1 | 1].tag = tr[u][p].tag;
        tr[u][p &lt;&lt; 1].sum = tr[u][p].tag * (tr[u][p &lt;&lt; 1].r - tr[u][p &lt;&lt; 1].l + 1);
        tr[u][p &lt;&lt; 1 | 1].sum = tr[u][p].tag * (tr[u][p &lt;&lt; 1 | 1].r - tr[u][p &lt;&lt; 1 | 1].l + 1);
        tr[u][p].tag = -1;
    &#125;
&#125;
inline void build(int u, int p, int l, int r)&#123;
    tr[u][p] = &#123;l, r, 0, -1&#125;;
    if(l == r)&#123;
        tr[u][p].sum = (s[l] - &#39;a&#39;) == u;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u, p &lt;&lt; 1, l, mid);
    build(u, p &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u, p);
&#125;
inline void modify(int u, int p, int l, int r, int v)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        tr[u][p].tag = v;
        tr[u][p].sum = v * (tr[u][p].r - tr[u][p].l + 1);
        return;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u, p &lt;&lt; 1, l, r, v);
    if(r &gt; mid) modify(u, p &lt;&lt; 1 | 1, l, r, v);
    pushup(u, p);
&#125;
inline int query(int u, int p, int l, int r)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        return tr[u][p].sum;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    int ans = 0;
    if(l &lt;= mid) ans += query(u, p &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query(u, p &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    s = &quot; &quot; + s;
    for(int i = 0; i &lt; 26; i++)&#123;
        build(i, 1, 1, n);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        vector&lt;int&gt; cnt(26);
        int odd = 0, need = -1;
        for(int j = 0; j &lt; 26; j++)&#123;
            cnt[j] = query(j, 1, l, r);
            if(cnt[j] &amp; 1) odd++, need = j;
        &#125;
        if(odd &gt; 1) continue;
        for(int j = 0; j &lt; 26; j++)&#123;
            modify(j, 1, l, r, 0);
        &#125;
        if(odd)&#123;
            --cnt[need];
            modify(need, 1, (l + r) &gt;&gt; 1, (l + r) &gt;&gt; 1, 1);
        &#125;
        int nl = l, nr = r;
        for(int j = 0; j &lt; 26; j++)&#123;
            if(cnt[j])&#123;
                modify(j, 1, nl, nl + cnt[j] / 2 - 1, 1);
                modify(j, 1, nr - cnt[j] / 2 + 1, nr, 1);
                nl += cnt[j] / 2;
                nr -= cnt[j] / 2;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt; 26; j++)&#123;
            if(query(j, 1, i, i))&#123;
                cout &lt;&lt; (char)(j + &#39;a&#39;);
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF242E-XOR-on-Segment"><a href="#CF242E-XOR-on-Segment" class="headerlink" title="CF242E | XOR on Segment"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YyNDJF">CF242E | XOR on Segment</span></h2><ul><li>题意<ul><li>给定 $n$ 个数的序列 $a$，$m$ 次操作，有以下两种操作：<ol><li>求 $\sum_{i &#x3D; l}^{r} a_i$。</li><li>把 $[l, r]$ 区间内每一个值都异或上 $x$。</li></ol></li></ul></li><li>分析<ul><li>平常的线段树都是动态区间询问和或者最值，但是这一道题将修改操作改成了区间异或，显然，我们无法像普通线段树一样操作。</li><li>如果和 $0$ 异或，那么 $1$ 的个数不变；</li><li>如果和 $1$ 异或，相当于将<strong>区间取反</strong>，那么 $1$ 的个数为原来 $0$ 的个数，即 $1$ 的个数为 序列长度 - 1的个数。</li><li>因此将每个数转成二进制，又因为 $a_i \le 10^6$ ，因此只需要开 20 棵线段树，每棵树维护某一位所有数的第 $i$ 进制位为 $1$ 的个数。</li><li>时间复杂度 $O(20nlogn)$。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
typedef long long LL;
struct Node&#123;
    int l, r;
    int sum, tag;
&#125;tr[21][N &lt;&lt; 2];
int pre[21], a[N];
inline void pushup(int u, int p)&#123;
    tr[u][p].sum = tr[u][p &lt;&lt; 1].sum + tr[u][p &lt;&lt; 1 | 1].sum;
&#125;
inline void pushdown(int u, int p)&#123;
    if(tr[u][p].tag)&#123;
        tr[u][p &lt;&lt; 1].sum = (tr[u][p &lt;&lt; 1].r - tr[u][p &lt;&lt; 1].l + 1) - tr[u][p &lt;&lt; 1].sum;
        tr[u][p &lt;&lt; 1].tag ^= tr[u][p].tag;
        tr[u][p &lt;&lt; 1 | 1].sum = (tr[u][p &lt;&lt; 1 | 1].r - tr[u][p &lt;&lt; 1 | 1].l + 1) - tr[u][p &lt;&lt; 1 | 1].sum;
        tr[u][p &lt;&lt; 1 | 1].tag ^= tr[u][p].tag;
        tr[u][p].tag = 0;
    &#125;
&#125;
inline void build(int u, int p, int l, int r)&#123;
    tr[u][p] = &#123;l, r, 0, 0&#125;;
    if(l == r)&#123;
        tr[u][p].sum = (pre[u] &amp; a[l]) != 0;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u, p &lt;&lt; 1, l, mid);
    build(u, p &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u, p);
&#125;
inline void modify(int u, int p, int l, int r)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        tr[u][p].tag ^= 1;
        tr[u][p].sum = (tr[u][p].r - tr[u][p].l + 1) - tr[u][p].sum;
        return;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u, p &lt;&lt; 1, l, r);
    if(r &gt; mid) modify(u, p &lt;&lt; 1 | 1, l, r);
    pushup(u, p);
&#125;
inline int query(int u, int p, int l, int r)&#123;
    if(l &lt;= tr[u][p].l &amp;&amp; tr[u][p].r &lt;= r)&#123;
        return tr[u][p].sum;
    &#125;
    pushdown(u, p);
    int mid = (tr[u][p].l + tr[u][p].r) &gt;&gt; 1;
    int ans = 0;
    if(l &lt;= mid) ans += query(u, p &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query(u, p &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; 20; i++)&#123;
        pre[i] = (1 &lt;&lt; i);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
    &#125;
    for(int i = 0; i &lt; 20; i++)&#123;
        build(i, 1, 1, n);
    &#125;
    cin &gt;&gt; m;
    while(m--)&#123;
        int op, l, r;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op == 1)&#123;
            LL ans = 0;
            for(int i = 0; i &lt; 20; i++)&#123;
                ans += 1ll * pre[i] * query(i, 1, l, r);
            &#125;
            cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
        &#125;else&#123;
            int x;
            cin &gt;&gt; x;
            for(int i = 0; i &lt; 20; i++)&#123;
                if(x &amp; pre[i])&#123;
                    modify(i, 1, l, r);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF438D-The-Child-and-Sequence"><a href="#CF438D-The-Child-and-Sequence" class="headerlink" title="CF438D | The Child and Sequence"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y0MzhE">CF438D | The Child and Sequence</span></h2><ul><li>题意<ul><li>给定序列，需要完成以下三种操作：<ol><li>查询区间和。</li><li>区间取模。</li><li>单点修改。</li></ol></li></ul></li><li>分析<ul><li>与给区间开根号的操作类似，当给区间开根号的时候，一个数只要变成 1 就不用再进行操作了，最多只需要开7、8次根号就不变了。</li><li>而当变成区间取模的时候，因为 $x ; mod ; p &lt; \frac{x}{2} ; (p &lt; x)$ ，所以取模最多也是 $log ; x$ 次，我们不妨记录区间最大值，如果最大值小于 $p$ 直接返回。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e5 + 10;
struct Node&#123;
    int l, r;
    LL sum, maxv;
&#125;tr[N &lt;&lt; 2];
LL w[N];
void pushup(int u)&#123;
    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    tr[u].maxv = max(tr[u &lt;&lt; 1].maxv, tr[u &lt;&lt; 1 | 1].maxv);
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r, 0, 0&#125;;
    if(l == r)&#123;
        tr[u].sum = tr[u].maxv = w[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
void modify_mod(int u, int l, int r, LL x)&#123;
    if(tr[u].maxv &lt; x) return;
    if(tr[u].l == tr[u].r)&#123;
        tr[u].sum %= x;
        tr[u].maxv %= x;
        return;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if(l &lt;= mid) modify_mod(u &lt;&lt; 1, l, r, x);
    if(r &gt; mid) modify_mod(u &lt;&lt; 1 | 1, l, r, x);
    pushup(u);
&#125;
void modify(int u, int l, int r, LL x)&#123;
    if(tr[u].l == tr[u].r)&#123;
        tr[u].sum = tr[u].maxv = x;
        return;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, x);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x);
    pushup(u);
&#125;
LL query(int u, int l, int r)&#123;
    if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    LL ans = 0;
    if(l &lt;= mid) ans += query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query(u &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
    &#125;
    build(1, 1, n);
    while(m--)&#123;
        int op;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; query(1, l, r) &lt;&lt; &#39;\n&#39;;
        &#125;else if(op == 2)&#123;
            int l, r, x;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
            modify_mod(1, l, r, x);
        &#125;else&#123;
            int k, x;
            cin &gt;&gt; k &gt;&gt; x;
            modify(1, k, k, x);
        &#125;
    &#125;
&#125;
</code></pre><h2 id="CF558E-A-Simple-Task"><a href="#CF558E-A-Simple-Task" class="headerlink" title="CF558E | A Simple Task"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y1NThF">CF558E | A Simple Task</span></h2><ul><li>题意<ul><li>对区间 $[l, r]$ 的字符串进行排序，1 为升序，0 为降序。</li></ul></li><li>分析<ul><li>经典操作，开 26 棵线段树，分别维护区间内每个字母的个数，开一个区间覆盖标记。</li><li>代码使用结构体封装的线段树。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
string s;
int n, m;

struct SegTree&#123;
    char letter;
    struct Node&#123;
        int l, r;
        int cov, sum;
    &#125;tr[N &lt;&lt; 2];

    void pushup(Node&amp; u, Node&amp; l, Node&amp; r)&#123;
        u.sum = l.sum + r.sum;
    &#125;
    void pushup(int u)&#123;
        pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);
    &#125;
    void build(int u, int l, int r)&#123;
        tr[u] = &#123;l, r, -1, s[l] == letter&#125;;
        if(l == r) return;
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid);
        build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
    void pushdown(int u)&#123;
        auto &amp;rt = tr[u], &amp;l = tr[u &lt;&lt; 1], &amp;r = tr[u &lt;&lt; 1 | 1];
        if(~rt.cov)&#123;
            l.cov = r.cov = rt.cov;
            l.sum = (l.r - l.l + 1) * rt.cov;
            r.sum = (r.r - r.l + 1) * rt.cov;
            rt.cov = -1;
        &#125;
    &#125;
    void modify(int u, int l, int r, int v)&#123;
        if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
            tr[u].cov = v;
            tr[u].sum = (tr[u].r - tr[u].l + 1) * v;
            return;
        &#125;
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
        pushup(u);
    &#125;
    int query(int u, int l, int r)&#123;
        if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        int ans = 0;
        if(l &lt;= mid) ans += query(u &lt;&lt; 1, l, r);
        if(r &gt; mid) ans += query(u &lt;&lt; 1 | 1, l, r);
        return ans;
    &#125;
&#125;tr[26];

void build(int l, int r)&#123;
    for(int i = 0; i &lt; 26; i++)&#123;
        tr[i].letter = &#39;a&#39; + i;
        tr[i].build(1, l, r);
    &#125;
&#125;

void sort(int l, int r, int op)&#123;
    vector&lt;pair&lt;char, int&gt;&gt; letters;
    for(int i = 0; i &lt; 26; i++)&#123;
        int cnt = tr[i].query(1, l, r);
        letters.push_back(&#123;i, cnt&#125;);
        tr[i].modify(1, l, r, 0);
    &#125;
    if(op == 0) reverse(letters.begin(), letters.end());
    int cur = l;
    for(auto range : letters)&#123;
        if(range.second == 0) continue;
        tr[range.first].modify(1, cur, cur + range.second - 1, 1);
        cur += range.second;
    &#125;
&#125;

int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    cin &gt;&gt; s;
    s = &quot; &quot; + s;
    build(1, n);
    while(m--)&#123;
        int l, r, op;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;
        sort(l, r, op);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt; 26; j++)&#123;
            if(tr[j].query(1, i, i))&#123;
                cout &lt;&lt; (char)(&#39;a&#39; + j);
                break;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre><h2 id="CF620E-New-Year-Tree"><a href="#CF620E-New-Year-Tree" class="headerlink" title="CF620E | New Year Tree"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y2MjBF">CF620E | New Year Tree</span></h2><ul><li>题意<ul><li>给出一棵 $n$ 个节点的树，根节点为 $1$。每个节点上有一种颜色 $c_i$。$m$ 次操作。操作有两种：<ol><li><code>1 u c</code>：将以 $u$ 为根的子树上的所有节点的颜色改为 $c$。</li><li><code>2 u</code>：询问以 $u$ 为根的子树上的所有节点的颜色数量。</li></ol></li></ul></li><li>分析<ul><li>因为空间有限，选择只开一颗线段树，运用状态压缩，以一个数表示区间内颜色。</li><li>又由于需要在树上操作子树，所以我们需要 dfs 一遍获得每个节点的 dfn，并且记录以 $x$ 为根的子树的 dfn 区间。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 4e5 + 10;
int h[N], e[N &lt;&lt; 1], ne[N &lt;&lt; 1], idx;
int in[N], out[N], dfn[N], cnt;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u, int fa)&#123;
    in[u] = ++cnt;
    dfn[cnt] = u;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa) continue;
        dfs(j, u);
    &#125;
    out[u] = cnt;
&#125;

struct Node&#123;
    int l, r;
    LL sum, add;
&#125;tr[N &lt;&lt; 2];
int c[N];
void pushup(int u)&#123;
    tr[u].sum = tr[u &lt;&lt; 1].sum | tr[u &lt;&lt; 1 | 1].sum;
&#125;
void pushdown(int u)&#123;
    if(tr[u].add)&#123;
        tr[u &lt;&lt; 1].add = tr[u].add;
        tr[u &lt;&lt; 1 | 1].add = tr[u].add;
        tr[u &lt;&lt; 1].sum = tr[u].add;
        tr[u &lt;&lt; 1 | 1].sum = tr[u].add;
        tr[u].add = 0;
    &#125;
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r)&#123;
        tr[u].sum = 1ll &lt;&lt; c[dfn[l]];
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
void modify(int u, int l, int r, LL v)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        tr[u].sum = v;
        tr[u].add = v;
        return;
    &#125;
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
    pushup(u);
&#125;
LL query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        return tr[u].sum;
    &#125;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    pushdown(u);
    LL res = 0;
    if(l &lt;= mid) res |= query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) res |= query(u &lt;&lt; 1 | 1, l, r);
    return res;
&#125;
LL lowbit(LL x)&#123;
    return x &amp; -x;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i];
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b), add(b, a);
    &#125;
    dfs(1, 0);
    build(1, 1, n);
    while(m--)&#123;
        int op;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            modify(1, in[a], out[a], 1ll &lt;&lt; b);
        &#125;else&#123;
            int a;
            cin &gt;&gt; a;
            LL res = query(1, in[a], out[a]);
            int ans = 0;
            while(res)&#123;
                res -= lowbit(res);
                ans++;
            &#125;
            cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre><h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><ul><li>通常来说，线段树占用空间是总区间长 $n$ 的常数倍，空间复杂度是 $O(n)$。然而，有时候 $n$ 很巨大，而我们又不需要使用所有的节点，这时便可以动态开点——不再一次性建好树，而是一边修改、查询一边建立。设总查询次数为 $m$，则这样的总空间复杂度为 $O(m;log;n)$。</li><li>比起普通线段树，动态开点线段树有一个优势，它能够处理零或负数位置。此时，求 $mid$ 时不能用 $(cl + cr) &#x2F; 2$，而要用 $(cl + cr - 1) &#x2F; 2$。</li><li>通常用在没有提供初始数据的场合（例如初始全0），这时更能显示出优势。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
#define val(x) tr[x].val
#define mark(x) tr[x].mark
// N 一般能开多大开多大，例如内存限制 128M 时可以开到八百万左右
const int N = 8e6;
int L = 1, R = 1e5, cnt = 1;
struct Node&#123;
    int ls, rs;
    LL val, mark;
&#125;tr[N];
void push_down(int p, int len)&#123;
    if(len &lt;= 1) return;
    if(!ls(p)) ls(p) = ++cnt;
    if(!rs(p)) rs(p) = ++cnt;
    val(ls(p)) += mark(p) * (len / 2);
    mark(ls(p)) += mark(p);
    val(rs(p)) += mark(p) * (len - len / 2);
    mark(rs(p)) += mark(p);
    mark(p) = 0;
&#125;
LL query(int u, int l, int r, int cl = L, int cr = R)&#123;
    if(cl &gt;= l &amp;&amp; cr &lt;= r) return val(u);
    push_down(u, cr - cl + 1);
    LL mid = (cl + cr - 1) / 2, ans = 0;
    if(l &lt;= mid) ans += query(ls(u), l, r, cl, mid);
    if(r &gt; mid) ans += query(rs(u), l, r, mid + 1, cr);
    return ans;
&#125;
void update(int l, int r, int d, int u = 1, int cl = L, int cr = R)&#123;
    if(cl &gt;= l &amp;&amp; cr &lt;= r)&#123;
        val(u) += d * (cr - cl + 1);
        mark(u) += d;
        return;
    &#125;
    push_down(u, cr - cl + 1);
    LL mid = (cl + cr - 1) / 2;
    if(l &lt;= mid) update(l, r, d, ls(u), cl, mid);
    if(r &gt; mid) update(l, r, d, rs(u), mid + 1, cr);
    val(u) = val(ls(u)) + val(rs(u));
&#125;
</code></pre><h2 id="CF431E-Chemistry-Experiment"><a href="#CF431E-Chemistry-Experiment" class="headerlink" title="CF431E | # Chemistry Experiment"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y0MzFF">CF431E | # Chemistry Experiment</span></h2><ul><li>题目中第二种操作需要将 $v$ 体积的水任意分配到 $n$ 支试管里，最小化有水的试管中的最大体积，输出这个最小值，该操作不会造成影响。</li><li>最小化最大值，考虑二分答案，因为只能往小于等于 $mid$ 的试管里面灌，也就是说我们要统计出所有高度小于等于 $mid$ 的试管的数量 $num$，同时也要统计这些试管里面水银的体积 $sum$。如果 $num \times mid - sum \ge v$ 这个 $mid$ 就是可行的（自行画图体会）。</li><li>又由于没有区间限制，而且 mid 值不确定，果断上权值线段树 + 动态开点。</li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int INF = 1e9;
const int N = 1e5 + 10;
const double eps = 1e-5;
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
#define val(x) tr[x].val
#define sum(x) tr[x].sum
#define sz(x) tr[x].sz
struct Node&#123;
    int ls, rs;
    LL sz, sum;
&#125;tr[N &lt;&lt; 6];
int idx, root;
int w[N];
int n, q, m = 1e9 + 10;
void pushup(Node&amp; u, Node&amp; l, Node&amp; r)&#123;
    u.sz = l.sz + r.sz;
    u.sum = l.sum + r.sum;
&#125;
void modify(int&amp; u, int l, int r, int x, int v)&#123;
    if(!u) u = ++idx;
    tr[u].sz += v, tr[u].sum += x * v;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    if(x &lt;= mid) modify(ls(u), l, mid, x, v);
    else modify(rs(u), mid + 1, r, x, v);
&#125;
Node query(int u, int l, int r, int ql, int qr)&#123;
    if(!u) return &#123;0, 0, 0, 0&#125;;
    if(ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u];
    int mid = (l + r) &gt;&gt; 1;
    if(qr &lt;= mid) return query(ls(u), l, mid, ql, qr);
    if(ql &gt; mid) return query(rs(u), mid + 1, r, ql, qr);
    Node res, left = query(ls(u), l, mid, ql, qr), right = query(rs(u), mid + 1, r, ql, qr);
    pushup(res, left, right);
    return res;
&#125;

bool check(double mid, LL v)&#123;
    LL up = floor(mid);
    if(up &gt; m) up = m;
    Node ans = query(root, 0, m, 0, up);
    double remain = 1.0 * ans.sz * mid - ans.sum - v;
    return remain &gt;= eps;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cout &lt;&lt; fixed &lt;&lt; setprecision(5);
    cin &gt;&gt; n &gt;&gt; q;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        modify(root, 0, m, w[i], 1);
    &#125;
    while(q--)&#123;
        int op;
        LL a, b;
        cin &gt;&gt; op;
        if(op == 1)&#123;
            cin &gt;&gt; a &gt;&gt; b;
            modify(root, 0, m, w[a], -1);
            w[a] = b;
            modify(root, 0, m, w[a], 1);
        &#125;else&#123;
            cin &gt;&gt; a;
            double l = 0, r = 1e15;
            while(r - l &gt; eps)&#123;
                double mid = (l + r) / 2;
                if(check(mid, a)) r = mid;
                else l = mid;
            &#125;
            cout &lt;&lt; l &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><hr><h1 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h1><ul><li>例题：区间 k 个数最大和</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010, M = 20010;
int n, m, k, x;
int a[N];
vector&lt;int&gt; nums;
struct Node&#123;
    int l, r, cnt;
    LL sum, val;        // cnt 记录出现次数，sum 记录和，val 记录值
&#125;tr[N * 40];
int root[N], idx;

int find(int x)&#123;
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
&#125;
int build(int l, int r)&#123;
    int p = ++idx;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
&#125;
int insert(int p, int l, int r, int x, int val)&#123;
    int q = ++idx;
    tr[q] = tr[p];
    tr[q].cnt++, tr[q].sum += val;
    if(l == r)&#123;
        tr[q].val = val;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x, val);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x, val);
    return q;
&#125;
// 查询前 k 大值，因为节点存的是值，所以找大的，先从右边找。
LL query(int q, int p, int l, int r, int k)&#123;
    if(l == r) return tr[q].val * k;    // 因为一个值可能出现多次，那么计算答案的时候要把他们都算上
    int cnt = tr[tr[q].r].cnt - tr[tr[p].r].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[q].r, tr[p].r, mid + 1, r, k);
    else return query(tr[q].l, tr[p].l, l, mid, k - cnt) + tr[tr[q].r].sum - tr[tr[p].r].sum;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;
    for(int i = 1; i &lt; nums.size(); i++)&#123;
        nums[i] += nums[i - 1];
    &#125;
/*     sort(nums.begin(), nums.end());
    nums.resize(unique(nums.begin(), nums.end()) - nums.begin()); */
    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i++)&#123;
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]), a[i]);
    &#125;
    while(m--)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        if(nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &gt;= x)&#123;
            cout &lt;&lt; &quot;Y\n&quot;;
        &#125;else&#123;
            cout &lt;&lt; &quot;N\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU3Lw==">第k小数</span></h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUxNDU2Lw==">题解</span></li><li>可持久化线段树<ul><li>难以进行区间修改操作</li></ul></li><li>离散化</li><li>在数值上建立线段树，维护每个数值区间中一共有多少个数</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, M = 10010;
int n, m;
int a[N];
vector&lt;int&gt; nums;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N * 4 + N * 17];
int root[N], idx;

int find(int x)&#123;
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
&#125;
int build(int l, int r)&#123;
    int p = ++idx;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
&#125;
int insert(int p, int l, int r, int x)&#123;
    int q = ++idx;
    tr[q] = tr[p];
    if(l == r)&#123;
        tr[q].cnt++;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
&#125;
int query(int q, int p, int l, int r, int k)&#123;
    if(l == r) return r;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k);
    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;
    sort(nums.begin(), nums.end());
    nums.resize(unique(nums.begin(), nums.end()) - nums.begin());
    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i++)&#123;
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));
    &#125;
    while(m--)&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl;
    &#125;
&#125;
</code></pre><hr><h1 id="动态开点可持久化线段树"><a href="#动态开点可持久化线段树" class="headerlink" title="动态开点可持久化线段树"></a>动态开点可持久化线段树</h1><ul><li>例题为 区间第 k 小</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, INF = 1e9;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N &lt;&lt; 5];
int n, m, idx , root[N], a[N];

void insert(int &amp;u, int v, int l, int r, int x)&#123;
    u = ++ idx;
    tr[u] = tr[v];
    tr[u].cnt ++ ;
    if(l == r) return ;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) insert(tr[u].l, tr[v].l, l, mid, x);
    else insert(tr[u].r, tr[v].r, mid + 1, r, x);
&#125;

int query(int p, int q, int l, int r, int k)&#123;
    if(l == r) return l;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[p].l, tr[q].l, l, mid, k);
    if(k &gt; cnt) return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
&#125;

int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1 ; i &lt;= n ; i ++ )&#123;
        cin &gt;&gt; a[i];
        insert(root[i], root[i - 1], -INF, INF, a[i]);
    &#125;
    for(int i = 1 ; i &lt;= m ; i ++ )&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; query(root[l - 1], root[r], -INF, INF, k) &lt;&lt; endl;
    &#125;
    
    return 0;
&#125;
</code></pre><h2 id="CF840D-Destiny"><a href="#CF840D-Destiny" class="headerlink" title="CF840D | Destiny"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y4NDBE">CF840D | Destiny</span></h2><ul><li>题意<ul><li>给定 $n$ 个元素，$m$ 次询问。</li><li>每次给出三个参数 $l,r,k$，询问区间 $[l,r]$ 内是否存在出现次数严格大于 $\frac{r-l+1}{k}$ 的数。如果存在就输出最小的那个 $ans$，否则输出 -1.</li></ul></li><li>分析<ul><li>考虑求的是区间出现个数大于 $\frac{r-l+1}{k}$ 的最小值，因此可以将区间排序然后分成 $k$ 段，并依次查询，取最小值。</li><li>左边的权值一定比右边的权值小，如果左边的出现个数大于 $\lfloor \frac{r-l+1}{k} \rfloor$ 那么很显然这边是有可能的，暴力找下试试看，如果不行的话，向右找，如果可以的话，这样依次找，直到找到了，一定是最小值，如果变成最大值的话，就从右边开始取。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 3e5 + 10;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N &lt;&lt; 5];
int idx, root[N], w[N];
void insert(int&amp; u, int v, int l, int r, int x)&#123;
    u = ++idx;
    tr[u] = tr[v];
    tr[u].cnt++;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    if(x &lt;= mid) insert(tr[u].l, tr[v].l, l, mid, x);
    else insert(tr[u].r, tr[v].r, mid + 1, r, x);
&#125;
int query(int p, int q, int l, int r, int k)&#123;
    if(l == r) return l;
    int cnt1 = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int cnt2 = tr[tr[q].r].cnt - tr[tr[p].r].cnt;
    int mid = l + r &gt;&gt; 1, ans = -1;
    if(cnt1 &gt; k)&#123;
        ans = query(tr[p].l, tr[q].l, l, mid, k);
    &#125;
    if(~ans) return ans;
    if(cnt2 &gt; k)&#123;
        ans = query(tr[p].r, tr[q].r, mid + 1, r, k);
    &#125;
    return ans;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        insert(root[i], root[i - 1], 1, n, w[i]);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        k = (r - l + 1) / k;
        cout &lt;&lt; query(root[l - 1], root[r], 1, n, k) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E9%A2%98%E9%9B%86/" rel="tag"><i class="ic i-tag"></i> 题集</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-07 09:04:29" itemprop="dateModified" datetime="2022-09-07T09:04:29+08:00">2022-09-07</time> </span><span id="post/线段树进阶.html" class="item leancloud_visitors" data-flag-title="线段树进阶" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html" title="线段树进阶">https://asterzc19.github.io/post/线段树进阶.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;848d77945ce37428.jpg" title="网络流"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>网络流</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">普通线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CF240F-TorCoder"><span class="toc-number">1.1.</span> <span class="toc-text">CF240F | TorCoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF242E-XOR-on-Segment"><span class="toc-number">1.2.</span> <span class="toc-text">CF242E | XOR on Segment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF438D-The-Child-and-Sequence"><span class="toc-number">1.3.</span> <span class="toc-text">CF438D | The Child and Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF558E-A-Simple-Task"><span class="toc-number">1.4.</span> <span class="toc-text">CF558E | A Simple Task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF620E-New-Year-Tree"><span class="toc-number">1.5.</span> <span class="toc-text">CF620E | New Year Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">动态开点线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CF431E-Chemistry-Experiment"><span class="toc-number">2.1.</span> <span class="toc-text">CF431E | # Chemistry Experiment</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%ACk%E5%B0%8F%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">第k小数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">动态开点可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CF840D-Destiny"><span class="toc-number">4.1.</span> <span class="toc-text">CF840D | Destiny</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html" title="线段树进阶">线段树进阶</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" title="图论题集">图论题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" title="搜索题集">搜索题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%96%87%E7%AB%A0/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/AcWing/" title="分类于 AcWing">AcWing</a></div><span><a href="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html" title="线性同余方程">线性同余方程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" title="网络流">网络流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" title="基础算法模板">基础算法模板</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" title="Flyme 更新日志">Flyme 更新日志</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">292k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:26</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/线段树进阶.html",favicon:{show:"嗨~",hide:"呜呜呜"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->