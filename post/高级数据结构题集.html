<!-- build time:Wed Sep 07 2022 10:36:31 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,题集"><link rel="canonical" href="https://asterzc19.github.io/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>高级数据结构题集 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">高级数据结构题集</h1><div class="meta"><span class="item" title="创建时间：2022-06-09 18:00:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-09T18:00:20+08:00">2022-06-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>52k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>47 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/adf69ad6a75c5594.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/372deb0eedb17ea9.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/b545cd4703efa0d4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/5c235cc1bbf7c128.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/6cde4a47e73d00cf.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/a67b0e59dd863077.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/db894a8df07c1517.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/c262304a9abc9a8f.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/7f6edf1d98b0d8a0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/848d77945ce37428.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/958c3bf3cd3a0db5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2ed81611f053c81c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/21bbfe021cfceec4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/0f4de4af64f8d166.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/728c619db3847842.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/9259140c0ac4c203.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/93a7b0f96c0166ce.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/a655408706100f86.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/85da8357bdceba73.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/8e1dc72d6a2cd665.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/e82f196e980a63f5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/17ec9c377d1b2c89.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/04b816dd3c5c9934.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2b1d828f5ff26065.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/4203257a6c65e036.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/44d29b2c5b4e40c8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/0ff0506797b60902.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p>包括并查集、树状数组、线段树、可持久化数据结构、平衡树、AC 自动机。<br>其余数据结构参考自 Pecco 、OI WIKI 以及他人博客。</p></blockquote><span id="more"></span><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="格子游戏"><a href="#格子游戏" class="headerlink" title="格子游戏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI1Mi8=">格子游戏</span></h3><ul><li>判断是否成环，当且仅当新加入的那条边的两个端点都在同一个集合中。</li><li>二维坐标 $(x, y)$ 转换成一维坐标 $(x \times n + y)$ （ $x, y$ 均从 0 开始）。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 40010;
int p[N];
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m, pos = 0;
    cin &gt;&gt; n &gt;&gt; m;
    auto getid = [&amp;](int x, int y)&#123;
        return (x * n + y);
    &#125;;
    for(int i = 0; i &lt; n * n; i++) p[i] = i;   // 转换坐标从 0 开始
    for(int i = 1; i &lt;= m; i++)&#123;
        int x, y;
        char op;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;
        x--, y--;   // 坐标从 0 开始
        int a = getid(x, y), b;
        if(op == &#39;R&#39;) b = getid(x, y + 1);
        else b = getid(x + 1, y);
        int pa = find(a), pb = find(b);
        if(pa == pb)&#123;
            pos = i;
            break;
        &#125;
        p[pa] = pb;
    &#125;
    if(!pos) cout &lt;&lt; &quot;draw&quot; &lt;&lt; endl;
    else cout &lt;&lt; pos &lt;&lt; endl;
&#125;
</code></pre><h3 id="搭配购买"><a href="#搭配购买" class="headerlink" title="搭配购买"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI1NC8=">搭配购买</span></h3><ul><li>维护 size 的并查集 + 01 背包</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010;
int p[N], v[N], w[N], dp[N];
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m, c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; v[i] &gt;&gt; w[i];
        p[i] = i;
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        int pa = find(a), pb = find(b);
        if(pa != pb)&#123;
            v[pb] += v[pa];
            w[pb] += w[pa];
            p[pa] = pb;
        &#125;
    &#125;
    // 01 背包
    for(int i = 1; i &lt;= n; i++)&#123;
        if(p[i] == i)&#123;
            for(int j = c; j &gt;= v[i]; j--)&#123;
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[c] &lt;&lt; endl;
&#125;
</code></pre><h3 id="程序自动分析"><a href="#程序自动分析" class="headerlink" title="程序自动分析"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjM5Lw==">程序自动分析</span></h3><ul><li>离散化</li><li>将所有相等的条件合并</li><li>依次判断每个不相等的条件</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int p[200010], cnt;
unordered_map&lt;int, int&gt; mp;
struct Query
&#123;
    int x, y, e;
&#125;query[200010];

int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int get(int x)&#123;
    if(!mp.count(x)) mp[x] = ++cnt;
    return mp[x];
&#125;
void solve()&#123;
    cnt = 0;
    mp.clear();

    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        int x, y, e;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; e;
        x = get(x), y = get(y);
        query[i] = &#123;x, y, e&#125;;
    &#125;
    for(int i = 1; i &lt;= cnt; i++) p[i] = i;
    // 合并所有相等的
    for(int i = 1; i &lt;= n; i++)&#123;
        if(query[i].e)&#123;
            int pa = find(query[i].x), pb = find(query[i].y);
            p[pa] = pb;
        &#125;
    &#125;
    // 检查所有不等的
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!query[i].e)&#123;
            int pa = find(query[i].x), pb = find(query[i].y);
            if(pa == pb)&#123;
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
                return;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t;
    cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h3 id="银河英雄传说"><a href="#银河英雄传说" class="headerlink" title="银河英雄传说"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQwLw==">银河英雄传说</span></h3><ul><li>让排头当根节点，维护当前战舰到排头的距离，相对距离 $|d[x] - d[y]| - 1$ 。</li><li>$d[pa] &#x3D; size[pb]$, $size[pb] ; +&#x3D; ; size[pa]$</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 30010;
int p[N], sz[N], d[N];
int find(int x)&#123;
    if(p[x] != x)&#123;
        int root = find(p[x]);
        d[x] += d[p[x]];
        p[x] = root;
    &#125;
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    for(int i = 1; i &lt; N; i++)&#123;
        p[i] = i;
        sz[i] = 1;
    &#125;
    int t;
    cin &gt;&gt; t;
    while(t--)&#123;
        char op;
        int x, y;
        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;
        if(op == &#39;M&#39;)&#123;
            int px = find(x), py = find(y);
            d[px] = sz[py];
            sz[py] += sz[px];
            p[px] = py;
        &#125;else&#123;
            int px = find(x), py = find(y);
            if(px == py)&#123;
                int ans = max(0, abs(d[x] - d[y]) - 1);
                cout &lt;&lt; ans &lt;&lt; endl;
            &#125;else&#123;
                cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQxLw==">奇偶游戏</span></h3><ul><li>由数据范围知，需要使用离散化。</li><li>题目条件可以转换成求前缀和，求 $S[L,R]$ 中是否有奇数个 1，可以转换成 $S_R - S_{L-1}$ 为奇数，可以再转换成判断 $S_R$ 和 $S_{L_1}$ 奇偶性不同。</li></ul><h4 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h4><ul><li>是一种枚举的思路，$x$ 表示如果 $x$ 是偶数情况下，$x+n$ 表示如果 $x$ 是奇数情况下。</li><li>重点是弄清楚同一个集合里的含义。一般情况是某个集合一个条件成立，则其他条件均成立。即集合里保存的是条件。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 40010, Base = N / 2;
int cnt, p[N];
unordered_map&lt;int, int&gt; mp;
int getid(int x)&#123;
    if(!mp.count(x)) mp[x] = ++cnt;
    return mp[x];
&#125;
int find(int x)&#123;
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt; N; i++) p[i] = i;
    int pos = m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int l, r;
        string op;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;
        l = getid(l - 1), r = getid(r);
        if(op == &quot;even&quot;)&#123;
            if(find(l + Base) == find(r))&#123;
                pos = i - 1;
                break;
            &#125;
            p[find(l)] = find(r);
            p[find(l + Base)] = find(r + Base);
        &#125;else&#123;
            if(find(l) == find(r))&#123;
                pos = i - 1;
                break;
            &#125;
            p[find(l + Base)] = find(r);
            p[find(l)] = find(r + Base);
        &#125;
    &#125;
    cout &lt;&lt; pos &lt;&lt; endl;
&#125;
</code></pre><h4 id="带边权的并查集"><a href="#带边权的并查集" class="headerlink" title="带边权的并查集"></a>带边权的并查集</h4><ul><li>$d[x]$ 表示 $x$ 与 $p[x]$ 的关系。<ul><li>$0$ 表示同类，$1$ 表示不同类</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20010;
int cnt, p[N], d[N];
unordered_map&lt;int, int&gt; mp;
int getid(int x)&#123;
    if(!mp.count(x)) mp[x] = ++cnt;
    return mp[x];
&#125;
int find(int x)&#123;
    if(p[x] != x)&#123;
        int root = find(p[x]);
        d[x] ^= d[p[x]];
        p[x] = root;
    &#125;
    return p[x];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt; N; i++) p[i] = i;
    int pos = m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int l, r;
        string op;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;
        l = getid(l - 1), r = getid(r);
        int pa = find(l), pb = find(r);
        int t = 0;
        if(op == &quot;odd&quot;) t = 1;
        if(pa == pb)&#123;
            if((d[l] ^ d[r]) != t)&#123;
                pos = i - 1;
                break;
            &#125;
        &#125;else&#123;
            p[pa] = pb;
            d[pa] = d[l] ^ d[r] ^ t; // 构造距离
        &#125;
    &#125;
    cout &lt;&lt; pos &lt;&lt; endl;
&#125;
</code></pre><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><ol><li>快速求前缀和	$O(logn)$</li><li>修改某一个数	$O(logn)$</li></ol><ul><li>基于二进制思想	$X &#x3D; 2^{i_k} + 2^{i_{k-1}} + 2^{i_{k-2}} + \cdots + 2^{i_1}$，因此 $1 \sim x$ 可以被分成 $k$ 段。</li><li>$(X - 2^{i_1}, X], (X - 2^{i_1} - 2^{i_2}, X - 2^{i_1}] \cdots (0, X - 2^{i_1} - 2^{i_2} \cdots - 2^{i_k}]$</li><li>$(L, R]$ 长度一定是 $R$ 的二进制表示的最后一位 $1$ 所对应的次幂，即 $[R - lowbit(R) + 1, R]$。</li><li>操作<ul><li>对 $a[x]$ 进行修改 <code>for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;</code></li><li>查询 $a[1 \sim x]$ 的和 <code>for(int i = x; i; i -= lowbit(i)) res += tr[i];</code></li></ul></li></ul><h3 id="楼兰图腾"><a href="#楼兰图腾" class="headerlink" title="楼兰图腾"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQzLw==">楼兰图腾</span></h3><ul><li>$tr[x]$ 存储的是区间 $[x - lowbit (x) + 1, x]$ 出现的数的次数，$sum$ 求的是 $1 \sim x$ 中出现的数的个数。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 200010;
typedef long long LL;
int n;
int Greater[N], Lower[N];
int a[N], tr[N];
int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;
void add(int x, int v)&#123;
    for(; x &lt;= n; x += lowbit(x)) tr[x] += v;
&#125;
int sum(int x)&#123;
    int res = 0;
    for(; x &gt; 0; x -= lowbit(x)) res += tr[x];
    return res;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    for(int i = 1; i &lt;= n; i++)&#123;
        int t = a[i];
        Greater[i] = sum(n) - sum(t);
        Lower[i] = sum(t - 1);
        add(t, 1);
    &#125;
    memset(tr, 0, sizeof(tr));
    LL ans1 = 0, ans2 = 0;
    for(int i = n; i; i--)&#123;
        int t = a[i];
        ans1 += Greater[i] * (LL)(sum(n) - sum(t));
        ans2 += Lower[i] * (LL)(sum(t - 1));
        add(t, 1);
    &#125;
    cout &lt;&lt; ans1 &lt;&lt; &#39; &#39; &lt;&lt; ans2 &lt;&lt; endl;
&#125;
</code></pre><h3 id="一个简单的整数问题-Ⅰ"><a href="#一个简单的整数问题-Ⅰ" class="headerlink" title="一个简单的整数问题 Ⅰ"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ4Lw==">一个简单的整数问题 Ⅰ</span></h3><ul><li>区间修改，单点查询，直接用差分数组建树维护单点值（前缀和）。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
int n;
int a[N], tr[N];
int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;
void add(int x, int v)&#123;
    for(; x &lt;= n; x += lowbit(x)) tr[x] += v;
&#125;
LL sum(int x)&#123;
    LL res = 0;
    for(; x &gt; 0; x -= lowbit(x)) res += tr[x];
    return res;
&#125;
int main()&#123;
    int m;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    for(int i = 1; i &lt;= n; i++) add(i, a[i] - a[i - 1]);
    while(m--)&#123;
        char op;
        int l, r, d;
        cin &gt;&gt; op;
        if(op == &#39;Q&#39;)&#123;
            cin &gt;&gt; d;
            cout &lt;&lt; sum(d) &lt;&lt; endl;
        &#125;else&#123;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            add(l, d); add(r + 1, -d);
        &#125;
    &#125;
&#125;
</code></pre><h3 id="一个简单的整数问题-Ⅱ-🌸"><a href="#一个简单的整数问题-Ⅱ-🌸" class="headerlink" title="一个简单的整数问题 Ⅱ 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ0Lw==">一个简单的整数问题 Ⅱ</span> 🌸</h3><ul><li>区间修改，区间求和</li><li>要在 $O(logn)$ 的时间复杂度内对差分树状数组进行区间查询，需要额外维护一个 $i \times b_i$ 的差分树状数组。</li><li>$S_n &#x3D; (b_1 + b_2 + \cdots + b_n) \times (n + 1) - (1 \times b_1 + 2 \times b_2 + \cdots i \times b_i)$</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010;
int n, m;
int a[N];
LL tr1[N], tr2[N];  // 维护 b[i] 和 b[i] * i 的前缀和
int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;
void add(LL tr[], int x, LL v)&#123;
    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;
&#125;
LL sum(LL tr[], int x)&#123;
    LL res = 0;
    for(int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
&#125;
LL cal(int x)&#123;
    return sum(tr1, x) * (x + 1) - (sum(tr2, x));
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    for(int i = 1; i &lt;= n; i++)&#123;
        int t = a[i] - a[i - 1];
        add(tr1, i, t); add(tr2, i, (LL)t * i);
    &#125;
    while(m--)&#123;
        char op;
        int l, r, d;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op == &#39;Q&#39;) cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;
        else&#123;
            cin &gt;&gt; d;
            add(tr1, l, d); add(tr2, l, (LL)d * l);     // a[l] += d
            add(tr1, r + 1, -d); add(tr2, r + 1, -(LL)d * (r + 1));     // a[r] -= d
        &#125;
    &#125;
&#125;
</code></pre><h3 id="谜一样的牛-🌸"><a href="#谜一样的牛-🌸" class="headerlink" title="谜一样的牛 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ1Lw==">谜一样的牛</span> 🌸</h3><ul><li>从剩余的数中，找到第 $k$ 小的数。$\Longleftrightarrow$ 找到一个最小的 $x$，使得 $sum (x) &#x3D; k$。</li><li>删除某个数。$\Longleftrightarrow$ $add(x, -1)$。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010;
int n;
int h[N], tr[N], ans[N];
int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;
void add(int x, int v)&#123;
    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;
&#125;
int sum(int x)&#123;
    int res = 0;
    for(int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) tr[i] = lowbit(i);
    for(int i = 2; i &lt;= n; i++) cin &gt;&gt; h[i];
    for(int i = n; i; i--)&#123;
        int k = h[i] + 1;
        int l = 1, r = n;
        while(l &lt; r)&#123;
            int mid = (l + r) &gt;&gt; 1;
            if(sum(mid) &gt;= k) r = mid;
            else l = mid + 1;
        &#125;
        ans[i] = l;
        add(l, -1);
    &#125;
    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;
&#125;
</code></pre><h3 id="CF383C-Propagating-tree"><a href="#CF383C-Propagating-tree" class="headerlink" title="CF383C | Propagating tree"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YzODND">CF383C | Propagating tree</span></h3><ul><li>题意<ul><li>树上每个节点都有一个权值，有两种操作：<ul><li>给一个节点的权值增加 $val$， 它的子节点权值都增加 $-val$， 它子节点的子节点权值都增加 $-(-val)$，一直到树的底部。</li><li>查询某个节点的权值。</li></ul></li></ul></li><li>题解<ul><li>可以树剖结合线段树维护，我们考虑让深度为奇数的根的子树修改的时候直接加 $val$，偶数的直接减去 $val$。这样我们就消除了所加的子树根结点深度不同的问题，所以我们的懒标记就可以合并了。</li><li>因为先前我们对深度不同的结点做出的调整，所以最后我们只需要在访问到每个点的时候判断一下深度的奇偶性，对应的加减就行了。</li><li>不过我们也可以用树状数组维护一个差分数组 $f[n]$，表示第 $n$ 号节点的修改情况，其中如果 $depth[n]$ 是奇数则记录增加量，否则记录减少量。则题中修改就等同于在 $dfs$ 序上修改一段区间（因为这时候增减已经不影响了）。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 2e5 + 10;
int tr[N], l[N], r[N];
int n, m;
inline int lowbit(int x)&#123;
    return x &amp; -x;
&#125;
inline void add(int x, int v)&#123;
    for(; x &lt;= n; x += lowbit(x))
        tr[x] += v;
&#125;
inline int sum(int x)&#123;
    int ret = 0;
    for(; x &gt; 0; x -= lowbit(x))
        ret += tr[x];
    return ret;
&#125;

int h[N], e[N &lt;&lt; 1], ne[N &lt;&lt; 1], idx;
inline void addedge(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
int depth[N], tot;
void dfs(int u, int fa)&#123;
    l[u] = ++tot;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa) continue;
        depth[j] = depth[u] + 1;
        dfs(j, u);
    &#125;
    r[u] = tot;
&#125;
int val[N];
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; val[i];
    &#125;
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        addedge(a, b);
        addedge(b, a);
    &#125;
    dfs(1, 0);
    for(int i = 1; i &lt;= m; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        if(a == 1)&#123;
            int x;
            cin &gt;&gt; x;
            if(depth[b] &amp; 1) add(l[b], x), add(r[b] + 1, -x);
            else add(l[b], -x), add(r[b] + 1, x);
        &#125;else&#123;
            int x = sum(l[b]);
            if(depth[b] &amp; 1) cout &lt;&lt; val[b] + x &lt;&lt; &#39;\n&#39;;
            else cout &lt;&lt; val[b] - x &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul><li>$pushup$<ul><li>由子节点更新父节点。</li><li>单点修改</li></ul></li><li>$pushdown$ （懒标记、延迟标记）<ul><li>由父节点更新子节点。</li><li>区间修改</li><li>例如： $add$ 懒标记，给以当前节点为根的子树中的每一个节点加上 $add$ 这个数（不包含根节点）<ul><li><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></li><li><code>right.add += root.add, right.sum += (right.r - right.l + 1) * root.add</code></li><li><code>root.add = 0</code></li></ul></li></ul></li><li>除最后一层是满二叉树，子区间划分 $mid &#x3D; \left \lfloor \frac{l + r}{2} \right \rfloor$ 即 $[L, mid],[mid + 1, R]$，可以用一维数组存整棵树，最多由 $2n - 1 + 2n$ 个点，故需要开 4 倍的空间。</li><li>扫描线法</li><li>操作<ul><li><code>pushup()</code></li><li><code>pushdown()</code></li><li><code>build()</code> 将一段区间初始化为线段树。</li><li><code>modify()</code> 修改单点、修改区间（延迟更新）。</li><li><code>query()</code></li></ul></li></ul><pre><code class="cpp">build(int u, int l, int r)&#123;
    tr[u].l = l, tr[u].r = r;
    if(l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u); // 一般于此写 pushup 操作
&#125;
</code></pre><h3 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h3><ul><li>通常来说，线段树占用空间是总区间长 $n$ 的常数倍，空间复杂度是 $O(n)$。然而，有时候 $n$ 很巨大，而我们又不需要使用所有的节点，这时便可以动态开点——不再一次性建好树，而是一边修改、查询一边建立。设总查询次数为 $m$，则这样的总空间复杂度为 $O(m;log;n)$。</li><li>比起普通线段树，动态开点线段树有一个优势，它能够处理零或负数位置。此时，求 $mid$ 时不能用 $(cl + cr) &#x2F; 2$，而要用 $(cl + cr - 1) &#x2F; 2$。</li><li>通常用在没有提供初始数据的场合（例如初始全0），这时更能显示出优势。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
#define val(x) tr[x].val
#define mark(x) tr[x].mark
// N 一般能开多大开多大，例如内存限制 128M 时可以开到八百万左右
const int N = 8e6;
int L = 1, R = 1e5, cnt = 1;
struct Node&#123;
    int ls, rs;
    LL val, mark;
&#125;tr[N];
void push_down(int p, int len)&#123;
    if(len &lt;= 1) return;
    if(!ls(p)) ls(p) = ++cnt;
    if(!rs(p)) rs(p) = ++cnt;
    val(ls(p)) += mark(p) * (len / 2);
    mark(ls(p)) += mark(p);
    val(rs(p)) += mark(p) * (len - len / 2);
    mark(rs(p)) += mark(p);
    mark(p) = 0;
&#125;
LL query(int u, int l, int r, int cl = L, int cr = R)&#123;
    if(cl &gt;= l &amp;&amp; cr &lt;= r) return val(u);
    push_down(u, cr - cl + 1);
    LL mid = (cl + cr - 1) / 2, ans = 0;
    if(l &lt;= mid) ans += query(ls(u), l, r, cl, mid);
    if(r &gt; mid) ans += query(rs(u), l, r, mid + 1, cr);
    return ans;
&#125;
void update(int l, int r, int d, int u = 1, int cl = L, int cr = R)&#123;
    if(cl &gt;= l &amp;&amp; cr &lt;= r)&#123;
        val(u) += d * (cr - cl + 1);
        mark(u) += d;
        return;
    &#125;
    push_down(u, cr - cl + 1);
    LL mid = (cl + cr - 1) / 2;
    if(l &lt;= mid) update(l, r, d, ls(u), cl, mid);
    if(r &gt; mid) update(l, r, d, rs(u), mid + 1, cr);
    val(u) = val(ls(u)) + val(rs(u));
&#125;
</code></pre><h3 id="最大数-🌸"><a href="#最大数-🌸" class="headerlink" title="最大数 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI3Ny8=">最大数</span> 🌸</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 200010;
int m, p;
struct Node
&#123;
    int l, r;
    int v;      // 区间[l, r]中的最大值
&#125;tr[N * 4];

void pushup(int u)&#123;     // 由子节点的信息，更新父节点的信息
    tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
&#125;
int query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].v;    // 区间[l, r]在当前节点的区间内
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    int v = 0;
    if(l &lt;= mid) v = query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) v = max(v, query(u &lt;&lt; 1 | 1, l, r));
    return v;
&#125;
void modify(int u, int x, int v)&#123;
    if(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;
    else&#123;
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(x &lt;= mid) modify(u &lt;&lt; 1, x, v);
        else modify(u &lt;&lt; 1 | 1, x, v);
        pushup(u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n = 0, last = 0;
    cin &gt;&gt; m &gt;&gt; p;
    build(1, 1, m);
    int x;
    while(m--)&#123;
        char op;
        cin &gt;&gt; op &gt;&gt; x;
        if(op == &#39;Q&#39;)&#123;
            last = query(1, n - x + 1, n);
            cout &lt;&lt; last &lt;&lt; endl;
        &#125;else&#123;
            modify(1, n + 1, ((long long)last + x) % p);
            n++;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="你能回答这些问题吗-🌸"><a href="#你能回答这些问题吗-🌸" class="headerlink" title="你能回答这些问题吗 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ2Lw==">你能回答这些问题吗</span> 🌸</h3><ul><li>维护每个区间后缀最大和，前缀最大和，区间和，区间最大子段和。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 500010;
int n, m;
int w[N];
struct Node
&#123;
    int l, r;
    int sum, lmax, rmax, tmax;
&#125;tr[N * 4];
void pushup(Node &amp;u, Node &amp;l, Node &amp;r)&#123;
    u.sum = l.sum + r.sum;
    u.lmax = max(l.lmax, l.sum + r.lmax);
    u.rmax = max(r.rmax, r.sum + l.rmax);
    u.tmax = max(max(l.tmax, r.tmax), l.rmax + r.lmax);
&#125;
void pushup(int u)&#123;
    pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);
&#125;
void build(int u, int l, int r)&#123;
    if(l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;
    else&#123;
        tr[u] = &#123;l, r&#125;;
        int mid = (l + r) &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
&#125;
void modify(int u, int x, int v)&#123;
    if(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;
    else&#123;
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(x &lt;= mid) modify(u &lt;&lt; 1, x, v);
        else modify(u &lt;&lt; 1 | 1, x, v);
        pushup(u);
    &#125;
&#125;
Node query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u];
    else&#123;
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(r &lt;= mid) return query(u &lt;&lt; 1, l, r);
        else if(l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r);
        else&#123;
            auto left = query(u &lt;&lt; 1, l, r);
            auto right = query(u &lt;&lt; 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    build(1, 1, n);
    int x, y;
    while(m--)&#123;
        int op;
        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;
        if(op == 1)&#123;
            if(x &gt; y) swap(x, y);
            cout &lt;&lt; query(1, x, y).tmax &lt;&lt; endl;
        &#125;else&#123;
            modify(1, x, y);
        &#125;
    &#125;
&#125;
</code></pre><h3 id="区间最大公约数-🌸"><a href="#区间最大公约数-🌸" class="headerlink" title="区间最大公约数 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ3Lw==">区间最大公约数</span> 🌸</h3><ul><li>最大公约数<ul><li>一定存在 $(x, y, z) ; &#x3D; ; (x, y - x, z - y)$</li><li>用线段树维护所有差分的值。单点修改，区间查询。</li><li>$gcd(a[l], gcd(b[l + 1], b[l + 2], \cdots b[r]))$</li></ul></li><li>区间 $[l, r]$ 增加一个数<ul><li>差分思想，将区间加减变成单点加减。</li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzEwNDcv">详细题解</span></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 500010;
int n, m;
LL w[N];
struct Node&#123;
    int l, r;
    LL sum, d;
&#125;tr[N * 4];
LL gcd(LL a, LL b)&#123;
    return b == 0 ? a : gcd(b, a % b);
&#125;
void pushup(Node &amp;u, Node &amp;l, Node &amp;r)&#123;
    u.sum = l.sum + r.sum;
    u.d = gcd(l.d, r.d);
&#125;
void pushup(int u)&#123;
    pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);
&#125;
void build(int u, int l, int r)&#123;
    if(l == r)&#123;
        LL b = w[r] - w[r - 1];
        tr[u] = &#123;l, r, b, b&#125;;
    &#125;else&#123;
        tr[u] = &#123;l, r&#125;;
        int mid = (l + r) &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
&#125;
void modify(int u, int x, LL v)&#123;
    if(tr[u].l == x &amp;&amp; tr[u].r == x)&#123;
        LL b = tr[u].sum + v;
        tr[u] = &#123;x, x, b, b&#125;;
    &#125;else&#123;
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(x &lt;= mid) modify(u &lt;&lt; 1, x, v);
        else modify(u &lt;&lt; 1 | 1, x, v);
        pushup(u);
    &#125;
&#125;
Node query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u];
    else&#123;
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(r &lt;= mid) return query(u &lt;&lt; 1, l, r);
        else if(l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r);
        else&#123;
            auto left = query(u &lt;&lt; 1, l, r);
            auto right = query(u &lt;&lt; 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    build(1, 1, n);
    
    int l, r;
    LL d;
    char op;
    while(m--)&#123;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op == &#39;Q&#39;)&#123;
            auto left  = query(1, 1, l);
            Node right(&#123;0, 0, 0, 0&#125;);
            if(l + 1 &lt;= r) right = query(1, l + 1, r);
            cout &lt;&lt; abs(gcd(left.sum, right.d)) &lt;&lt; endl;    // 需要正数
        &#125;else&#123;
            cin &gt;&gt; d;
            modify(1, l, d);
            if(r + 1 &lt;= n) modify(1, r + 1, -d);
        &#125;
    &#125;
&#125;
</code></pre><h3 id="一个简单的整数问题-Ⅱ-🌸-1"><a href="#一个简单的整数问题-Ⅱ-🌸-1" class="headerlink" title="一个简单的整数问题 Ⅱ 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ0Lw==">一个简单的整数问题 Ⅱ</span> 🌸</h3><ul><li>信息<ul><li>$sum$ 如果考虑当前节点及子节点上的所有标记，当前区间和是多少。</li><li>$add$ 懒标记，给以当前节点为根的子树中的每一个节点加上 $add$ 这个数（不包含根节点）<ul><li><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></li><li><code>right.add += root.add, right.sum += (right.r - right.l + 1) * root.add</code></li><li><code>root.add = 0</code></li></ul></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010;
int n, m;
int w[N];
struct Node&#123;
    int l, r;
    LL sum, add;
&#125;tr[N * 4];
void pushup(int u)&#123;
    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
&#125;
void pushdown(int u)&#123;
    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];
    if(root.add)&#123;
        left.add += root.add, left.sum += (LL)(left.r - left.l + 1) * root.add;
        right.add += root.add, right.sum += (LL)(right.r - right.l + 1) * root.add;
        root.add = 0;
    &#125;
&#125;
void build(int u, int l, int r)&#123;
    if(l == r) tr[u] = &#123;l, r, w[l], 0&#125;;
    else&#123;
        tr[u] = &#123;l, r&#125;;
        int mid = (l + r) &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
&#125;
void modify(int u, int l, int r, int d)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        tr[u].sum += (LL)(tr[u].r - tr[u].l + 1) * d;
        tr[u].add += d;
    &#125;else&#123;      // 分裂
        pushdown(u);
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, d);
        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d);
        pushup(u);
    &#125;
&#125;
LL query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    LL sum = 0;
    if(l &lt;= mid) sum = query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) sum += query(u &lt;&lt; 1 | 1, l, r);
    return sum;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    build(1, 1, n);
    char op;
    int l, r, d;
    while(m--)&#123;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op == &#39;C&#39;)&#123;
            cin &gt;&gt; d;
            modify(1, l, r, d);
        &#125;else&#123;
            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="亚特兰蒂斯-🌸🌸"><a href="#亚特兰蒂斯-🌸🌸" class="headerlink" title="亚特兰蒂斯 🌸🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ5Lw==">亚特兰蒂斯</span> 🌸🌸</h3><ul><li>在 $y$ 轴建立线段树，每一个矩形的左边权值为 $1$，右边权值为 $-1$</li><li>线段树中的节点信息<ul><li>$cnt$ 当前区间整个被覆盖次数</li><li>$len$ 不考虑祖先节点 $cnt$ 的前提下，$cnt &gt; 0$ 的区间总长。</li></ul></li><li>本题考虑扫描线的特殊性质<ul><li>永远只考虑根节点的信息，即 <code>query</code> 时不会调用 <code>pushdown</code></li><li>所有操作都是成对出现，且先加后减</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010;
struct Segment&#123;
    double x, y1, y2;
    int k;
    bool operator &lt; (const Segment &amp;t) const&#123;
        return x &lt; t.x;
    &#125;
&#125;seg[N * 2];
struct Node&#123;
    int l, r;
    int cnt;
    double len;
&#125;tr[N * 8];
vector&lt;double&gt; origin;

int find(double y)&#123;
    return lower_bound(origin.begin(), origin.end(), y) - origin.begin();
&#125;
void pushup(int u)&#123;
    if(tr[u].cnt) tr[u].len = origin[tr[u].r + 1] - origin[tr[u].l];
    else if(tr[u].l != tr[u].r) tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len;
    else tr[u].len = 0;
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r, 0, 0&#125;;
    if(l != r)&#123;
        int mid = (l + r) &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r);
    &#125;
&#125;
void modify(int u, int l, int r, int k)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        tr[u].cnt += k;
        pushup(u);
    &#125;else&#123;
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, k);
        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k);
        pushup(u);
    &#125;
&#125;
void solve(int n)&#123;
    origin.clear();
    for(int i = 0, j = 0; i &lt; n; i++)&#123;
        double x1, y1, x2, y2;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;
        seg[j++] = &#123;x1, y1, y2, 1&#125;;
        seg[j++] = &#123;x2, y1, y2, -1&#125;;
        origin.push_back(y1), origin.push_back(y2);
    &#125;
    sort(origin.begin(), origin.end());
    origin.erase(unique(origin.begin(), origin.end()), origin.end());
    build(1, 0, origin.size() - 2);
    sort(seg, seg + n * 2);
    double ans = 0;
    for(int i = 0; i &lt; n * 2; i++)&#123;
        if (i &gt; 0) ans += tr[1]. len * (seg[i]. x - seg[i - 1]. x);
        modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k);
    &#125;
    cout &lt;&lt; &quot;Total explored area: &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; endl;
    cout &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t = 1, n;
    while(cin &gt;&gt; n &amp;&amp; n)&#123;
        cout &lt;&lt; &quot;Test case #&quot; &lt;&lt; t++ &lt;&lt; endl;
        solve(n);
    &#125;
&#125;
</code></pre><h3 id="维护序列-🌸"><a href="#维护序列-🌸" class="headerlink" title="维护序列 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI3OS8=">维护序列</span> 🌸</h3><ul><li>先乘后加</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010;
int n, p, m;
int w[N];
struct Node&#123;
    int l, r;
    int sum, add, mul;
&#125;tr[N * 4];

void pushup(int u)&#123;
    tr[u].sum = (tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum) % p;
&#125;
void eval(Node &amp;t, int add, int mul)&#123;
    t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + 1) * add) % p;
    t.mul = ((LL)t.mul * mul) % p;
    t.add = ((LL)t.add * mul + add) % p;
&#125;
void pushdown(int u)&#123;
    eval(tr[u &lt;&lt; 1], tr[u].add, tr[u].mul);
    eval(tr[u &lt;&lt; 1 | 1], tr[u].add, tr[u].mul);
    tr[u].add = 0, tr[u].mul = 1;
&#125;
void build(int u, int l, int r)&#123;
    if(l == r) tr[u] = &#123;l, r, w[r], 0, 1&#125;;
    else&#123;
        tr[u] = &#123;l, r, 0, 0, 1&#125;;
        int mid = (l + r) &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
&#125;
void modify(int u, int l, int r, int add, int mul)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) eval(tr[u], add, mul);
    else&#123;
        pushdown(u);
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, add, mul);
        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, add, mul);
        pushup(u);
    &#125;
&#125;
int query(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
    pushdown(u);
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    int sum = 0;
    if(l &lt;= mid) sum = query(u &lt;&lt; 1, l, r);
    if(r &gt; mid) sum = (sum + query(u &lt;&lt; 1 | 1, l, r)) % p;
    return sum;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; p;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    build(1, 1, n);

    cin &gt;&gt; m;
    while(m--)&#123;
        int t, l, r, d;
        cin &gt;&gt; t &gt;&gt; l &gt;&gt; r;
        if(t == 1)&#123;
            cin &gt;&gt; d;
            modify(1, l, r, 0, d);
        &#125;else if(t == 2)&#123;
            cin &gt;&gt; d;
            modify(1, l, r, d, 1);
        &#125;else&#123;
            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h2><ul><li>$trie$ 的可持久化</li><li>线段树的可持久化–主席树</li><li>可持久化的<strong>前提</strong>是本身的拓扑结构不变</li><li>解决什么样的问题？<ul><li>可以存下来数据结构的所有历史版本</li><li>核心思想<ul><li>只记录每个版本与前一个版本不同的地方</li></ul></li></ul></li></ul><h3 id="最大异或和-🌸🌸🌸"><a href="#最大异或和-🌸🌸🌸" class="headerlink" title="最大异或和 🌸🌸🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI3OS8=">最大异或和</span> 🌸🌸🌸</h3><ul><li>可持久化 $trie$ 树</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzQ2NTM0Lw==">详细题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUxNDE5Lw==">代码详解</span></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 600010, M = N * 25;
int n, m;
int s[N];
int tr[M][2];
int max_id[M];
int root[N], idx;
// i是第i个插入的数的i, p是上一个插入的数的节点号, q是当前节点号, k是现在取到第k位
void insert(int i, int k, int p, int q)&#123;
    if(k &lt; 0)&#123;
        max_id[q] = i;  // 记录当前节点(可能会被后面公用)所能到达的最大范围i
        return;
    &#125;
    int v = s[i] &gt;&gt; k &amp; 1;
    if(p) tr[q][v ^ 1] = tr[p][v ^ 1];  // 相当于复制
    tr[q][v] = ++idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
&#125;
int query(int r, int C, int L)&#123;
    int p = r;
    for(int i = 23; i &gt;= 0; i--)&#123;
        int v = C &gt;&gt; i &amp; 1;
        if(max_id[tr[p][v ^ 1]] &gt;= L) p = tr[p][v ^ 1];
        else p = tr[p][v];
    &#125;
    return C ^ s[max_id[p]];
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    max_id[0] = -1;
    root[0] = ++idx;
    insert(0, 23, 0, root[0]);
    for(int i = 1; i &lt;= n; i++)&#123;
        int x;
        cin &gt;&gt; x;
        s[i] = s[i - 1] ^ x;
        root[i] = ++idx;
        insert(i, 23, root[i - 1], root[i]);
    &#125;
    char op;
    int l, r, x;
    while(m--)&#123;
        cin &gt;&gt; op;
        if(op == &#39;A&#39;)&#123;
            cin &gt;&gt; x;
            n++;
            s[n] = s[n - 1] ^ x;
            root[n] = ++idx;
            insert(n, 23, root[n - 1], root[n]);
        &#125;else&#123;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
            cout &lt;&lt; query(root[r - 1], x ^ s[n], l - 1) &lt;&lt; endl;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="第k小数-🌸🌸🌸"><a href="#第k小数-🌸🌸🌸" class="headerlink" title="第k小数 🌸🌸🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU3Lw==">第k小数</span> 🌸🌸🌸</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUxNDU2Lw==">题解</span></li><li>可持久化线段树<ul><li>难以进行区间修改操作</li></ul></li><li>离散化</li><li>在数值上建立线段树，维护每个数值区间中一共有多少个数</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, M = 10010;
int n, m;
int a[N];
vector&lt;int&gt; nums;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N * 4 + N * 17];
int root[N], idx;

int find(int x)&#123;
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
&#125;
int build(int l, int r)&#123;
    int p = ++idx;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
&#125;
int insert(int p, int l, int r, int x)&#123;
    int q = ++idx;
    tr[q] = tr[p];
    if(l == r)&#123;
        tr[q].cnt++;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
&#125;
int query(int q, int p, int l, int r, int k)&#123;
    if(l == r) return r;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k);
    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;
    sort(nums.begin(), nums.end());
    nums.resize(unique(nums.begin(), nums.end()) - nums.begin());
    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i++)&#123;
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));
    &#125;
    while(m--)&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl;
    &#125;
&#125;
</code></pre><h3 id="可持久化线段树模板"><a href="#可持久化线段树模板" class="headerlink" title="可持久化线段树模板"></a>可持久化线段树模板</h3><ul><li>例题：区间 k 个数最大和</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 200010, M = 20010;
int n, m, k, x;
int a[N];
vector&lt;int&gt; nums;
struct Node&#123;
    int l, r, cnt;
    LL sum, val;        // cnt 记录出现次数，sum 记录和，val 记录值
&#125;tr[N * 40];
int root[N], idx;

int find(int x)&#123;
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
&#125;
int build(int l, int r)&#123;
    int p = ++idx;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
&#125;
int insert(int p, int l, int r, int x, int val)&#123;
    int q = ++idx;
    tr[q] = tr[p];
    tr[q].cnt++, tr[q].sum += val;
    if(l == r)&#123;
        tr[q].val = val;
        return q;
    &#125;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x, val);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x, val);
    return q;
&#125;
// 查询前 k 大值，因为节点存的是值，所以找大的，先从右边找。
LL query(int q, int p, int l, int r, int k)&#123;
    if(l == r) return tr[q].val * k;    // 因为一个值可能出现多次，那么计算答案的时候要把他们都算上
    int cnt = tr[tr[q].r].cnt - tr[tr[p].r].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[q].r, tr[p].r, mid + 1, r, k);
    else return query(tr[q].l, tr[p].l, l, mid, k - cnt) + tr[tr[q].r].sum - tr[tr[p].r].sum;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;
    for(int i = 1; i &lt; nums.size(); i++)&#123;
        nums[i] += nums[i - 1];
    &#125;
/*     sort(nums.begin(), nums.end());
    nums.resize(unique(nums.begin(), nums.end()) - nums.begin()); */
    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i++)&#123;
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]), a[i]);
    &#125;
    while(m--)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        if(nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &gt;= x)&#123;
            cout &lt;&lt; &quot;Y\n&quot;;
        &#125;else&#123;
            cout &lt;&lt; &quot;N\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="动态开点可持久化线段树"><a href="#动态开点可持久化线段树" class="headerlink" title="动态开点可持久化线段树"></a>动态开点可持久化线段树</h3><ul><li>例题为 区间第 k 小</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, INF = 1e9;
struct Node&#123;
    int l, r;
    int cnt;
&#125;tr[N &lt;&lt; 5];
int n, m, idx , root[N], a[N];

void insert(int &amp;u, int v, int l, int r, int x)&#123;
    u = ++ idx;
    tr[u] = tr[v];
    tr[u].cnt ++ ;
    if(l == r) return ;
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) insert(tr[u].l, tr[v].l, l, mid, x);
    else insert(tr[u].r, tr[v].r, mid + 1, r, x);
&#125;

int query(int p, int q, int l, int r, int k)&#123;
    if(l == r) return l;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt) return query(tr[p].l, tr[q].l, l, mid, k);
    if(k &gt; cnt) return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
&#125;

int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1 ; i &lt;= n ; i ++ )&#123;
        cin &gt;&gt; a[i];
        insert(root[i], root[i - 1], -INF, INF, a[i]);
    &#125;
    for(int i = 1 ; i &lt;= m ; i ++ )&#123;
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; query(root[l - 1], root[r], -INF, INF, k) &lt;&lt; endl;
    &#125;
    
    return 0;
&#125;
</code></pre><h2 id="Treap-平衡树"><a href="#Treap-平衡树" class="headerlink" title="Treap - 平衡树"></a>Treap - 平衡树</h2><ul><li>Binary Search Tree + heap<ul><li>BST，当前节点的左子树中的任何一个点的权值小于当前节点的权值；当前节点的右子树中的任何一个点的权值大于当前节点的权值<ul><li>动态维护有序序列</li></ul></li></ul></li><li>支持插入、删除、找前驱&#x2F;后继、最大&#x2F;最小、求某个值的排名、求排名是 $k$ 的数是哪个、比某个数小的最大值、比某个数大的最小值</li></ul><h3 id="AcWing-普通平衡树"><a href="#AcWing-普通平衡树" class="headerlink" title="AcWing|普通平衡树"></a><a href="">AcWing|普通平衡树</a></h3><ul><li>模板</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, INF = 0x3f3f3f3f;
struct Node&#123;
    int l, r;
    int key;    // 二叉搜索树权值
    int val;    // 大根堆的随机权值
    int cnt, sz;
&#125;tr[N];

// Treap 在以关键码构成二叉搜索树的同时, 还满足堆的性质, 且堆的权重随机, 这使得 Treap 的期望复杂度是 log n

int root, idx, n;
// 更新父节点 sz 信息
void pushup(int p)&#123;
    tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz + tr[p].cnt;
&#125;
// 创建一个叶节点
int get_node(int key)&#123;
    tr[++idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].sz = 1;
    return idx;
&#125;
//初始化平衡树 左右哨兵 
//如果查询的结果可能不存在，那加上哨兵之后可以保证查询的结果一定存在，就不需要在查询过程中特判无解
void build()&#123;
    get_node(-INF), get_node(INF);
    root = 1, tr[1].r = 2;
    pushup(root);
&#125;
// 右旋
void zig(int &amp;p)&#123;
    // 根变了, 传引用
    // 旋转的时候传 root, root 会变化,我们希望 root 还是真正的 root, 故用 root
    // p 始终指向根
    int q = tr[p].l;
    tr[p].l = tr[q].r;
    tr[q].r = p;
    p = q;
    pushup(tr[p].r);
    pushup(p);
    // 不需要更新 p 是因为看着右旋图, 右旋之前 y 左是 A + B , y 右是 C, 旋过之后实际上 y 左是 A, y 右是 B + C,
    // 但是不更新 p,由于有 tr[q].r = p, 相当于 y 的 size 由左侧的 A + B 和右侧的 C 构成, 不影响最终 size
    // 但是 p 的 r 要更新, 因为 r 由 B 和 C 构成( r 旋前只有 C )
&#125;
// 左旋
void zag(int &amp;p)&#123;
    int q = tr[p].r;
    tr[p].r = tr[q].l;
    tr[q].l = p;
    p = q;
    pushup(tr[p].l);
    pushup(p);
&#125;
// 插入值 key, 从根开始
void insert(int &amp;p, int key)&#123;   // p 是每一层根节点的指针
    if(!p) p = get_node(key);
    else if(tr[p].key == key) tr[p].cnt++;
    else if(tr[p].key &gt; key)&#123;
        // 当前节点值大于 key, 说明应该在左子树插入
        insert(tr[p].l, key);
        // 由于在左子树插入, 插入左侧后左子树 val 可能大于根节点, 左大右旋, 保证堆的性质
        if(tr[tr[p].l].val &gt; tr[p].val) zig(p);
    &#125;else&#123;
        insert(tr[p].r, key);
        if(tr[tr[p].r].val &gt; tr[p].val) zag(p);
    &#125;
    pushup(p);  // p 是每一层的根的指针, 自底向上更新 p   
&#125;
void remove(int &amp;p, int key)&#123;
    if(!p) return ;
    if(tr[p].key == key)&#123;
        if(tr[p].cnt &gt; 1) tr[p].cnt--;
        else if(tr[p].l || tr[p].r)&#123;
            // 当前节点只有一个可以且有左儿子或右儿子
            if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)&#123;
                // 只存在左儿子(左 val &gt; 右 val_0) 或左 val &gt; 右 val 
                zig(p);
                remove(tr[p].r, key);
            &#125;else&#123;
                // 若存在右儿子且左val&lt;右val 
                // 左儿子也可能不存在, 不存在的话左儿子的 val 就是 0 , 肯定 &lt;= 右儿子的 val ( val 最小为 0 ), 这个模板隐含了判存在操作
                zag(p);
                remove(tr[p].l, key);
            &#125;
        &#125;else&#123;
            // 不存在左右子树,是叶子节点
            p = 0;
        &#125;
    &#125;else if(tr[p].key &gt; key) remove(tr[p].l, key);
    else remove(tr[p].r, key);
    pushup(p);
&#125;
// 没有修改,不需要引用
// 通过数值找排名
int get_rank_by_key(int p, int key)&#123;
    if(!p) return 0;
    if(tr[p].key == key) return tr[tr[p].l].sz + 1; //左子树的 size + 1 (同样的数值中最靠左的)
    if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].sz + tr[p].cnt + get_rank_by_key(tr[p].r, key); // 去右边找的时候找的是在右子树中的排名, 需要加上左子树和根的 cnt
&#125;
// 通过排名找数值
int get_key_by_rank(int p, int rank)&#123;
    if(!p) return INF;
    if(tr[tr[p].l].sz &gt;= rank) return get_key_by_rank(tr[p].l, rank); // 左边的个数 &gt;=rank, 说明数值在左边
    if(tr[tr[p].l].sz + tr[p].cnt &gt;= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].sz - tr[p].cnt); // 去右子树中找数值, 排名应该先减去左子树 size + cnt
&#125;
// 找到严格小于key的最大数
int get_prev(int p, int key)&#123;
    if(!p) return -INF;
    if(tr[p].key &gt;= key) return get_prev(tr[p].l, key); // 当前大于 key, 右子树不考虑
    return max(tr[p].key, get_prev(tr[p].r, key));  // 左子树都小于 key 所以不如 key 更好, 所以考虑当前 key 和右子树

&#125;
// 找到严格大于key的最小数
int get_next(int p, int key)&#123;
    if(!p) return INF;
    if(tr[p].key &lt;= key)return get_next(tr[p].r, key); // 当前小于key, 左子树不考虑
    return min(tr[p].key, get_next(tr[p].l, key)); // 右子树都大于 key 所以不如 key 更好, 所以考虑当前 key 和左子树
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    build();
    int n;
    cin &gt;&gt; n;
    while(n--)&#123;
        int op, x;
        cin &gt;&gt; op &gt;&gt; x;
        if(op == 1) insert(root, x);
        else if(op == 2) remove(root, x);
        else if(op == 3) cout &lt;&lt; get_rank_by_key(root, x) - 1 &lt;&lt; &#39;\n&#39;;
        else if(op == 4) cout &lt;&lt; get_key_by_rank(root, x + 1) &lt;&lt; &#39;\n&#39;;
        else if(op == 5) cout &lt;&lt; get_prev(root, x) &lt;&lt; &#39;\n&#39;;
        else cout &lt;&lt; get_next(root, x) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h2 id="Splay-平衡树"><a href="#Splay-平衡树" class="headerlink" title="Splay 平衡树"></a>Splay 平衡树</h2><pre><code class="cpp">平衡二叉树
set/map 红黑树(代码长) == splay(代码适中,支持很多操作)
treap(有局限,一些操作做不了)
AVL
多叉树
B树 B+树

操作:
    左旋 
    右旋 (维护的是中序遍历不变)
             右旋
              -&gt;
         z           z
        /           //
       y           x    
      / \         / \\
     x   c       A   y
    / \            // \
   A   B           B   C
   AxByc           AxByc
             左旋
              -&gt;
   =线代表变得关系
   -代表不变的关系
   可以发现由于要维护中序遍历,最左和最右的关系是不变的
    插入
    查询
 每操作一个节点 均将该节点旋转到树根
splay(x,k) 将点x旋转至点k下
1   
       z      y    x
      /      / \    \ 
     y      x   z    y
    /                 \
   x                   z    
        先转y     转x
    每转一次x往上走两格 直到某个点下面为止
2     z       z   x
     /       /   / \
    y       x   y   z
     \     /
      x   y
       先转x     转x

插入
1  找到x插入位置
   把x转到根
2  将一个序列插到y的后面
    ---------------
            y z
    2.1 找y的后继z 
    2.2 将y转到根       splay(y,0)
    2.3 将z转到y的下面  spaly(z,y)
   y
    \
     z
    /
  null(因为z和y之间没有数,所以z左子树为空) 
   2.4 将序列插入到z的左子树 
删除
   -----------------
     L-1 L   R R+1
   1 将L-1转到根节点
   2 将R+1转到L-1下面
   此时R+1的左子树=[L,R]
   3 将R+1的左儿子置为空Null
本题
维护信息
   1 子树总点数 size 用于递归查找位置
   2 懒标记     flag 整个区间是否需要翻转

pushup(u)用两个儿子信息维护根节点信息
  tr[u].size = tr[u&lt;&lt;1].size+tr[u&lt;&lt;1|1].size
写在旋转最后

pushdown(u)下传懒标记,先更新子树
    swap(tr[u&lt;&lt;1],tr[u&lt;&lt;1|1])(要翻转整颗子树，要先把左右两个儿子翻转，然后递归翻转左右两棵子树)
    将标记下传 t[u&lt;&lt;1] = t[u&lt;&lt;1|1] = t[u]
    将当前标记清空  t[u] = 0
写在递归之前

splay保证中序遍历是当前序列的顺序



--------------------------------------------------------------------------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, m;
struct Node
&#123;
    int s[2], p, v;//儿子,父节点,编号
    int size, flag;//子树节点个数, 有没有翻转

    void init(int _v, int _p)
    &#123;
        v = _v, p = _p;
        size = 1;
    &#125;
&#125;tr[N];
int root, idx;

void pushup(int x)
&#123;
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
&#125;

void pushdown(int x)
&#123;
    // 如果当前子树需要翻转 48.34
    if (tr[x].flag)
    &#123;
        //要翻转整颗子树，要先把左右两个儿子翻转，然后递归翻转左右两棵子树
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;//翻转标记往下传
        tr[tr[x].s[1]].flag ^= 1;//翻转标记往下传
        tr[x].flag = 0;//当前标记清空
    &#125;
&#125;

/*
          z
         /
        y
       /
      x  
    k=0表示x是y的左儿子；k=1表示x是y的右儿子
         z           z
        /           //   --1
       y           x    
      / \         / \\   --2
     x   c       A   y
    / \      3--   // \
   A   B           B   C 
   AxByc           AxByc
             左旋
              -&gt;
   =线代表变得关系
   -代表不变的关系
   可以发现由于要维护中序遍历,最左和最右的关系是不变的
   体现在rotate中就三条边
   k代表左,k^1代表右
*/
void rotate(int x)
&#123;
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;  // k=0表示x是y的左儿子；k=1表示x是y的右儿子
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;// 边1 z原来的儿子y变为x  x的父节点变为z
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;// 边3 y的左儿子变为x的右儿子B,x的右儿子的父节点变为y
    tr[x].s[k ^ 1] = y, tr[y].p = x;// 边2 x的右儿子变为y,y的父节点变为x
    pushup(y), pushup(x);// A,B,C三个点信息没变,但x,y子树信息变了,又y在x下面,所以先维护更新y子树,再维护更新x子树
&#125;
/*
1   
       z      y    x
      /      / \    \ 
     y      x   z    y
    /                 \
   x                   z    
        先转y     转x
    每转一次x往上走两格 直到某个点下面为止
2     z       z   x
     /       /   / \
    y       x   y   z
     \     /
      x   y
       先转x     转x
*/
void splay(int x, int k)
&#123;
    while (tr[x].p != k)
    &#123;
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
        // 如果是折线关系  ==  x是y的右/左儿子 且 y是z的左/右儿子  一0一1
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);//折线rotate两次x
            else rotate(y);//直线rotate 一次y一次x
        rotate(x);
    &#125;
    if (!k) root = x;//如果k==0 根节点更新为x
&#125;
// 按大插右 小插左的二叉树插法 插入节点
void insert(int v)
&#123;
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];//一直往下递归直到u为null
    u = ++ idx;
    if (p) tr[p].s[v &gt; tr[p].v] = u;//如果有父节点,父节点儿子信息更新为u
    tr[u].init(v, p);//初始化点u的值和父节点
    splay(u, 0);//插入后将当前点u转到根节点上
&#125;
/*
                 k
                / \
 tr[u&lt;&lt;1].size    
 如果左子树个数&gt;=k 则去左子树里看
 如果左子树个数=k-1,则u就是中序遍历第k个点
 否则去右子树里看,k-=tr[u&lt;&lt;1].size-1
*/
int get_k(int k)
&#123;
    int u = root;
    while (true)
    &#123;
        pushdown(u);
        if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    &#125;
    return -1;//找不到返回-1
&#125;
//中序遍历
void output(int u)
&#123;
    pushdown(u);
    // 如果u有左儿子 先递归输出左儿子
    if (tr[u].s[0]) output(tr[u].s[0]);
    // 如果u不是哨兵输出当前点
    if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v);
    // 如果u有右儿子 递归输出右儿子
    if (tr[u].s[1]) output(tr[u].s[1]);
&#125;

int main()
&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt;= n + 1; i ++ ) insert(i);//插入哨兵 0,n+1 防止L-1和R+1越界
    while (m -- )
    &#123;
        int l, r;
        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
        //因为哨兵要翻转的从[L,R]变为[L+1,R+1] 则要找L和R+2作为L+1的前继和R+1的后继
        l = get_k(l), r = get_k(r + 2);
        // 左端点l转到根,右端点r转到左端点下面
        splay(l, 0), splay(r, l);
        // 只要将r的左子树[L+1,R+1]翻转
        tr[tr[r].s[0]].flag ^= 1;
    &#125;
    output(root);
    return 0;
&#125;
</code></pre><h3 id="P3391-文艺平衡树"><a href="#P3391-文艺平衡树" class="headerlink" title="P3391 | 文艺平衡树"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzOTE=">P3391 | 文艺平衡树</span></h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 100010, INF = 0x3f3f3f3f;
struct Node&#123;
    int s[2], p, v;
    int sz, flag;
    void init(int _v, int _p)&#123;
        v = _v, p = _p;
        sz = 1;
    &#125;
&#125;tr[N];
int root, idx, n, m;

void pushup(int x)&#123;
    tr[x].sz = tr[tr[x].s[0]].sz + tr[tr[x].s[1]].sz + 1;
&#125;
void pushdown(int x)&#123;
    if(tr[x].flag)&#123;
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;
        tr[tr[x].s[1]].flag ^= 1;
        tr[x].flag = 0;
    &#125;
&#125;
void rotate(int x)&#123;
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
&#125;
void splay(int x, int k)&#123;
    while(tr[x].p != k)&#123;
        int y = tr[x].p, z = tr[y].p;
        if(z != k)&#123;
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        &#125;
        rotate(x);
    &#125;
    if(!k) root = x;
&#125;
void insert(int v)&#123;
    int u = root, p = 0;
    while(u)&#123;
        p = u, u = tr[u].s[v &gt; tr[u].v];
    &#125;
    u = ++idx;
    if(p) tr[p].s[v &gt; tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
&#125;
int get_k(int k)&#123;
    int u = root;
    while(1)&#123;
        pushdown(u);
        if(tr[tr[u].s[0]].sz &gt;= k) u = tr[u].s[0];
        else if(tr[tr[u].s[0]].sz + 1 == k) return u;
        else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
    &#125;
    return -1;
&#125;
void output(int u)&#123;
    pushdown(u);
    if(tr[u].s[0]) output(tr[u].s[0]);
    if(tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) cout &lt;&lt; tr[u].v &lt;&lt; &quot; &quot;;
    if(tr[u].s[1]) output(tr[u].s[1]);
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt;= n + 1; i++)&#123;
        insert(i);
    &#125;
    while(m--)&#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        l = get_k(l), r = get_k(r + 2);
        splay(l, 0), splay(r, l);
        tr[tr[r].s[0]].flag ^= 1;
    &#125;
    output(root);
&#125;
</code></pre><h3 id="P3369-普通平衡树"><a href="#P3369-普通平衡树" class="headerlink" title="P3369 | 普通平衡树"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjk=">P3369 | 普通平衡树</span></h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, INF = 0x3f3f3f3f;
struct Node&#123;
    int s[2], p, v;
    int sz, flag;
    int cnt;

    void init(int _v, int _p)&#123;
        v = _v, p = _p;
        sz = 1;
        cnt = 1;
    &#125;
&#125;tr[N];
int root, idx;
void pushup(int u)&#123;
    tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + tr[u].cnt;
&#125;
void rotate(int x)&#123;
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
&#125;
void splay(int x, int k)&#123;
    while(tr[x].p != k)&#123;
        int y = tr[x].p, z = tr[y].p;
        if(z != k)&#123;
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        &#125;
        rotate(x);
    &#125;
    if(!k) root = x;
&#125;
void find(int x)&#123;
    int p = root;
    if(!p) return;
    while(tr[p].s[x &gt; tr[p].v] &amp;&amp; x != tr[p].v)&#123;
        p = tr[p].s[x &gt; tr[p].v];
    &#125;
    splay(p, 0);
&#125;
void insert(int x)&#123;
    int p = root, y = 0;
    while(p != 0 &amp;&amp; x != tr[p].v)&#123;
        y = p, p = tr[p].s[x &gt; tr[p].v];
    &#125;
    if(p != 0)&#123;
        tr[p].cnt++;
    &#125;else&#123;
        p = ++idx;
        if(y != 0) tr[y].s[x &gt; tr[y].v] = p;
        tr[p].init(x, y);
    &#125;
    splay(p, 0);
&#125;
int pre_next(int x, int st)&#123;
    find(x);
    int p = root;
    if(tr[p].v &gt; x &amp;&amp; st == 1)&#123;
        return p;
    &#125;
    if(tr[p].v &lt; x &amp;&amp; st == 0)&#123;
        return p;
    &#125;
    p = tr[root].s[st];
    while(tr[p].s[st ^ 1] != 0) p = tr[p].s[st ^ 1];
    return p;
&#125;
void remove(int x)&#123;
    int last = pre_next(x, 0);
    int next = pre_next(x, 1);
    splay(last, 0), splay(next, last);
    int k = tr[next].s[0];
    if(tr[k].cnt &gt; 1)&#123;
        tr[k].cnt--;
        splay(k, 0);
    &#125;else&#123;
        tr[next].s[0] = 0;
    &#125;
&#125;
int pos(int x)&#123;
    int p = root;
    if(tr[p].sz &lt; x)&#123;
        return -1;
    &#125;
    while(1)&#123;
        if(x &lt;= tr[tr[p].s[0]].sz)&#123;
            p = tr[p].s[0];
        &#125;else if(x &gt; tr[tr[p].s[0]].sz + tr[p].cnt)&#123;
            x -= tr[tr[p].s[0]].sz + tr[p].cnt;
            p = tr[p].s[1];
        &#125;else&#123;
            return p;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    insert(-INF), insert(INF);
    for(int i = 1; i &lt;= n; i++)&#123;
        int op, num;
        cin &gt;&gt; op &gt;&gt; num;
        if(op == 1)&#123;
            insert(num);
        &#125;else if(op == 2)&#123;
            remove(num);
        &#125;else if(op == 3)&#123;
            find(num);
            cout &lt;&lt; tr[tr[root].s[0]].sz &lt;&lt; &#39;\n&#39;;
        &#125;else if(op == 4)&#123;
            cout &lt;&lt; tr[pos(num + 1)].v &lt;&lt; &#39;\n&#39;;
        &#125;else if(op == 5)&#123;
            cout &lt;&lt; tr[pre_next(num, 0)].v &lt;&lt; &#39;\n&#39;;
        &#125;else&#123;
            cout &lt;&lt; tr[pre_next(num, 1)].v &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="POJ2828-Buy-Tickets"><a href="#POJ2828-Buy-Tickets" class="headerlink" title="POJ2828 | Buy Tickets"></a><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0vUE9KLTI4MjgjYXV0aG9yPUhVQ00yMDE3MzI=">POJ2828 | Buy Tickets</span></h3><ul><li>题意<ul><li>有 $N$ 个人排队，每一个人都有一个 $val$ 来对应，每一个后来人都会插入当前队伍的某一个位置 $pos$。要求把队伍最后的状态输出。</li></ul></li><li>分析<ul><li>用 splay 模拟一遍即可。</li></ul></li><li>代码</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 2e5 + 10;
int n, m;
struct Node&#123;
    int s[2], p, v;
    int sz, flag;
    void init(int _v, int _p)&#123;
        v = _v, p = _p;
        sz = 1;
    &#125;
&#125;tr[N];
int root, idx;
void pushup(int x)&#123;
    tr[x].sz = tr[tr[x].s[0]].sz + tr[tr[x].s[1]].sz + 1;
&#125;
void pushdown(int x)&#123;
    if(tr[x].flag)&#123;
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;
        tr[tr[x].s[1]].flag ^= 1;
        tr[x].flag = 0;
    &#125;
&#125;
void rotate(int x)&#123;
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
&#125;
void splay(int x, int k)&#123;
    while(tr[x].p != k)&#123;
        int y = tr[x].p, z = tr[y].p;
        if(z != k)&#123;
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        &#125;
        rotate(x);
    &#125;
    if(!k) root = x;
&#125;
int get_k(int k)&#123;
    int u = root;
    while(1)&#123;
        //pushdown(u);
        if(tr[tr[u].s[0]].sz &gt;= k) u = tr[u].s[0];
        else if(tr[tr[u].s[0]].sz + 1 == k) return u;
        else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
    &#125;
    return -1;
&#125;
void insert(int x, int v)&#123;
    if(!root)&#123;
        root = ++idx;
        tr[root].init(v, 0);
        return;
    &#125;
    if(!x)&#123;
        int u = root;
        while(tr[u].s[0]) u = tr[u].s[0];
        tr[u].s[0] = ++idx;
        tr[idx].init(v, u);
        splay(idx, 0);
        return;
    &#125;
    int k = get_k(x);
    splay(k, 0);
    root = ++idx;
    tr[root].init(v, 0);
    tr[root].s[1] = tr[k].s[1];
    tr[tr[k].s[1]].p = root;
    tr[k].s[1] = 0;
    tr[root].s[0] = k;
    tr[k].p = root;
    pushup(k), pushup(root);
&#125;
void output(int u)&#123;
    //pushdown(u);
    if(tr[u].s[0]) output(tr[u].s[0]);
    printf(&quot;%d &quot;, tr[u].v);
    if(tr[u].s[1]) output(tr[u].s[1]);
&#125;
int main()&#123;
    while(~scanf(&quot;%d&quot;, &amp;n))&#123;
        root = idx = 0;
        memset(tr, 0, sizeof tr);
        for(int i = 1; i &lt;= n; i++)&#123;
            int t, x;
            scanf(&quot;%d %d&quot;, &amp;t, &amp;x);
            insert(t, x);
        &#125;
        output(root);
        puts(&quot;&quot;);
    &#125;
&#125;
</code></pre><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><ul><li>参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vV0FNb25zdGVyL3AvMTAxMTg5MzQuaHRtbA==">莫队算法——从入门到黑题</span></li></ul><h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><ul><li>解决一段区间内不同数的个数</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 1e6 + 10;
inline int read()&#123;
    int x = 0, f = 1;
    char ch = getchar();
    while(!isdigit(ch))&#123;
        if(ch == &#39;-&#39;) f = -1;
        ch = getchar();
    &#125;
    while(isdigit(ch))&#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = getchar();
    &#125;
    return x * f;
&#125;
inline void write(int x)&#123;
    if(x &lt; 0)&#123;
        putchar(&#39;-&#39;);
        x = -x;
    &#125;
    if(x &gt; 9) write(x / 10);
    putchar(x % 10 + &#39;0&#39;);
&#125;
int sq;
struct query&#123;
    int l, r, id;
    // 奇偶化排序
    bool operator &lt; (const query &amp;o) const&#123;
        // 这里只需要知道每个元素归属哪个块，而块的大小都是 sqrt(n)，所以可以直接用 l/sq
        if(l / sq != o.l / sq)&#123;
            return l &lt; o.l;
        &#125;
        if(l / sq &amp; 1)&#123;
            return r &lt; o.r;
        &#125;
        return r &gt; o.r;
    &#125;
&#125;Q[N];
int A[N], ans[N], cnt[N], cur, l = 1, r = 0;
inline void add(int p)&#123;
    if(cnt[A[p]] == 0)&#123;
        cur++;
    &#125;
    cnt[A[p]]++;
&#125;
inline void del(int p)&#123;
    cnt[A[p]]--;
    if(cnt[A[p]] == 0)&#123;
        cur--;
    &#125;
&#125;
int main()&#123;
    int n = read();
    sq = sqrt(n);
    for(int i = 1; i &lt;= n; i++)&#123;
        A[i] = read();
    &#125;
    int q = read();
    for(int i = 0; i &lt; q; i++)&#123;
        Q[i].l = read();
        Q[i].r = read();
        Q[i].id = i;
    &#125;
    sort(Q, Q + q);
    for(int i = 0; i &lt; q; i++)&#123;
        while(l &gt; Q[i].l) add(--l);
        while(r &lt; Q[i].r) add(++r);
        while(l &lt; Q[i].l) del(l++);
        while(r &gt; Q[i].r) del(r--);
        ans[Q[i].id] = cur;
    &#125;
    for(int i = 0; i &lt; q; i++)&#123;
        write(ans[i]);
        putchar(&#39;\n&#39;);
    &#125;
&#125;
</code></pre><h3 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h3><ul><li>加入时间戳，可以做到单点修改</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e6 + 100;
int a[N], cnt[N], ans[N], bel[N];
struct Query&#123;
    int l, r, time, id;
&#125;q[N];
struct Modify&#123;
    int pos, color, last;
&#125;c[N];
int sz;
bool cmp(Query a, Query b)&#123;
    if(bel[a.l] ^ bel[b.l])&#123;
        return bel[a.l] &lt; bel[b.l];
    &#125;else&#123;
        if(bel[a.r] ^ bel[b.r])&#123;
            return bel[a.r] &lt; bel[b.r];
        &#125;else&#123;
            return a.time &lt; b.time;
        &#125;
    &#125;
&#125;
inline int read()&#123;
    int x = 0, f = 1;
    char ch = getchar();
    while(!isdigit(ch))&#123;
        if(ch == &#39;-&#39;) f = -1;
        ch = getchar();
    &#125;
    while(isdigit(ch))&#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = getchar();
    &#125;
    return x * f;
&#125;
int cntq, cntc, cur;
inline void add1(int p)&#123;
    if(cnt[a[p]] == 0)&#123;
        cur++;
    &#125;
    cnt[a[p]]++;
&#125;
inline void del1(int p)&#123;
    cnt[a[p]]--;
    if(cnt[a[p]] == 0)&#123;
        cur--;
    &#125;
&#125;
int main()&#123;
    int n = read(), m = read();
    sz = pow(n, 2.0 / 3.0);
    int bnum = ceil((double)n / sz);
    for(int i = 1; i &lt;= bnum; ++i)&#123;
        for(int j = (i - 1) * sz + 1; j &lt;= i * sz; ++j)&#123;
            bel[j] = i;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; ++i)&#123;
        a[i] = read();
    &#125;
    for(int i = 1; i &lt;= m; ++i)&#123;
        char op[10];
        scanf(&quot;%s&quot;, op);
        if(op[0] == &#39;Q&#39;)&#123;
            q[++cntq].l = read();
            q[cntq].r = read();
            q[cntq].time = cntc;
            q[cntq].id = cntq;
        &#125;else if(op[0] == &#39;R&#39;)&#123;
            c[++cntc].pos = read();
            c[cntc].color = read();
        &#125;
    &#125;
    sort(q + 1, q + cntq + 1, cmp);
    int l = 1, r = 0, ctime = 0;
    for(int i = 1; i &lt;= cntq; ++i)&#123;
        int ql = q[i].l, qr = q[i].r, qtime = q[i].time;
        while(l &lt; ql) del1(l++);
        while(l &gt; ql) add1(--l);
        while(r &lt; qr) add1(++r);
        while(r &gt; qr) del1(r--);
        while(ctime &lt; qtime)&#123;
            ctime++;
            if(ql &lt;= c[ctime].pos &amp;&amp; c[ctime].pos &lt;= qr)&#123;
                cur -= !--cnt[a[c[ctime].pos]] - !cnt[c[ctime].color]++;
            &#125;
            swap(a[c[ctime].pos], c[ctime].color);
        &#125;
        while(qtime &lt; ctime)&#123;
            if(ql &lt;= c[ctime].pos &amp;&amp; c[ctime].pos &lt;= qr)&#123;
                cur -= !--cnt[a[c[ctime].pos]] - !cnt[c[ctime].color]++;
            &#125;
            swap(a[c[ctime].pos], c[ctime].color);
            ctime--;
        &#125;
        ans[q[i].id] = cur;
    &#125;
    for(int i = 1; i &lt;= cntq; ++i)&#123;
        printf(&quot;%d\n&quot;, ans[i]);
    &#125;
&#125;
</code></pre><h2 id="珂朵莉树"><a href="#珂朵莉树" class="headerlink" title="珂朵莉树"></a>珂朵莉树</h2><ul><li>优雅的暴力</li><li>珂朵莉树的适用范围是有<strong>区间赋值</strong>操作且<strong>数据随机</strong>的题目。其实珂朵莉树看上去并不像是树状数据结构，但因为一般要用到<code>std::set</code>，而<code>std::set</code>是用红黑树实现的，所以也不算名不副实。在随机数据下，珂朵莉树可以达到 $O(n;log⁡;log⁡;n)$ 的复杂度（参见<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDI3ODYwNzE=">这篇文章</span>）。</li><li>珂朵莉树的思想在于随机数据下的区间赋值操作很可能让大量元素变为同一个数。所以我们以三元组<code>&lt;l,r,v&gt;</code>的形式保存数据（区间 $[l,r]$ 中的元素的值都是 $v$）：</li></ul><h3 id="CF896C-Willem-Chtholly-and-Seniorious"><a href="#CF896C-Willem-Chtholly-and-Seniorious" class="headerlink" title="CF896C | Willem, Chtholly and Seniorious"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y4OTZD">CF896C | Willem, Chtholly and Seniorious</span></h3><pre><code class="cpp">// 珂朵莉树
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;

struct Node&#123;
    LL l, r;
    mutable LL v;
    Node(LL l, LL r, LL v) : l(l), r(r), v(v) &#123;&#125;
    bool operator &lt; (const Node &amp;rhs) const&#123;
        return l &lt; rhs.l;
    &#125;
&#125;;

LL qpow(LL a, LL b, LL mod)&#123;
    LL ans = 1;
    a %= mod;
    while(b)&#123;
        if(b &amp; 1) ans = ans * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    &#125;
    return ans;
&#125;

set&lt;Node&gt; tr;
// 分裂区间
auto split(LL pos)&#123;
    auto it = tr.lower_bound(Node(pos, 0, 0));
    if(it != tr.end() &amp;&amp; it-&gt;l == pos)&#123;
        return it;
    &#125;
    it--;
    auto [l, r, v] = *it;
    tr.erase(it);
    tr.insert(&#123;l, pos - 1, v&#125;);
    return tr.insert(&#123;pos, r, v&#125;).first;
&#125;
// 赋值
void assign(LL l, LL r, LL v)&#123;
    // 强调顺序
    auto end = split(r + 1), begin = split(l);
    tr.erase(begin, end);
    tr.insert(&#123;l, r, v&#125;);
&#125;
// 区间加
void add(LL l, LL r, LL v)&#123;
    auto end = split(r + 1), begin = split(l);
    for(auto it = begin; it != end; it++)&#123;
        it-&gt;v += v;
    &#125;
&#125;
// 求区间 k 大值
LL kth(LL l, LL r, LL k)&#123;
    auto end = split(r + 1), begin = split(l);
    // pair 存节点的值和区间长度
    vector&lt;pair&lt;LL, LL&gt;&gt; v;
    for(auto it = begin; it != end; it++)&#123;
        v.push_back(&#123;it-&gt;v, it-&gt;r - it-&gt;l + 1&#125;);
    &#125;
    sort(v.begin(), v.end());
    for(int i = 0; i &lt; v.size(); i++)&#123;
        k -= v[i].second;
        if(k &lt;= 0) return v[i].first;
    &#125;
&#125;
// 求区间 n 次方和
LL sum_of_power(LL l, LL r, LL x, LL y)&#123;
    LL tot = 0;
    auto end = split(r + 1), begin = split(l);
    for(auto it = begin; it != end; it++)&#123;
        tot = (tot + qpow(it-&gt;v, x, y) * (it-&gt;r - it-&gt;l + 1)) % y;
    &#125;
    return tot;
&#125;
LL rnd(LL&amp; seed)&#123;
    LL x = seed;
    seed = (seed * 7 + 13) % 1000000007;
    return x;
&#125;
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(false);
    LL n, m, seed, vmax;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;
    for(int i = 1; i &lt;= n; i++)&#123;
        LL r = rnd(seed);
        tr.insert(&#123;i, i, r % vmax + 1&#125;);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        LL opr = rnd(seed) % 4 + 1, l = rnd(seed) % n + 1, r = rnd(seed) % n + 1, x, y;
        if(l &gt; r)&#123;
            swap(l, r);
        &#125;
        if(opr == 3)&#123;
            x = rnd(seed) % (r - l + 1) + 1;
        &#125;else&#123;
            x = rnd(seed) % vmax + 1;
        &#125;
        if(opr == 4)&#123;
            y = rnd(seed) % vmax + 1;
        &#125;
        switch (opr)
        &#123;
        case 1:
            add(l, r, x);
            break;
        
        case 2:
            assign(l, r, x);
            break;

        case 3:
            cout &lt;&lt; kth(l, r, x) &lt;&lt; &#39;\n&#39;;
            break;

        case 4:
            cout &lt;&lt; sum_of_power(l, r, x, y) &lt;&lt; &#39;\n&#39;;
            break;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><ul><li><p>树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。</p></li><li><p>具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。</p></li><li><p><strong>树链剖分</strong>（树剖&#x2F;链剖）有多种形式，如 <strong>重链剖分</strong>，<strong>长链剖分</strong> 和用于 Link&#x2F;cut Tree 的剖分（有时被称作“实链剖分”），大多数情况下（没有特别说明时），“树链剖分”都指“重链剖分”。</p></li><li><p>重链剖分可以将树上的任意一条路径划分成不超过  条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。</p></li><li><p>重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。</p><ol><li>修改 <strong>树上两点之间的路径上</strong> 所有点的值。</li><li>查询 <strong>树上两点之间的路径上</strong> 节点权值的 <strong>和&#x2F;极值&#x2F;其它（在序列上可以用数据结构维护，便于合并的信息）</strong>。</li></ol></li><li><p>除了配合数据结构来维护树上路径信息，树剖还可以用来 （且常数较小）地求 LCA。在某些题目中，还可以利用其性质来灵活地运用树剖。</p></li></ul><h3 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h3><ul><li>定义 <strong>重子节点</strong> 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。</li><li>定义 <strong>轻子节点</strong> 表示剩余的所有子结点。从这个结点到重子节点的边为 <strong>重边</strong>，到其他轻子节点的边为 <strong>轻边</strong>。</li><li>若干条首尾衔接的重边构成 <strong>重链</strong>。</li><li>把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。</li><li>重链剖分有一个重要的性质：<strong>对于节点数为 n 的树，从任意节点向上走到根节点，经过的轻边数量不超过 log⁡n</strong> 。这是因为，如果一个节点连向父节点的边是轻边，就必然存在子树不小于它的兄弟节点，那么父节点对应子树的大小一定超过该节点的两倍。每经过一条轻边，子树大小就翻倍，所以最多只能经过 log⁡n 条。</li><li>我们通过两次dfs来进行重链剖分。第一趟dfs，先得到每个节点的<code>fa</code>（父节点）、<code>sz</code>（子树大小）、<code>dep</code>（深度）、<code>hson</code>（重子节点）：</li></ul><pre><code class="cpp">int fa[N], dep[N], sz[N], hson[N], top[N], dfsn[N], madfsn[N];
void dfs1(int p, int d = 1)&#123;
    int cnt = 1, maxv = 0;
    dep[p] = d;
    for(auto i : g[p])&#123;
        if(!dep[i])&#123;
            dfs1(i, d + 1);
            fa[i] = p;
            cnt += sz[i];
            if(sz[i] &gt; maxv)&#123;
                maxv = sz[i];
                hson[p] = i;
            &#125;
        &#125;
    &#125;
    sz[p] = cnt;
&#125;
</code></pre><ul><li>第二趟dfs，得到每个节点的<code>top</code>（链头，即所在的重链中深度最小的那个节点）：</li></ul><pre><code class="cpp">// 需要先把根节点的top初始化为自身
void dfs2(int p)&#123;
    for(auto i : g[p])&#123;
        if(!top[i])&#123;
            if(i == hson[p])&#123;
                top[i] = top[p];
            &#125;else&#123;
                top[i] = i;
            &#125;
            dfs2(i);
        &#125;
    &#125;
&#125;
</code></pre><h3 id="求-LCA"><a href="#求-LCA" class="headerlink" title="求 LCA"></a>求 LCA</h3><ul><li>树剖可以单次 $O(log;⁡n)$ 地求 LCA，且常数较小。假如我们要求两个节点的 LCA，如果它们在同一条链上，那直接输出深度较小的那个节点就可以了。</li><li>否则，LCA要么在链头深度较小的那条链上，要么就是两个链头的父节点的LCA，但绝不可能在链头深度较大的那条链上。所以我们可以直接把链头深度较大的节点用其链头的父节点代替，然后继续求它与另一者的LCA。</li><li>由于在链上我们可以 $O(1)$ 地跳转，每条链间由轻边连接，而经过轻边的次数又不超过 $log ;n$ ，所以我们实现了 $O(log⁡;n)$ 的 LCA 查询。</li></ul><pre><code class="cpp">int lca(int a, int b)&#123;
    while (top[a] != top[b])&#123;
        if (dep[top[a]] &gt; dep[top[b]])
            a = fa[top[a]];
        else
            b = fa[top[b]];
    &#125;
    return (dep[a] &gt; dep[b] ? b : a);
&#125;
</code></pre><h3 id="结合数据结构"><a href="#结合数据结构" class="headerlink" title="结合数据结构"></a>结合数据结构</h3><ul><li>在进行了树链剖分后，我们便可以配合线段树等数据结构维护树上的信息，这需要我们改一下第二次dfs的代码，我们用<code>dfsn</code>数组记录每个点的<strong>dfs序</strong>，用<code>madfsn</code>数组记录<strong>每棵子树的最大dfs序</strong>：</li></ul><pre><code class="cpp">// 需要先把根节点的top初始化为自身
int cnt;
void dfs2(int p)&#123;
    madfsn[p] = dfsn[p] = ++cnt;
    if(hson[p] != 0)&#123;
        top[hson[p]] = top[p];
        dfs2(hson[p]);
        madfsn[p] = max(madfsn[p], madfsn[hson[p]]);
    &#125;
    for(auto i : g[p])&#123;
        if(!top[i])&#123;
            top[i] = i;
            dfs2(i);
            madfsn[p] = max(madfsn[p], madfsn[i]);
        &#125;
    &#125;
&#125;
</code></pre><ul><li>注意到，<strong>每棵子树的dfs序都是连续的，且根节点dfs序最小</strong>；而且，如果我们优先遍历重子节点，那么<strong>同一条链上的节点的dfs序也是连续的，且链头节点dfs序最小</strong>。</li><li><img data-src="https://pic4.zhimg.com/80/v2-2f1a4cdb51812c7a4cd7f0ab22b9566f_720w.jpg"></li><li>所以就可以用线段树等数据结构维护区间信息（以点权的和为例），例如路径修改（类似于求LCA的过程）：</li></ul><pre><code class="cpp">// 路径修改
void update_path(int x, int y, int z)&#123;
    while(top[x] != top[y])&#123;
        if(dep[top[x]] &gt; dep[top[y]])&#123;
            modify(1, dfsn[top[x]], dfsn[x], z);
            x = fa[top[x]];
        &#125;else&#123;
            modify(1, dfsn[top[y]], dfsn[y], z);
            y = fa[top[y]];
        &#125;
    &#125;
    if(dep[x] &gt; dep[y])&#123;
        modify(1, dfsn[top[y]], dfsn[x], z);
    &#125;else&#123;
        modify(1, dfsn[top[x]], dfsn[y], z);
    &#125;
&#125;
// 路径查询
int query_path(int x, int y)&#123;
    int ans = 0;
    while(top[x] != top[y])&#123;
        if(dep[top[x]] &gt; dep[top[y]])&#123;
            ans += query(1, dfsn[top[x]], dfsn[x]);
            x = fa[top[x]];
        &#125;else&#123;
            ans += query(1, dfsn[top[y]], dfsn[y]);
            y = fa[top[y]];
        &#125;
    &#125;
    if(dep[x] &gt; dep[y])&#123;
        ans += query(1, dfsn[top[y]], dfsn[x]);
    &#125;else&#123;
        ans += query(1, dfsn[top[x]], dfsn[y]);
    &#125;
    return ans;
&#125;
// 子树修改
void modify_subtree(int x, int z)&#123;
    modify(1, dfsn[x], madfsn[x], z);
&#125;
// 子树查询
int query_subtree(int x)&#123;
    return query(1, dfsn[x], madfsn[x]);
&#125;
</code></pre><ul><li>需要注意，建线段树的时候不是按节点编号建，而是按dfs序建</li></ul><pre><code class="cpp">for (int i = 1; i &lt;= n; ++i)
    B[i] = read();
// ...
for (int i = 1; i &lt;= n; ++i)
    A[dfsn[i]] = B[i];
build();
</code></pre><ul><li>当然，不仅可以用线段树维护，有些题也可以使用<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYzNTMwODI=">珂朵莉树</span>等数据结构（要求数据不卡珂朵莉树，如<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vd3d3Lmx1b2d1LmNvbS5jbi9wcm9ibGVtL1A0MzE1">这道</span>）。此外，如果需要维护的是边权而不是点权，把每条边的边权下放到深度较深的那个节点处即可，但是查询、修改的时候要注意略过最后一个点。</li></ul><h3 id="P2590-树的统计"><a href="#P2590-树的统计" class="headerlink" title="P2590 树的统计"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1OTA=">P2590 树的统计</span></h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 3e4 + 10;
struct Node&#123;
    int l, r;
    LL sum, maxv;
&#125;tr[N &lt;&lt; 2];
LL w[N];
void pushup(int u)&#123;
    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    tr[u].maxv = max(tr[u &lt;&lt; 1].maxv, tr[u &lt;&lt; 1 | 1].maxv);
&#125;
void build(int u, int l, int r)&#123;
    tr[u] = &#123;l, r&#125;;
    if(l == r)&#123;
        tr[u].sum = w[l];
        tr[u].maxv = w[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
&#125;
void modify(int u, int l, int r, LL v)&#123;
    if(l == tr[u].l &amp;&amp; r == tr[u].r)&#123;
        tr[u].sum = v;
        tr[u].maxv = v;
        return;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
    pushup(u);
&#125;
int query_max(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        return tr[u].maxv;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    int ans = -0x3f3f3f3f;
    if(l &lt;= mid) ans = max(ans, query_max(u &lt;&lt; 1, l, r));
    if(r &gt; mid) ans = max(ans, query_max(u &lt;&lt; 1 | 1, l, r));
    return ans;
&#125;
int query_sum(int u, int l, int r)&#123;
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;
        return tr[u].sum;
    &#125;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    int ans = 0;
    if(l &lt;= mid) ans = query_sum(u &lt;&lt; 1, l, r);
    if(r &gt; mid) ans += query_sum(u &lt;&lt; 1 | 1, l, r);
    return ans;
&#125;

// 树链剖分
int h[N], ne[N &lt;&lt; 1], e[N &lt;&lt; 1], idx;
int fa[N], dep[N], sz[N], hson[N], top[N], dfsn[N], madfsn[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs1(int p, int d = 1)&#123;
    int cnt = 1, maxv = 0;
    dep[p] = d;
    for(int i = h[p]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa[p]) continue;
        if(!dep[j])&#123;
            dfs1(j, d + 1);
            cnt += sz[j];
            fa[j] = p;
            if(sz[j] &gt; maxv) maxv = sz[j], hson[p] = j;
        &#125;
    &#125;
    sz[p] = cnt;
&#125;
int cnt;
void dfs2(int p)&#123;
    madfsn[p] = dfsn[p] = ++cnt;
    if(hson[p] != 0)&#123;
        top[hson[p]] = top[p];
        dfs2(hson[p]);
        madfsn[p] = max(madfsn[p], madfsn[hson[p]]);
    &#125;
    for(int i = h[p]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa[p] || j == hson[p]) continue;
        if(!top[j])&#123;
            top[j] = j;
            dfs2(j);
            madfsn[p] = max(madfsn[p], madfsn[j]);
        &#125;
    &#125;
&#125;
int query_path_max(int x, int y)&#123;
    int ans = -0x3f3f3f3f;
    while(top[x] != top[y])&#123;
        if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);
        ans = max(ans, query_max(1, dfsn[top[x]], dfsn[x]));
        x = fa[top[x]];
    &#125;
    if(dep[x] &gt; dep[y]) swap(x, y);
    ans = max(ans, query_max(1, dfsn[x], dfsn[y]));
    return ans;
&#125;
int query_path_sum(int x, int y)&#123;
    int ans = 0;
    while(top[x] != top[y])&#123;
        if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);
        ans += query_sum(1, dfsn[top[x]], dfsn[x]);
        x = fa[top[x]];
    &#125;
    if(dep[x] &gt; dep[y]) swap(x, y);
    ans += query_sum(1, dfsn[x], dfsn[y]);
    return ans;
&#125;
int num[N];
int main()&#123;
    cin.tie(0)-&gt;sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    memset(h, -1, sizeof h);
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
        add(b, a);
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; num[i];
    &#125;
    top[1] = 1;
    dfs1(1);
    dfs2(1);
    for(int i = 1; i &lt;= n; i++)&#123;
        w[dfsn[i]] = num[i];
    &#125;
    build(1, 1, n);
    int m;
    cin &gt;&gt; m;
    while(m--)&#123;
        string op;
        int a, b;
        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
        if(op[0] == &#39;C&#39;) modify(1, dfsn[a], dfsn[a], b);
        else if(op == &quot;QMAX&quot;)&#123;
            cout &lt;&lt; query_path_max(a, b) &lt;&lt; &#39;\n&#39;;
        &#125;else&#123;
            cout &lt;&lt; query_path_sum(a, b) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E9%A2%98%E9%9B%86/" rel="tag"><i class="ic i-tag"></i> 题集</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-07 09:05:35" itemprop="dateModified" datetime="2022-09-07T09:05:35+08:00">2022-09-07</time> </span><span id="post/高级数据结构题集.html" class="item leancloud_visitors" data-flag-title="高级数据结构题集" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" title="高级数据结构题集">https://asterzc19.github.io/post/高级数据结构题集.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;a67b0e59dd863077.jpg" title="图论题集"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>图论题集</h3></a></div><div class="item right"><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;06&#x2F;25&#x2F;ff62598e6c27ddd4.png" title="Flyme 更新日志"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Flyme 更新日志</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F"><span class="toc-number">1.1.</span> <span class="toc-text">格子游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E9%85%8D%E8%B4%AD%E4%B9%B0"><span class="toc-number">1.2.</span> <span class="toc-text">搭配购买</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">程序自动分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4"><span class="toc-number">1.4.</span> <span class="toc-text">银河英雄传说</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%B8%B8%E6%88%8F"><span class="toc-number">1.5.</span> <span class="toc-text">奇偶游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%9F%9F%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">扩展域并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E8%BE%B9%E6%9D%83%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">带边权的并查集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%BC%E5%85%B0%E5%9B%BE%E8%85%BE"><span class="toc-number">2.1.</span> <span class="toc-text">楼兰图腾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E2%85%A0"><span class="toc-number">2.2.</span> <span class="toc-text">一个简单的整数问题 Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E2%85%A1-%F0%9F%8C%B8"><span class="toc-number">2.3.</span> <span class="toc-text">一个简单的整数问题 Ⅱ 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%9C%E4%B8%80%E6%A0%B7%E7%9A%84%E7%89%9B-%F0%9F%8C%B8"><span class="toc-number">2.4.</span> <span class="toc-text">谜一样的牛 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF383C-Propagating-tree"><span class="toc-number">2.5.</span> <span class="toc-text">CF383C | Propagating tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">动态开点线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%95%B0-%F0%9F%8C%B8"><span class="toc-number">3.2.</span> <span class="toc-text">最大数 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97-%F0%9F%8C%B8"><span class="toc-number">3.3.</span> <span class="toc-text">你能回答这些问题吗 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%F0%9F%8C%B8"><span class="toc-number">3.4.</span> <span class="toc-text">区间最大公约数 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E2%85%A1-%F0%9F%8C%B8-1"><span class="toc-number">3.5.</span> <span class="toc-text">一个简单的整数问题 Ⅱ 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%9A%E7%89%B9%E5%85%B0%E8%92%82%E6%96%AF-%F0%9F%8C%B8%F0%9F%8C%B8"><span class="toc-number">3.6.</span> <span class="toc-text">亚特兰蒂斯 🌸🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97-%F0%9F%8C%B8"><span class="toc-number">3.7.</span> <span class="toc-text">维护序列 🌸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">可持久化数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C-%F0%9F%8C%B8%F0%9F%8C%B8%F0%9F%8C%B8"><span class="toc-number">4.1.</span> <span class="toc-text">最大异或和 🌸🌸🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%ACk%E5%B0%8F%E6%95%B0-%F0%9F%8C%B8%F0%9F%8C%B8%F0%9F%8C%B8"><span class="toc-number">4.2.</span> <span class="toc-text">第k小数 🌸🌸🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.3.</span> <span class="toc-text">可持久化线段树模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">4.4.</span> <span class="toc-text">动态开点可持久化线段树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Treap-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">Treap - 平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">AcWing|普通平衡树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Splay-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">Splay 平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P3391-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.1.</span> <span class="toc-text">P3391 | 文艺平衡树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P3369-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.2.</span> <span class="toc-text">P3369 | 普通平衡树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POJ2828-Buy-Tickets"><span class="toc-number">6.3.</span> <span class="toc-text">POJ2828 | Buy Tickets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%AB%E9%98%9F"><span class="toc-number">7.</span> <span class="toc-text">莫队</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F"><span class="toc-number">7.1.</span> <span class="toc-text">普通莫队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F"><span class="toc-number">7.2.</span> <span class="toc-text">带修莫队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">珂朵莉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF896C-Willem-Chtholly-and-Seniorious"><span class="toc-number">8.1.</span> <span class="toc-text">CF896C | Willem, Chtholly and Seniorious</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">9.</span> <span class="toc-text">树链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">9.1.</span> <span class="toc-text">重链剖分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82-LCA"><span class="toc-number">9.2.</span> <span class="toc-text">求 LCA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.</span> <span class="toc-text">结合数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2590-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">9.4.</span> <span class="toc-text">P2590 树的统计</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/STL%E7%AE%80%E4%BB%8B.html" title="STL 简介">STL 简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/AcWing/" title="分类于 AcWing">AcWing</a></div><span><a href="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html" title="线性同余方程">线性同余方程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html" title="网络流">网络流</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html" title="图论题集">图论题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF.html" title="基础数据结构模板">基础数据结构模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%96%87%E7%AB%A0/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">动态规划题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html" title="搜索与图论模板">搜索与图论模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/CodeForces/" title="分类于 CodeForces">CodeForces</a> <i class="ic i-angle-right"></i> <a href="/categories/AtCoder/" title="分类于 AtCoder">AtCoder</a></div><span><a href="/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" title="题目小集">题目小集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" title="Flyme 更新日志">Flyme 更新日志</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">292k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:26</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/高级数据结构题集.html",favicon:{show:"嗨~",hide:"呜呜呜"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->