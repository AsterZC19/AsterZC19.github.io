<!-- build time:Wed Sep 07 2022 10:36:32 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="il1q90BxSJlkHz0ezs6wuAALE1ljC0BqphuEiVcl41I"><link rel="alternate" type="application/rss+xml" title="Retsa" href="https://asterzc19.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Retsa" href="https://asterzc19.github.io/atom.xml"><link rel="alternate" type="application/json" title="Retsa" href="https://asterzc19.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="模板,题集"><link rel="canonical" href="https://asterzc19.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162449527-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-162449527-1")</script><title>动态规划题集 | 回不到的过去 = Retsa</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">动态规划题集</h1><div class="meta"><span class="item" title="创建时间：2022-02-28 18:00:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-28T18:00:20+08:00">2022-02-28</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>48k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>44 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">回不到的过去</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2ed81611f053c81c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/79181978dd20d35c.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/9259140c0ac4c203.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/8e1dc72d6a2cd665.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/21bbfe021cfceec4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/ff4c0e1d1c41cedd.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/85da8357bdceba73.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/2b1d828f5ff26065.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/728c619db3847842.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/0f4de4af64f8d166.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/7f6edf1d98b0d8a0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/0ff0506797b60902.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/d77d62850e952780.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/372deb0eedb17ea9.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/b545cd4703efa0d4.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/5c235cc1bbf7c128.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/04b816dd3c5c9934.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/cc4fe587071a62d8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/44d29b2c5b4e40c8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/05ac51bc092a5a09.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/82a4dfcddf3ba7e0.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/a655408706100f86.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/848d77945ce37428.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/06/e82f196e980a63f5.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/4203257a6c65e036.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/07/6cde4a47e73d00cf.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/db894a8df07c1517.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/7d78d1f79d9080f1.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/34d7d1d1b3b17e24.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/a67b0e59dd863077.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asterzc19.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/iOS.jpg"><meta itemprop="name" content="Retsa"><meta itemprop="description" content=", 对未来的透支，对过去的偿还"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Retsa"></span><div class="body md" itemprop="articleBody"><blockquote><p>包括背包问题，线性 DP，区间 DP，计数类 DP，数位统计 DP，状压 DP，树形 DP，记忆化搜索，背包模型，数字三角形模型，最长上升子序列模型，状态机模型，单调队列优化 DP，斜率优化 DP。</p></blockquote><hr><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><pre><code class="cpp">// N 件物品，容量为 V，体积 v，价值 w
cin &gt;&gt; N &gt;&gt; V;
for(int i = 1; i &lt;= N; i++)&#123;
    cin &gt;&gt; v[i] &gt;&gt; w[i];
&#125;
for(int i = 1; i &lt;= N; i++)&#123;
    for(int j = V; j &gt;= v[i]; j--)&#123;
        dp[j] = max(dp[j],dp[j - v[i]] + w[i]);
    &#125;
&#125;
cout &lt;&lt; dp[V] &lt;&lt; endl;
</code></pre><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ul><li>求所有前缀的最大值</li></ul><pre><code class="cpp">cin &gt;&gt; N &gt;&gt; V;
for(int i = 1; i &lt;= N; i++)&#123;
    cin &gt;&gt; v[i] &gt;&gt; w[i];
&#125;
for(int i = 1; i &lt;= N; i++)&#123;
    for(int j = v[i]; j &lt;= V; j++)&#123;
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    &#125;
&#125;
cout &lt;&lt; dp[V] &lt;&lt; endl;
</code></pre><h3 id="多重背包问题-Ⅰ"><a href="#多重背包问题-Ⅰ" class="headerlink" title="多重背包问题 Ⅰ"></a>多重背包问题 Ⅰ</h3><pre><code class="cpp">// N 种物品，容量为 V，一种物品有 s 件。
cin &gt;&gt; N &gt;&gt; V;
for(int i = 1; i &lt;= N; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];
for(int i = 1; i &lt;= N; i++)&#123;
    for(int j = 0; j &lt;= N; j++)&#123;
        for(int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)&#123;
            dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i] * k] + w[i] * k);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[N][V] &lt;&lt; endl;
</code></pre><h3 id="多重背包问题-Ⅱ"><a href="#多重背包问题-Ⅱ" class="headerlink" title="多重背包问题 Ⅱ"></a>多重背包问题 Ⅱ</h3><ul><li>考察多重背包的二进制优化方法</li></ul><pre><code class="cpp">cin &gt;&gt; N &gt;&gt; V;
int cnt = 0;
for(int i = 1; i &lt;= n; i++)&#123;
    int a, b, s;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;
    int k = 1;
    while(k &lt;= s)&#123;
        cnt++;
        v[cnt] = a * k, w[cnt] = b * k;
        s -= k;
        k *= 2;
    &#125;
    if(s &gt; 0)&#123;
        cnt++;
        v[cnt] = a * s, w[cnt] = b * s;
    &#125;
&#125;
n = cnt;
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = V; j &gt;= v[i]; j--)&#123;
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    &#125;
&#125;
cout &lt;&lt; dp[V] &lt;&lt; endl;
</code></pre><h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><pre><code class="cpp">cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= n; i++)&#123;
    cin &gt;&gt; s[i];
    for(int j = 1; j &lt;= s[i]; j++)&#123;
        cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];
    &#125;
&#125;
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = m; j &gt;= 0; j--)&#123;
        for(int k = 0; k &lt;= s[i]; k++)&#123;
            if(v[i][k] &lt;= j)&#123;
                dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);
            &#125;
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[m] &lt;&lt; endl;
</code></pre><hr><h2 id="线性-DP"><a href="#线性-DP" class="headerlink" title="线性 DP"></a>线性 DP</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><pre><code class="cpp">int n;
cin &gt;&gt; n;
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = 1; j &lt;= i; j++)&#123;
        cin &gt;&gt; a[i][j];
    &#125;
&#125;
for(int i = 0; i &lt;= n; i++)&#123;
    for(int j = 0; j &lt;= i + 1; j++)&#123;
        f[i][j] = -INF;
    &#125;
&#125;
f[1][1] = a[1][1];
for(int i = 2; i &lt;= n; i++)&#123;
    for(int j = 1; j &lt;= i; j++)&#123;
        f[i][j] = max(f[i-1][j-1] + a[i][j], f[i-1][j] + a[i][j]);
    &#125;
&#125;
int res = -INF;
for(int i = 1; i &lt;= n; i++)&#123;
    res = max(res, f[n][i]);
&#125;
cout &lt;&lt; res &lt;&lt; endl;
</code></pre><h3 id="最长上升子序列-Ⅰ"><a href="#最长上升子序列-Ⅰ" class="headerlink" title="最长上升子序列 Ⅰ"></a>最长上升子序列 Ⅰ</h3><pre><code class="cpp">cin &gt;&gt; n;
for(int i = 1; i &lt;= n; i++)
    cin &gt;&gt; a[i];
for(int i = 1; i &lt;= n; i++)&#123;
    dp[i] = 1;
    for(int j = 1; j &lt; i; j++)&#123;
        if(a[j] &lt; a[i])&#123;
            dp[i] = max(dp[i], dp[j] + 1);
        &#125;
    &#125;
&#125;
int res = 0;
for(int i = 1; i &lt;= n; i++)&#123;
    res = max(res, dp[i]);
&#125;
cout &lt;&lt; res &lt;&lt; endl;
</code></pre><h3 id="最长上升子序列-Ⅱ"><a href="#最长上升子序列-Ⅱ" class="headerlink" title="最长上升子序列 Ⅱ"></a>最长上升子序列 Ⅱ</h3><pre><code class="cpp">// q[len] 表示长度为 len 的序列最后一个数的值
int n;
cin &gt;&gt; n;
for (int i = 1; i &lt;= n; i++)
    cin &gt;&gt; a[i];

int len = 0;
for(int i = 1; i &lt;= n; i++)&#123;
    int l = 0, r = len;
    while(l &lt; r)&#123;
        int mid = l + r + 1 &gt;&gt; 1;
        if(q[mid] &lt; a[i]) l = mid;
        else r = mid - 1;
    &#125;
    len = max(len, r + 1);
    q[r + 1] = a[i];
&#125;
cout &lt;&lt; len &lt;&lt; endl;
</code></pre><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><pre><code class="cpp">scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
scanf(&quot;%s %s&quot;, a + 1, b + 1);
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = 1; j &lt;= m; j++)&#123;
        dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        if(a[i] == b[j])&#123;
            dp[i][j] = max(dp[i-1][j-1] + 1, dp[i][j]);
        &#125;
    &#125;
&#125;
printf(&quot;%d\n&quot;, dp[n][m]);
</code></pre><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><ul><li>题意<ul><li>给定 $n$ 个长度不超过 $10$ 的字符串以及 $m$ 次询问，每次询问给出一个字符串和一个操作次数上限。</li><li>对于每次询问，请你求出给定的 $n$ 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</li><li>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</li></ul></li><li>代码</li></ul><pre><code class="cpp">int edit_distance(char a[], char b[])
&#123;
    int la = strlen(a+1), lb = strlen(b+1);
    for(int i = 0; i &lt;= lb; i++) dp[0][i] = i;
    for(int i = 0; i &lt;= la; i++) dp[i][0] = i;
    for(int i = 1; i &lt;= la; i++)&#123;
        for(int j = 1; j &lt;= lb; j++)&#123;
            dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1);
            dp[i][j] = min(dp[i][j], dp[i-1][j-1] + (a[i] != b[j]));
        &#125;
    &#125;
    return dp[la][lb];
&#125;    
int main()
&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);	// n 个字符串，m 次询问
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%s&quot;, str[i] + 1);
    while(m--)&#123;
        char s[N];
        int limit;
        scanf(&quot;%s%d&quot;, s + 1, &amp;limit);
        int res = 0;
        for(int i = 1; i &lt;= n; i++)&#123;
            if(edit_distance(str[i], s) &lt;= limit)&#123;
                res ++;
            &#125;
        &#125;
        printf(&quot;%d\n&quot;, res);
    &#125;
&#125;
</code></pre><hr><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><pre><code class="cpp">cin &gt;&gt; n;
for(int i = 1; i &lt;= n; i++)&#123;
    cin &gt;&gt; s[i];
&#125;
for(int i = 1; i &lt;= n; i++)&#123;
    s[i] += s[i - 1];
&#125;
for(int len = 2; len &lt;= n; len++)&#123;
    for(int i = 1; i + len - 1 &lt;= n; i++)&#123;
        int l = i, r = i + len - 1;
        dp[l][r] = 1e9;
        for(int k = l; k &lt; r; k++)&#123;
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l-1]);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[1][n] &lt;&lt; endl;
</code></pre><h3 id="AcWing-环形石子合并"><a href="#AcWing-环形石子合并" class="headerlink" title="AcWing|环形石子合并"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3MC8=">AcWing|环形石子合并</span></h3><ul><li>每轮合并的石子必须是 <strong>相邻</strong> 的两堆石子，用到的是经典的区间 DP 模型，枚举区间长度</li><li>状态表示 $dp[l, r]$<ul><li>集合：当前合并的石子堆的大小为 $len$，且石子堆的左端点是 $l$，右端点是 $r$ 的方案</li><li>属性：Min&#x2F;Max</li></ul></li><li>状态计算（以最小值为例）<ul><li><code>dp[l][r] = min (dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1]</code></li></ul></li><li>通过把链延长两倍，变成 $2n$ 堆石子，可以在 $O(n^3)$ 的时间复杂度之内解决这道题目</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 410;
int dp1[N][N], dp2[N][N];
int w[N], s[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n; cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        w[i + n] = w[i];
    &#125;
    for(int i = 1; i &lt;= 2 * n; i++) s[i] = s[i - 1] + w[i];
    memset(dp1, 0x3f, sizeof(dp1));
    memset(dp2, -0x3f, sizeof(dp2));
    for(int len = 1; len &lt;= n; len++)&#123;
        for(int i = 1; i + len - 1 &lt;= n * 2; i++)&#123;
            int j = i + len - 1;
            if(i == j) dp1[i][j] = dp2[i][j] = 0;
            else&#123;
                for(int k = i; k &lt; j; k++)&#123;
                    dp1[i][j] = min(dp1[i][j], dp1[i][k] + dp1[k + 1][j] + s[j] - s[i - 1]);
                    dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k + 1][j] + s[j] - s[i - 1]);
                &#125;
            &#125;
        &#125;
    &#125;
    int ans1 = 0x3f3f3f3f, ans2 = -0x3f3f3f3f;
    for(int i = 1; i &lt;= n; i++)&#123;
        ans1 = min(ans1, dp1[i][i + n - 1]);
        ans2 = max(ans2, dp2[i][i + n - 1]);
    &#125;
    cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2 &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-能量项链"><a href="#AcWing-能量项链" class="headerlink" title="AcWing|能量项链"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzIyLw==">AcWing|能量项链</span></h3><ul><li>状态表示 $dp[L, R]$<ul><li>集合：所有将 $[L, R]$ 合并在成一个矩阵（珠子）的方式</li><li>属性：Max</li></ul></li><li>状态计算<ul><li><code>dp[L][R] = max(dp[L][R], dp[L][K] + dp[K][R] + w[L] * w[K] * w[R])</code></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 210;
int dp[N][N], w[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n; cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i];
        w[i + n] = w[i];
    &#125;
    for(int len = 3; len &lt;= n + 1; len++)&#123;
        for(int i = 1; i + len - 1 &lt;= 2 * n; i++)&#123;
            int j = i + len - 1;
            for(int k = i + 1; k &lt; j; k++)&#123;
                dp[i][j] = max(dp[i][j] , dp[i][k] + dp[k][j] + w[i] * w[k] * w[j]);
            &#125;
        &#125;
    &#125;
    int ans = 0;
    for(int i = 1; i &lt;= n; i++) ans = max(ans, dp[i][i + n]);
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-凸多边形的划分"><a href="#AcWing-凸多边形的划分" class="headerlink" title="AcWing|凸多边形的划分"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3MS8=">AcWing|凸多边形的划分</span></h3><ul><li>状态表示 $dp[L, R]$<ul><li>集合：所有将 $(L, L + 1), (L + 1, L + 2), \cdots , (R - 1, R), (R, L)$ 这个多边形划分成三角形的方案</li><li>属性：Min</li></ul></li><li>状态计算<ul><li><code>dp[L][R] = max(dp[L][R], dp[L][K] + dp[K][R] + w[L] * w[K] * w[R])</code></li></ul></li><li>数组实现高精度</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 55, M = 35, INF = 1e9;
int n;
int w[N];
LL dp[N][N][M];
void add(LL a[], LL b[])&#123;
    static LL c[M];
    memset(c, 0, sizeof(c));
    for(int i = 0, t = 0; i &lt; M; i++)&#123;
        t += a[i] + b[i];
        c[i] = t % 10;
        t /= 10;
    &#125;
    memcpy(a, c, sizeof(c));
&#125;
void mul(LL a[], LL b)&#123;
    static LL c[M];
    memset(c, 0, sizeof(c));
    LL t = 0;
    for(int i = 0; i &lt; M; i++)&#123;
        t += a[i] * b;
        c[i] = t % 10;
        t /= 10;
    &#125;
    memcpy(a, c, sizeof(c));
&#125;
int cmp(LL a[], LL b[])&#123;
    for(int i = M - 1; i &gt;= 0; i--)&#123;
        if(a[i] &gt; b[i]) return 1;
        if(a[i] &lt; b[i]) return -1;
    &#125;
    return 0;
&#125;
void print(LL a[])&#123;
    int k = M - 1;
    while(k &amp;&amp; !a[k]) k--;
    while(k &gt;= 0) cout &lt;&lt; a[k--];
    cout &lt;&lt; endl;
&#125;
int main()&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    LL tmp[M];
    for(int len = 3; len &lt;= n; len++)&#123;
        for(int l = 1; l + len - 1 &lt;= n; l++)&#123;
            int r = l + len - 1;
            dp[l][r][M - 1] = 1;
            for(int k = l + 1; k &lt; r; k++)&#123;
                memset(tmp, 0, sizeof(tmp));
                tmp[0] = w[l];
                mul(tmp, w[k]);
                mul(tmp, w[r]);
                add(tmp, dp[l][k]);
                add(tmp, dp[k][r]);
                if(cmp(dp[l][r], tmp) &gt; 0)&#123;
                    memcpy(dp[l][r], tmp, sizeof(tmp));
                &#125;
            &#125;
        &#125;
    &#125;
    print(dp[1][n]);
&#125;
</code></pre><h3 id="AcWing-加分二叉树"><a href="#AcWing-加分二叉树" class="headerlink" title="AcWing|加分二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDgxLw==">AcWing|加分二叉树</span></h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzEyODQxLw==">介绍前，中，后序遍历</span></li><li>状态表示 $dp[L, R]$<ul><li>集合：所有中序遍历是 $[L, R]$ 这一段的二叉树的集合</li><li>属性：Max</li></ul></li><li>状态计算<ul><li>枚举不同根节点的方案</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 30;
int n;
int w[N];
int dp[N][N], g[N][N];
void dfs(int l, int r)&#123;
    if(l &gt; r) return;
    int t = g[l][r];
    cout &lt;&lt; t &lt;&lt; &quot; &quot;;
    dfs(l, t - 1);
    dfs(t + 1, r);
&#125;
int main()&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    for(int len = 1; len &lt;= n; len++)&#123;
        for(int l = 1; l + len - 1 &lt;= n; l++)&#123;
            int r = l + len - 1;
            if(len == 1) dp[l][r] = w[l], g[l][r] = l;
            else&#123;
                for(int k = l; k &lt;= r; k++)&#123;
                    int left = k == l ? 1 : dp[l][k - 1];
                    int right = k == r ? 1 : dp[k + 1][r];
                    int score = left * right + w[k];
                    if(dp[l][r] &lt; score)&#123;
                        dp[l][r] = score;
                        g[l][r] = k;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[1][n] &lt;&lt; endl;
    dfs(1, n);
&#125;
</code></pre><h3 id="AcWing-棋盘分割"><a href="#AcWing-棋盘分割" class="headerlink" title="AcWing|棋盘分割"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzIzLw==">AcWing|棋盘分割</span></h3><ul><li>状态表示 $dp[x1, y1, x2, y2, k]$<ul><li>集合：子矩阵 $(x1, y1)(x2, y2)$ 切分成 $k$ 部分的所有方案</li><li>属性：均方差的最小值</li></ul></li><li>记忆化搜索</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 15, M = 9;
const double INF = 1e9;
int n, m = 8;
int s[M][M];
double dp[M][M][M][M][N];
double X;
int getSum(int x1, int y1, int x2, int y2)&#123;
    return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
&#125;
double get(int x1, int y1, int x2, int y2)&#123;
    double sum = getSum(x1, y1, x2, y2) - X;
    return sum * sum / n;
&#125;
double calc(int x1, int y1, int x2, int y2, int k)&#123;
    double &amp;v = dp[x1][y1][x2][y2][k];
    if(v &gt;= 0) return v;
    if(k == 1) return v = get(x1, y1, x2, y2);
    v = INF;
    for(int i = x1; i &lt; x2; i++)&#123;
        v = min(v, get(x1, y1, i, y2) + calc(i + 1, y1, x2, y2, k - 1));
        v = min(v, get(i + 1, y1, x2, y2) + calc(x1, y1, i, y2, k - 1));
    &#125;
    for(int i = y1; i &lt; y2; i++)&#123;
        v = min(v, get(x1, y1, x2, i) + calc(x1, i + 1, x2, y2, k - 1));
        v = min(v, get(x1, i + 1, x2, y2) + calc(x1, y1, x2, i, k - 1));
    &#125;
    return v;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= m; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            cin &gt;&gt; s[i][j];
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        &#125;
    &#125;
    X = 1.0 * s[m][m] / n;
    memset(dp, -1, sizeof(dp));
    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; sqrt(calc(1, 1, 8, 8, n)) &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="计数类-DP"><a href="#计数类-DP" class="headerlink" title="计数类 DP"></a>计数类 DP</h2><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><ul><li>把 $1, 2, … , n$ 分别看做 $n$ 个物品的体积，这 $n$ 个物体均无使用次数限制，问恰好能装满总体积为 $n$ 的背包的总方案数。（完全背包问题变形）</li><li>$dp[i][j]$ 表示前 $i$ 个整数恰好拼成 $j$ 的方案数。</li><li>类似完全背包的推导 $dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]$ 可等价变形为 $dp[j] &#x3D; dp[j] + dp[j - i]$</li></ul><pre><code class="cpp">cin &gt;&gt; n;
dp[0] = 1;	// 容量为 0 时，前 i 个物品全不选也是一种方案
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = i; j &lt;= n; j++)&#123;
        dp[j] = (dp[j] + dp[j - i]) % mod;
    &#125;
&#125;
cout &lt;&lt; dp[n] &lt;&lt; endl;
</code></pre><hr><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><pre><code class="cpp">int n, m;
int g[N][N], f[N][N];
int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;
int dp(int x, int y)&#123;
    int &amp;v = f[x][y];
    if(v != -1) return v;
    v = 1;
    for(int i = 0; i &lt; 4; i++)&#123;
        int nx = x + dx[i], ny = y + dy[i];
        if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; g[x][y] &gt; g[nx][ny])&#123;
            v = max(v, dp(nx, ny) + 1);
        &#125;
    &#125;
    return v;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            cin &gt;&gt; g[i][j];
        &#125;
    &#125;
    memset(f, -1, sizeof(f));
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            ans = max(ans, dp(i, j));
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="状压-DP"><a href="#状压-DP" class="headerlink" title="状压 DP"></a>状压 DP</h2><ul><li>棋盘式（基于连通性）</li><li>集合式</li></ul><h3 id="蒙德里安的梦想🌸"><a href="#蒙德里安的梦想🌸" class="headerlink" title="蒙德里安的梦想🌸"></a>蒙德里安的梦想🌸</h3><ul><li>状态表示 $f[i, j]$<ul><li>集合：将前面全部排好，且 $i - 1$ 列伸出到第 $i$ 列所有方案的集合，$j$ 表示状态</li></ul></li><li>先放横着的，竖着的随着横向的摆放而固定。之后判断是否合法，有两个条件<ul><li>$(j; &amp; ;k) &#x3D; 0$</li><li>所有连续空着的位置的长度必须是偶数</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 12, M = 1 &lt;&lt; N;
LL dp[N][M];
bool st[M]; // st[j | k] = 1 表示能成功转移
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m, n || m)&#123;
        // 预处理 st
        for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123;
            st[i] = 1;
            int cnt = 0; // 记录一列中 0 的个数
            for(int j = 0; j &lt; n; j++)&#123;
                if(i &gt;&gt; j &amp; 1)&#123;
                    if(cnt &amp; 1)&#123;
                        st[i] = 0;
                        break;
                    &#125;
                &#125;else&#123;
                    cnt++;
                &#125;
            &#125;
            if(cnt &amp; 1) st[i] = 0;
        &#125;

        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;   // 没有横着摆放的小方块，所有小方块都是竖着摆放的，记录为一种状态
        for(int i = 1; i &lt;= m; i++)&#123;
            for(int j = 0; j &lt; 1 &lt;&lt; n; j++)&#123;
                for(int k = 0; k &lt; 1 &lt;&lt; n; k++)&#123;
                    if((j &amp; k) == 0 &amp;&amp; st[j | k])&#123;
                        dp[i][j] += dp[i - 1][k];
                    &#125;
                &#125;
            &#125;
        &#125;
        cout &lt;&lt; dp[m][0] &lt;&lt; endl;   // 最后一列不会伸出
    &#125;
&#125;
</code></pre><h3 id="最短-Hamilton-路径🌸"><a href="#最短-Hamilton-路径🌸" class="headerlink" title="最短 Hamilton 路径🌸"></a>最短 Hamilton 路径🌸</h3><ul><li>状态表示 $f[i, j]$<ul><li>集合：所有从 $0$ 走到 $j$，走过的所有点是 $i$ 的所有路径</li><li>属性：Min</li></ul></li><li>状态计算<ul><li>$0 \to \cdots \to k \to j$ 中 $k$ 的所有情况，$k$ 表示走到 $j$ 之前，以 $k$ 为终点的最短距离</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20, M = 1 &lt;&lt; N;
int n;
int w[N][N];
int dp[M][N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            cin &gt;&gt; w[i][j];
        &#125;
    &#125;
    memset(dp, 0x3f, sizeof(dp));
    dp[1][0] = 0;
    for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123;
        for(int j = 0; j &lt; n; j++)&#123;
            if(i &gt;&gt; j &amp; 1)&#123;
                for(int k = 0; k &lt; n; k++)&#123;
                    if(i &gt;&gt; k &amp; 1)&#123;
                        dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + w[k][j]);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-小国王"><a href="#AcWing-小国王" class="headerlink" title="AcWing|小国王"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA2Ni8=">AcWing|小国王</span></h3><ul><li>状态表示 $f[i, j, s]$<ul><li>集合：所有只摆在前 $i$ 行，已经摆了 $j$ 个国王，并且第 $i$ 行摆放的状态是 $s$ 的所有方案的集合。</li><li>属性：Count</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 12, M = 1 &lt;&lt; 10, K = 110;
vector&lt;int&gt; st;
int cnt[M];
vector&lt;int&gt; head[M];
LL dp[N][K][M];

int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    auto check = [&amp;n](int st)&#123;
        for(int i = 0; i &lt; n; i++)&#123;
            if((st &gt;&gt; i &amp; 1) &amp;&amp; (st &gt;&gt; (i + 1) &amp; 1)) return false;
        &#125;
        return true;
    &#125;;
    auto count = [&amp;n](int st)&#123;
        int res = 0;
        for(int i = 0; i &lt; n; i++)&#123;
            if(st &gt;&gt; i &amp; 1) res++;
        &#125;
        return res;
    &#125;;
    for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123;
        if(check(i))&#123;
            st.push_back(i);
            cnt[i] = count(i);
        &#125;
    &#125;
    for(int i = 0; i &lt; st.size(); i++)&#123;
        for(int j = 0; j &lt; st.size(); j++)&#123;
            int a = st[i], b = st[j];
            if(check(a | b) &amp;&amp; (a &amp; b) == 0)&#123;
                head[i].push_back(j);
            &#125;
        &#125;
    &#125;
    dp[0][0][0] = 1;
    for(int i = 1; i &lt;= n + 1; i++)&#123;
        for(int j = 0; j &lt;= m; j++)&#123;
            for(int a = 0; a &lt; st.size(); a++)&#123;
                for(int b : head[a])&#123;
                    int c = cnt[st[a]];
                    if(j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][b];
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-玉米田"><a href="#AcWing-玉米田" class="headerlink" title="AcWing|玉米田"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzI5Lw==">AcWing|玉米田</span></h3><ul><li>状态表示 $f[i, s]$<ul><li>集合：所有已经摆完前 $i$ 行，且第 $i$ 行的状态是 $s$ 的所有摆放方案的集合</li><li>属性：Count</li></ul></li><li>将图按照二进制存储，进行<strong>与操作</strong>即可判断该状态是否合法</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 14, M = 1 &lt;&lt; 12, mod = 1e8;
int n, m;
int w[N];
vector&lt;int&gt; st;
vector&lt;int&gt; head[M];
int dp[N][M];
bool check(int st)&#123;
    for(int i = 0; i + 1 &lt; m; i++)&#123;
        if((st &gt;&gt; i &amp; 1) &amp;&amp; (st &gt;&gt; i + 1 &amp; 1)) return false;
    &#125;
    return true;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            int t; cin &gt;&gt; t;
            w[i] += !t * (1 &lt;&lt; j);
        &#125;
    &#125;
    for(int i = 0; i &lt; 1 &lt;&lt; m; i++) if(check(i)) st.push_back(i);
    for(int i = 0; i &lt; st.size(); i++)&#123;
        for(int j = 0; j &lt; st.size(); j++)&#123;
            int a = st[i], b = st[j];
            if(!(a &amp; b)) head[i].push_back(j);
        &#125;
    &#125;
    dp[0][0] = 1;
    for(int i = 1; i &lt;= n + 1; i++)&#123;
        for(int j = 0; j &lt; st.size(); j++)&#123;
            if(!(st[j] &amp; w[i]))&#123;
                for(int k : head[j])&#123;
                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[n + 1][0] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-炮兵阵地-🌸"><a href="#AcWing-炮兵阵地-🌸" class="headerlink" title="AcWing|炮兵阵地 🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjk0Lw==">AcWing|炮兵阵地</span> 🌸</h3><ul><li>状态表示 $f[i, j, k]$<ul><li>集合：所有已经摆完前 $i$ 行，且第 $i - 1$ 行的状态是 $j$，第 $i$ 行的状态是 $k$ 的所有摆放方案的最大值</li><li>属性：Max</li></ul></li><li>假如开大数组的话，空间复杂度会是 $O(N \times 2^{M} \times 2^{M})$ 会爆内存，因此我们必须使用滚动数组</li><li>$a$ 为第 $i - 1$ 行，$b$ 为第 $i$ 行，$c$ 为第 $i - 2$ 行</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10, M = 1 &lt;&lt; 10;
int n, m;
int g[1010];
int dp[2][M][M];
vector&lt;int&gt; st;
int cnt[M];
bool check(int st)&#123;
    for(int i = 0; i &lt; m; i++)&#123;
        if((st &gt;&gt; i &amp; 1) &amp;&amp; ((st &gt;&gt; i + 1 &amp; 1) || (st &gt;&gt; i + 2 &amp; 1))) return false;
    &#125;
    return true;
&#125;
int count(int st)&#123;
    int res = 0;
    for(int i = 0; i &lt; m; i++)&#123;
        if(st &gt;&gt; i &amp; 1) res++;
    &#125;
    return res;
&#125;
int main()&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            char c;
            cin &gt;&gt; c;
            g[i] += (c == &#39;H&#39;) &lt;&lt; j;
        &#125;
    &#125;
    for(int i = 0; i &lt; 1 &lt;&lt; m; i++)&#123;
        if(check(i))&#123;
            st.push_back(i);
            cnt[i] = count(i);
        &#125;
    &#125;
    for(int i = 1; i &lt;= n + 2; i++)&#123;
        for(int j = 0; j &lt; st.size(); j++)&#123; // 上一行状态
            for(int k = 0; k &lt; st.size(); k++)&#123; // 当前状态
                for(int u = 0; u &lt; st.size(); u++)&#123; // 前面第两行的状态
                    int a = st[j], b = st[k], c = st[u];
                    if(a &amp; b | a &amp; c | b &amp; c) continue;
                    if(g[i] &amp; b | g[i - 1] &amp; a) continue;
                    dp[i &amp; 1][j][k] = max(dp[i &amp; 1][j][k], dp[(i - 1) &amp; 1][u][j] + cnt[b]);
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[n + 2 &amp; 1][0][0] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-愤怒的小鸟🌖"><a href="#AcWing-愤怒的小鸟🌖" class="headerlink" title="AcWing|愤怒的小鸟🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTI2Lw==">AcWing|愤怒的小鸟</span>🌖</h3><ul><li>本题中抛物线严格经过原点，所以 $c$ 为 $0$，所以只需要两个点即可确定一条抛物线</li><li><code>path[i][j]</code> 表示编号为 $i$ 的小猪和编号为 $j$ 的小猪所在的抛物线，变量的属性为这个抛物线可消灭的小猪的二进制表示</li><li>状态表示：<code>dp[i]</code> 表示当前击败状态 $i$ 表示的小猪所需要的最少的小鸟</li><li>状态计算：找到 $i$ 状态下没有被消灭的小猪的编号 $x$，枚举可消灭它的抛物线 $path[x][j]$ 并更新状态<ul><li><code>dp[i | path[x][j]] = min(dp[i | path[x][j]], dp[i] + 1)</code></li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;double, double&gt; PDD;
const int N = 19, M = 1 &lt;&lt; 18;
const double eps = 1e-8;
int n, m;
PDD q[N];
int path[N][N];
int dp[M];
int cmp(double x, double y)&#123;
    if(fabs(x - y) &lt; eps) return 0;
    if(x &lt; y) return -1;
    return 1;
&#125;
void solve()&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;
    memset(path, 0, sizeof(path));
    for(int i = 0; i &lt; n; i++)&#123;
        path[i][i] = 1 &lt;&lt; i;
        for(int j = 0; j &lt; n; j++)&#123;
            double x1 = q[i].first, y1 = q[i].second;
            double x2 = q[j].first, y2 = q[j].second;
            if(!cmp(x1, x2)) continue;
            double a = (y1 / x1 - y2 / x2) / (x1 - x2);
            double b = y2 / x2 - a * x2;
            if(cmp(a, 0) &gt;= 0) continue;
            int st = 0;
            for(int k = 0; k &lt; n; k++)&#123;
                double x = q[k].first, y = q[k].second;
                if(!cmp(a * x * x + b * x, y)) st += 1 &lt;&lt; k;
            &#125;
            path[i][j] = st;
        &#125;
    &#125;
    memset(dp, 0x3f, sizeof(dp));
    dp[0] = 0;
    for(int i = 0; i + 1 &lt; 1 &lt;&lt; n; i++)&#123;
        int x = 0;
        for(int j = 0; j &lt; n; j++)&#123;
            if(!(i &gt;&gt; j &amp; 1))&#123;
                x = j;
                break;
            &#125;
        &#125;
        for(int j = 0; j &lt; n; j++)&#123;
            dp[i | path[x][j]] = min(dp[i | path[x][j]], dp[i] + 1);
        &#125;
    &#125;
    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1] &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><hr><h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><h3 id="没有上司的舞会🌸"><a href="#没有上司的舞会🌸" class="headerlink" title="没有上司的舞会🌸"></a>没有上司的舞会🌸</h3><ul><li>状态表示 $f[u][0&#x2F;1]$<ul><li>集合：所有从以 $u$ 为根的子树中选择，并且不选 $u$ 这个点的方案，所有从以 $u$ 为根的子树中选，并且选择 $u$ 这个点的方案</li><li>属性：最大值</li></ul></li><li>状态计算<ul><li>不选当前点 $u$，可以选择他的子节点 $s$，也可以不选，$f[u][0] +&#x3D; max (f[s_i][0], f[s_i][1])$</li><li>选择当前点 $u$，他的子节点 $s$ 一定不能选，$f[u][1] +&#x3D; f[s_i][0]$</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 6010;
int f[N][2];
int happy[N];
bool has_father[N];
int h[N], e[N], ne[N], idx;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u)&#123;
    f[u][1] = happy[u];
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        dfs(j);
        f[u][0] += max(f[j][1], f[j][0]);
        f[u][1] += f[j][0];
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; happy[i];
    &#125;
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(b, a);
        has_father[a] = 1;
    &#125;
    int root = 1;
    while(has_father[root])&#123;
        root++;
    &#125;
    dfs(root);
    cout &lt;&lt; max(f[root][0], f[root][1]) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-树的最长路径"><a href="#AcWing-树的最长路径" class="headerlink" title="AcWing|树的最长路径"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3NC8=">AcWing|树的最长路径</span></h3><ul><li>找树的直径，边权为 1<ul><li>任取一点为起点，找到距离该点最远的一个点 $u$ DFS&#x2F;BFS</li><li>再找到距离 $u$ 最远的一点 $v$ DFS&#x2F;BFS</li><li>$u$ 和 $v$ 之间的路径就是一条直径</li></ul></li><li>本题边权有正负，故用树形 DP 解决</li><li>枚举路径的中间节点</li><li>观察中间的某一个点，那么经过他的路径有：<ol><li>以其子树中的某个节点作为起点，以他作为终点的粉色路径</li><li>以其子树中的某个节点作为起点，以子树中的某个节点作为终点的蓝色路径</li><li>以其子树中的某个节点作为起点，以非其子树的节点作为终点的橙色路径</li></ol></li><li>对于第 $1$ 种情况，我们可以直接递归处理其子树，找出到当前子树根节点最长的路径长度即可</li><li>对于第 $2$ 种情况，我们在处理第 $1$ 种情况时，顺便找出 $1$ 类路径的次长路径</li><li>把最长和次长拼在一起，就是我们要的第 $2$ 种情况</li><li>而对于第 $3$ 种情况，我们可以把它归类为其祖先节点的第 $1,2$ 种情况，让其祖先节点去处理即可</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010, M = 2 * N;
int h[N], e[M], ne[M], w[M], idx;
int ans;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int dfs(int u, int fa)&#123;
    int dist = 0;   // 表示从当前点往下走的最大长度
    int d1 = 0, d2 = 0;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa) continue;
        int d = dfs(j, u) + w[i];
        dist = max(dist, d);
        if(d &gt; d1) d2 = d1, d1 = d;
        else if(d &gt; d2) d2 = d;
    &#125;
    ans = max(ans, d1 + d2);
    return dist;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n; cin &gt;&gt; n;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(b, a, c);
        add(a, b, c);
    &#125;
    dfs(1, -1);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-树的中心"><a href="#AcWing-树的中心" class="headerlink" title="AcWing|树的中心"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3NS8=">AcWing|树的中心</span></h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzY4MjUv">详细题解</span></li><li>本题即用到了用子节点更新父节点信息的普遍情况，又用到了用父节点更新子节点的情况</li><li>首先分析题目，其实是要我们把每一个点到其他点的最长距离求出来，再求一个其中最短的就可以了，我们来分析一下每一个点可以再树上怎么走，其实就是向上和向下走</li><li>我们用 $d1[u], d2[u], up[u], p1[u], p2[u]$分别存一下需要的信息，这些数据存的是：<ul><li>$d1[u]$：存下 $u$ 节点向下走的最长路径的长度</li><li>$d2[u]$：存下 $u$ 节点向下走的第二长的路径的长度</li><li>$p1[u]$：存下 $u$ 节点向下走的最长路径是从哪一个节点下去的</li><li>$p2[u]$：存下 $u$ 节点向下走的第二长的路径是从哪一个节点走下去的</li><li>$up[u]$：存下 $u$ 节点向上走的最长路径的长度</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010, M = 2 * N, INF = 0x3f3f3f3f;
int h[N], e[M], ne[M], w[M], idx;
int d1[N], d2[N], p1[N], p2[N], up[N];
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int dfs_d(int u, int fa)&#123;
    d1[u] = d2[u] = -INF;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == fa) continue;
        int d = dfs_d(j, u) + w[i];
        if(d &gt; d1[u])&#123;
            d2[u] = d1[u], d1[u] = d;
            p2[u] = p1[u], p1[u] = j;
        &#125;else if(d &gt; d2[u])&#123;
            d2[u] = d;
            p2[u] = j;
        &#125;
    &#125;
    if(d1[u] == -INF) d1[u] = d2[u] = 0;
    return d1[u];
&#125;
void dfs_u(int u, int s)&#123;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        if(j == s) continue;
        if(p1[u] == j) up[j] = max(up[u], d2[u]) + w[i];
        else up[j] = max(up[u], d1[u]) + w[i];
        dfs_u(j, u);
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n; cin &gt;&gt; n;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(b, a, c);
        add(a, b, c);
    &#125;
    dfs_d(1, -1);
    dfs_u(1, -1);
    int ans = INF;
    for(int i = 1; i &lt;= n; i++)&#123;
        ans = min(ans, max(d1[i], up[i]));
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-数字转换"><a href="#AcWing-数字转换" class="headerlink" title="AcWing|数字转换"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3Ny8=">AcWing|数字转换</span></h3><ul><li>由于任意正整数 $x$，的约数之和是唯一的，且本题要求只又约数之和小于自身才能转换，故对于所有的 $x$ 来说，他向小于自己的数转换的边至多只有一条，那就是 $x$ 的约数之和 $x′(x′&lt;x)$</li><li>建好图后，本题即可转换成在一个森林中，找出一个直径最长的树，并求它的直径</li><li>处理约数之和时，需要运用筛法的思想，可以降低时间复杂度</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 50010;
int h[N], e[N], ne[N], idx;
int sum[N];
bool st[N];
int ans;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
int dfs(int u)&#123;
    int d1 = 0, d2 = 0;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        int d = dfs(j) + 1;
        if(d &gt; d1) d2 = d1, d1 = d;
        else if(d &gt; d2) d2 = d;
    &#125;
    ans = max(ans, d1 + d2);
    return d1;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 2; j &lt;= n / i; j++)&#123;
            sum[i * j] += i;
        &#125;
    &#125;
    memset(h, -1, sizeof(h));
    for(int i = 2; i &lt;= n; i++)&#123;
        if(i &gt; sum[i])&#123;
            add(sum[i], i);
            st[i] = 1;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(!st[i])&#123;
            dfs(i);
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-二叉苹果树"><a href="#AcWing-二叉苹果树" class="headerlink" title="AcWing|二叉苹果树"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3Ni8=">AcWing|二叉苹果树</span></h3><ul><li>题目本身是有依赖的背包模型，区别在于把物品价值分给了边而不是点</li><li>对于一棵树来说，任意节点的入边（连向父节点的边）都是唯一的，所以边权和点权在确定树的根节点之后，可以视作一个东西（将入边价值视作该点价值）</li><li>对于本题来说，分组背包集合划分会导致超时，因此采用体积集合划分</li><li>状态表示 $f[i][j]$<ul><li>集合：以 $i$ 为根节点的子树，包含 $i$ 的连通块的边数不超过 $j$ 的方案</li><li>属性：最大值</li></ul></li><li>状态计算<ul><li>$f_{i,j} &#x3D; max\left { f_{i, j - 1 - k} + f_{son_i,k} + w_{edge_i} \right } ;;; k \in [0,j - 1]$</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110, M = N &lt;&lt; 1;
int h[N], e[M], ne[M], w[M], idx;
int f[N][N];
int n, m;
void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u, int fa)&#123;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        if(e[i] == fa) continue;
        dfs(e[i], u);
        for(int j = m; j &gt;= 0; j--)&#123;
            for(int k = 0; k &lt;= j - 1; k++)&#123;
                f[u][j] = max(f[u][j], f[u][j - k - 1] + f[e[i]][k] + w[i]);
            &#125;
        &#125;
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i &lt; n; i++)&#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(b, a, c);
        add(a, b, c);
    &#125;
    dfs(1, -1);
    cout &lt;&lt; f[1][m] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-战略游戏"><a href="#AcWing-战略游戏" class="headerlink" title="AcWing|战略游戏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzI1Lw==">AcWing|战略游戏</span></h3><ul><li>每条边上最少选择一个点，求最小权值</li><li>状态表示 $f[i][0&#x2F;1]$<ul><li>集合：所有在以 $i$ 为根的子树中选，且点 $i$ 的状态是 $j$ 的所有选法</li><li>属性：最小值</li></ul></li><li>状态计算<ul><li>$f[i][0]$，不选择当前点的方案，$f[i][0] &#x3D; min(\sum f[son_i][1])$</li><li>$f[i][1]$，选择当前点的方案，$f[i][1] &#x3D; min(\sum min(f[son_i][1], f[son_i][0]))$</li></ul></li><li><img data-src="https://cdn.acwing.com/media/article/image/2021/09/09/55909_968c7bc211-79306FEB-FC94-4BAB-95D3-327AECCCECEF(20210909-222.PNG)" alt="战略游戏"></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1510;

int h[N], e[N], ne[N], idx;
int f[N][2];
bool has_father[N];
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u)&#123;
    f[u][0] = 0;
    f[u][1] = 1;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        dfs(j);
        f[u][0] += f[j][1];
        f[u][1] += min(f[j][0], f[j][1]);
    &#125;
&#125;
int main()&#123;
    int n;
    while(~scanf(&quot;%d&quot;, &amp;n))&#123;
        memset(h, -1, sizeof(h));
        idx = 0;
        memset(has_father, 0, sizeof(has_father));
        for(int i = 1; i &lt;= n; i++)&#123;
            int a, b ,c;
            scanf(&quot;%d:(%d) &quot;, &amp;a, &amp;c);
            while(c--)&#123;
                scanf(&quot;%d&quot;, &amp;b);
                add(a, b);
                has_father[b] = 1;
            &#125;
        &#125;
        int root = 0;
        while(has_father[root])&#123;
            root++;
        &#125;
        dfs(root);
        printf(&quot;%d\n&quot;, min(f[root][0], f[root][1]));
    &#125;
&#125;
</code></pre><h3 id="AcWing-皇宫看守🌖"><a href="#AcWing-皇宫看守🌖" class="headerlink" title="AcWing|皇宫看守🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3OS8=">AcWing|皇宫看守</span>🌖</h3><ul><li>在战略游戏中，题目要求的放置方案是每条边都被观察到，而本题则是要求每个点都被观察到，因此同样使用树形 DP</li><li>如果只是要求 每条边 被 观察 到，那么我们在处理 父节点 时，枚举到一个 子节点 就可以直接进行讨论<ul><li>父节点放置哨兵，所有子节点都可放可不放哨兵</li><li>父节点不放哨兵，所有子节点都要放置哨兵</li></ul></li><li>但是在本题的要求中，每条边变成了每个点就会出现如下三种情况<ul><li>父节点放置哨兵，所有子节点都可放可不放哨兵</li><li>父节点不放哨兵，但是他至少有一个子节点放置哨兵，观察他</li><li>父节点不放哨兵，但父节点的父节点放置哨兵观察，则子节点可放可不放哨兵</li></ul></li><li>因此状态机模型如下<ol><li>被父节点观察（0）</li><li>被子节点观察（1）</li><li>被自己观察（2）</li></ol><ul><li><img data-src="https://cdn.acwing.com/media/article/image/2021/09/13/55909_d25b0f1713-EB1FDF4E-0D6A-4A7A-8FCF-D0F21B94443C(20210913-001.PNG)"></li></ul></li><li>状态表示 $f[i][0&#x2F;1&#x2F;2]$<ul><li>集合：以结点 $i$ 为根节点的子树，在 $i$ 点，状态为 $j$ 的方案</li><li>属性：最小值</li></ul></li><li>状态计算<ul><li>$f[i][0] &#x3D; \sum min(f[son_i][1], f[son_i][2]);$</li><li>$f[i][1] &#x3D; min(f[son_i][2] + \sum min(f[son_j][1], f[son_j][2])) ;;;(i \neq j)$</li><li>$f[i][2] &#x3D; \sum min\left {f[son_i][0], f[son_i][1], f[son_i][2] \right } + w_i$</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1510;
int h[N], e[N], ne[N], w[N], idx;
int f[N][3];
bool st[N];

void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u)&#123;
    f[u][0] = 0;
    f[u][1] = 0x3f3f3f3f;   // f[u][1] 求最小值，初始化为最大值
    f[u][2] = w[u];
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        dfs(j);
        f[u][0] += min(f[j][1], f[j][2]);
        f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]);
    &#125;
    for(int i = h[u]; ~i; i = ne[i])&#123;
        int j = e[i];
        // f[u][0] 中记录了 sum(min(f[j][1], f[j][2])), 再从中减去对应贡献即可得到剩余的
        f[u][1] = min(f[u][1], f[u][0] + f[j][2] - min(f[j][1], f[j][2]));
    &#125;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    memset(h, -1, sizeof(h));
    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        int id, cnt, cost;
        cin &gt;&gt; id &gt;&gt; cost &gt;&gt; cnt;
        w[id] = cost;
        while(cnt--)&#123;
            int ver;
            cin &gt;&gt; ver;
            add(id, ver);
            st[ver] = 1;
        &#125;
    &#125;
    int root = 1;
    while(st[root])&#123;
        root++;
    &#125;
    dfs(root);
    cout &lt;&lt; min(f[root][1], f[root][2]) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><hr><h2 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h2><ul><li>使用<ul><li>求满足一个性质的所有数时使用。</li></ul></li><li>技巧<ul><li>$[X, Y] ; -&gt; ; f (Y) - f (X - 1)$</li><li>从树的角度来考虑, 把整个数拆成每一位，从最高位向最低位看。设当前这一位为 $x$，则当前位分成 $[0, x)$ 和 $x$ 两种情况，即为树的两个分支，左分支大多都能通过公式获得。答案即为树的全部左分支加起来再加上最右的叶子。</li></ul></li><li>模板<ul><li>预处理通常为 DP 或组合数。在分类讨论计算答案时，和预处理的 DP 过程类似。</li></ul></li></ul><pre><code class="cpp">void init() // 根据题意做预处理。
&#123;
    for(int i = 0; i &lt;= 9; i ++) // 对第一位初始化
        f[1][i] = 1;

    // DP过程
&#125;

int dp(int n)
&#123;
    if(!n) return 1;
    vector&lt;int&gt; num;
    // 取出每一位数字，可以根据进制转化问题替换 10
    while(n) num.push_back(n % 10), n /= 10; 
    n = num.size();

    LL ans = 0;
    int last = 0;
    for(int i = n - 1; i &gt;= 0; i --)
    &#123;
        int x = num[i];

        // 分类讨论
    &#125;

    return ans;
&#125;
</code></pre><h3 id="AcWing-度的数量"><a href="#AcWing-度的数量" class="headerlink" title="AcWing|度的数量"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4My8=">AcWing|度的数量</span></h3><ul><li>首先我们把数字 $n$ 对于 $B$ 进制来进行分解，将每一位上的数字存入一个数组中，然后从高位往低位去讨论，</li><li>对于第 $i$ 位数字 $x$ 有三种情况<ul><li>$x &#x3D; 0$ ：则 $i$ 位上只能取 $0$ ，所以直接讨论 $i-1$ 位就可以了</li><li>$x &#x3D; 1$ ：则 $i$ 位上取 $0$ 的时候，后面 $i-1$ 位都可以随意取值，取 $1$ 的时候，后面 $i- 1$ 位要再小于题目的数的前提下取值，并且能取 $k-last-1$ 个 $1$</li><li>$x &gt; 1$ ：则 $i$ 位上可以取 $1$ ，$0$ ，并且后面 $i-1$ 位可以随便取。</li></ul></li><li>这里 $i-1$ 位随便取和对于 $i-1$ 位讨论的区别，就体现在前一个直接用组合数 $f[i-1][k-last]$ 就可以，后面则需要再进入循环去讨论。</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 35;
int f[N][N];
int K, B;
void init()&#123;
    for(int i = 0; i &lt; N; i++)&#123;
        for(int j = 0; j &lt;= i; j++)&#123;
            if(!j) f[i][j] = 1;
            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];
        &#125;
    &#125;
&#125;
int dp(int n)&#123;
    if(!n) return 0;
    vector&lt;int&gt; nums;
    while(n)&#123;
        nums.push_back(n % B);
        n /= B;
    &#125;
    int ans = 0;
    int last = 0;
    for(int i = nums.size() - 1; i &gt;= 0; i--)&#123;
        int x = nums[i];
        if(x &gt; 0)&#123;
            ans += f[i][K - last];
            if(x &gt; 1)&#123;
                if(K - last - 1 &gt;= 0) ans += f[i][K - last - 1];
                break;
            &#125;else&#123;
                last++;
                if(last &gt; K) break;
            &#125;
        &#125;
        if(i == 0 &amp;&amp; last == K) ans++;
    &#125;
    return ans;
&#125;
int main()&#123;
    init();
    int l, r;
    cin &gt;&gt; l &gt;&gt; r &gt;&gt; K &gt;&gt; B;
    cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-数字游戏"><a href="#AcWing-数字游戏" class="headerlink" title="AcWing|数字游戏"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4NC8=">AcWing|数字游戏</span></h3><ul><li>同上一题，先求 $0 \sim N$ 中不降数的个数</li><li>状态表示 $f[i][j]$<ul><li>集合：所有最高位是 $j$，且一共有 $i$ 位的不降数的集合</li><li>属性：数量</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 15;
int f[N][N];
void init()&#123;
    for(int i = 0; i &lt;= 9; i++)&#123;
        f[1][i] = 1;
    &#125;
    for(int i = 2; i &lt; N; i++)&#123;
        for(int j = 0; j &lt;= 9; j++)&#123;
            for(int k = j; k &lt;= 9; k++)&#123;
                f[i][j] += f[i - 1][k];
            &#125;
        &#125;
    &#125;
&#125;
int dp(int n)&#123;
    if(!n) return 1;
    vector&lt;int&gt; num;
    while(n)&#123;
        num.push_back(n % 10);
        n /= 10;
    &#125;
    int ans = 0, last = 0;
    for(int i = num.size() - 1; i &gt;= 0; i--)&#123;
        int x = num[i];
        // 左边分支,因为要保持不降序,所以j &gt;= last
        for(int j = last; j &lt; x; j++)&#123;
            ans += f[i + 1][j];
        &#125;
        // 如果上一位最大值大于x的话,不构成非降序,所以右边分支结束
        if(last &gt; x) break;
        last = x;
        // 全部枚举完了也同样构成一种方案
        if(!i) ans++;
    &#125;
    return ans;
&#125;
int main()&#123;
    int n, m;
    init();
    while(cin &gt;&gt; n &gt;&gt; m)&#123;
        cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><hr><h3 id="AcWing-Windy-数"><a href="#AcWing-Windy-数" class="headerlink" title="AcWing|Windy 数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4NS8=">AcWing|Windy 数</span></h3><ul><li>基本模板同上</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzE1NTYyLw==">详细题解</span></li><li>需要判断数是否小于 $n$ 位，因为没有前导零</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 15;
int f[N][N];
// f[i][j] 表示一共有i位，且最高为是数字j的满足wingy数定义的数的个数
void init()&#123;
    for(int i = 0; i &lt;= 9; i++)&#123;
        f[1][i] = 1;
    &#125;
    for(int i = 2; i &lt;= N; i++)&#123;
        for(int j = 0; j &lt;= 9; j++)&#123;
            for(int k = 0; k &lt;= 9; k++)&#123;
                if(abs(j - k) &gt;= 2) f[i][j] += f[i - 1][k];
            &#125;
        &#125;
    &#125;
&#125;
int dp(int n)&#123;
    if(!n) return 0;
    vector&lt;int&gt; num;
    while(n)&#123;
        num.push_back(n % 10);
        n /= 10;
    &#125;
    int ans = 0, last = -1;
    for(int i = num.size() - 1; i &gt;= 0; i--)&#123;
        int x = num[i];
        for(int j = (i == num.size() - 1); j &lt; x; j++)&#123;
            if(abs(j - last) &gt;= 2) ans += f[i + 1][j];
        &#125;
        if(abs(last - x) &lt; 2) break;
        last = x;
        if(!i) ans++;
    &#125;
    for(int i = 1; i &lt;= num.size() - 1; i++)&#123;
        for(int j = 1; j &lt;= 9; j++)&#123;
            ans += f[i][j];
        &#125;
    &#125;
    return ans;
&#125;
int main()&#123;
    int n, m;
    init();
    cin &gt;&gt; n &gt;&gt; m;
    cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre><h3 id="AcWing-数字游戏-Ⅱ"><a href="#AcWing-数字游戏-Ⅱ" class="headerlink" title="AcWing|数字游戏 Ⅱ"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4Ni8=">AcWing|数字游戏 Ⅱ</span></h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzE1NTU2Lw==">详细题解</span></li><li>$f[i][j][k]$ 表示一共有 $i$ 位，且最高位数字是 $j$，且所有位数字和 $MOD ; P$ 结果为 $k$ 的数的个数。</li><li>状态计算：<ul><li>由于第 $i$ 位已经是 $j$，且所有数字之和 $MOD ; P$ 为 $k$，所以我们考虑第 $i - 1$ 位，假设第 $i - 1$ 位数字是 $x$，由于 $j$ 已经知道，那么剩下的 $i - 1$ 位数字之和取模后就是 $(k - j) MOD P$</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 11, M = 110;
int f[N][10][M];
int P;
int mod(int u, int v)&#123;
    return (u % v + v) % v;
&#125;
void init()&#123;
    memset(f, 0, sizeof(f));
    for(int i = 0; i &lt;= 9; i++) f[1][i][i % P]++;
    for(int i = 2; i &lt; N; i++)&#123;
        for(int j = 0; j &lt;= 9; j++)&#123;
            for(int k = 0; k &lt; P; k++)&#123;
                for(int x = 0; x &lt;= 9; x++)&#123;
                    f[i][j][k] += f[i - 1][x][mod(k - j, P)];
                &#125;
            &#125;
        &#125;
    &#125; 
&#125;
int dp(int n)&#123;
    if(!n) return 1;
    vector&lt;int&gt; nums;
    while(n)&#123;
        nums.push_back(n % 10);
        n /= 10;
    &#125;
    int ans = 0, last = 0;
    for(int i = nums.size() - 1; i &gt;= 0; i--)&#123;
        int x = nums[i];
        for(int j = 0; j &lt; x; j++)&#123;
            ans += f[i + 1][j][mod(-last, P)];
        &#125;
        last += x;
        if(!i &amp;&amp; last % P == 0) ans++;
    &#125;
    return ans;
&#125;
int main()&#123;
    int l, r;
    while(cin &gt;&gt; l &gt;&gt; r &gt;&gt; P)&#123;
        init();
        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre><h3 id="AcWing-不要-62"><a href="#AcWing-不要-62" class="headerlink" title="AcWing|不要 62"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4Ny8=">AcWing|不要 62</span></h3><ul><li>数位 DP + 状态机 DP</li><li>基本分析同其他数位 DP 题一样，难点是求左边分支</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 15;
int f[N][N];
void init()&#123;
    for(int i = 0; i &lt;= 9; i++)&#123;
        if(i != 4)&#123;
            f[1][i] = 1;
        &#125;
    &#125;
    for(int i = 2; i &lt; N; i++)&#123;
        for(int j = 0; j &lt;= 9; j++)&#123;
            if(j == 4) continue;
            // k 表示第 i - 1 位我填的什么，i - 1 位是我们之前填好的，所以可以拿来用
            for(int k = 0; k &lt;= 9; k++)&#123;
                if(k == 4 || j == 6 &amp;&amp; k == 2) continue;
                f[i][j] += f[i - 1][k];
            &#125;
        &#125;
    &#125;
&#125;
int dp(int n)&#123;
    if(!n) return 1;
    vector&lt;int&gt; num;
    while(n)&#123;
        num.push_back(n % 10);
        n /= 10;
    &#125;
    int ans = 0, last = 0;
    for(int i = num.size() - 1; i &gt;= 0; i--)&#123;
        int x = num[i];
        for(int j = 0; j &lt; x; j++)&#123;
            if(j == 4 || last == 6 &amp;&amp; j == 2) continue;
            ans += f[i + 1][j];
        &#125;
        if(x == 4 || last == 6 &amp;&amp; x == 2) break;
        last = x;
        if(!i) ans++;
    &#125;
    return ans;
&#125;
int main()&#123;
    init();
    int l, r;
    while(cin &gt;&gt; l &gt;&gt; r, l || r)&#123;
        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><h3 id="AcWing-摘花生"><a href="#AcWing-摘花生" class="headerlink" title="AcWing|摘花生"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNy8=">AcWing|摘花生</span></h3><pre><code class="cpp">for(int i = 1; i &lt;= r; i++)&#123;
    for(int j = 1; j &lt;= c; j++)&#123;
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + w[i][j];
    &#125;
&#125;
cout &lt;&lt; dp[r][c] &lt;&lt; endl;
</code></pre><h3 id="AcWing-最低通行费"><a href="#AcWing-最低通行费" class="headerlink" title="AcWing|最低通行费"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMC8=">AcWing|最低通行费</span></h3><pre><code class="cpp">for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = 1; j &lt;= n; j++)&#123;
        if(i == 1 &amp;&amp; j == 1) dp[i][j] = w[i][j];
        else&#123;
            dp[i][j] = INF;
            if(i &gt; 1) dp[i][j] = min(dp[i][j], dp[i - 1][j] + w[i][j]);
            if(j &gt; 1) dp[i][j] = min(dp[i][j], dp[i][j - 1] + w[i][j]);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[n][n] &lt;&lt; endl;
</code></pre><h3 id="AcWing-方格取数🌸"><a href="#AcWing-方格取数🌸" class="headerlink" title="AcWing|方格取数🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyOS8=">AcWing|方格取数</span>🌸</h3><ul><li><strong>为何不能分开走</strong><ul><li>第一次走为局部最优并且也对第二次走造成了影响，第二次走是在第一次影响下所能走的局部最优，不具备“无后效性”，因此分开两次走并不是全局最优解。</li></ul></li><li>状态表示<ul><li>把 $dp[i_1][j_1][i_2][j_2]$ 转化为 $dp[k][i_1][i_2]$，其中 $k &#x3D; i_1 + j_1 &#x3D; i_2 + j_2$，即等价于 $dp[i_1][k - i_1][i_2][k - i_2]$。</li><li>因此，在处理两次走到相同点的时候，可以转化为<strong>在 $i_1 &#x3D; i_2$ 和 $j_1 &#x3D; j_2$ 时</strong>，只取一次 $w[i_1][j_1]$ 的值</li><li>观察可发现，当两条路径走的步长相同时，才有可能出现重复点。</li><li>又因为每步同时走 $i_1 + j_1 &#x3D; i_2 + j_2$ 必然成立，因此令前面的和为 $k$，状态表示为 $dp[k][i_1][i_2]$。</li></ul></li><li>状态计算<ul><li>可分为四种，一起向右走、一起向下走、一下一右。</li><li>$k - 1 &#x3D; i_1 + j_1 - 1 &#x3D; i_2 + j_2 - 1$ 可分别转换成四种状态转移，取这四种状态集合的 $max$ 即可。</li><li>$i_1 &#x3D; i_2$ 代表路径在该点重合。</li></ul></li></ul><pre><code class="cpp">for(int k = 2; k &lt;= 2 * n; k++)&#123;
    for(int i1 = 1; i1 &lt;= n; i1++)&#123;
        for(int i2 = 1; i2 &lt;= n; i2++)&#123;
            int j1 = k - i1, j2 = k - i2;
            if(j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n)&#123;
                int t = w[i1][j1];
                if(i1 != i2) t += w[i2][j2];
                int &amp;x = dp[k][i1][i2];
                x = max(x, dp[k - 1][i1 - 1][i2 - 1] + t);
                x = max(x, dp[k - 1][i1 - 1][i2] + t);
                x = max(x, dp[k - 1][i1][i2 - 1] + t);
                x = max(x, dp[k - 1][i1][i2] + t);
            &#125;
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[2 * n][n][n] &lt;&lt; endl;
</code></pre><h3 id="AcWing-传纸条🌸"><a href="#AcWing-传纸条🌸" class="headerlink" title="AcWing|传纸条🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjc3Lw==">AcWing|传纸条</span>🌸</h3><ul><li>可以证明与 <em>方格取数</em> 相同。<ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzEyMzg5Lw==">证明</span></li></ul></li><li>代码</li></ul><pre><code class="cpp">for(int k = 2; k &lt;= n + m; k++)&#123;
    for(int i = 1; i &lt; k; i++)&#123;
        for(int j = 1; j &lt; k; j++)&#123;
            int j1 = k - i, j2 = k - j;
            int &amp;x = dp[k][i][j];
            int t = w[i][j1];
            if(i != j) t += w[j][j2];
            x = max(x, dp[k - 1][i - 1][j - 1] + t);
            x = max(x, dp[k - 1][i - 1][j] + t);
            x = max(x, dp[k - 1][i][j - 1] + t);
            x = max(x, dp[k - 1][i][j] + t);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[n + m][n][n] &lt;&lt; endl;
</code></pre><hr><h2 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h2><h3 id="AcWing-怪盗基德的滑翔翼"><a href="#AcWing-怪盗基德的滑翔翼" class="headerlink" title="AcWing|怪盗基德的滑翔翼"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxOS8=">AcWing|怪盗基德的滑翔翼</span></h3><ul><li>两个方向都求一下 $LIS$</li></ul><pre><code class="cpp">for(int i = 1; i &lt;= n; i++)&#123;
    dp1[i] = 1;
    for(int j = 1; j &lt; i; j++)&#123;
        if(w[i] &gt; w[j]) dp1[i] = max(dp1[i], dp1[j] + 1);
    &#125;
    ans = max(ans, dp1[i]);
&#125;
for(int i = n; i &gt;= 1; i--)&#123;
    dp2[i] = 1;
    for(int j = n; j &gt; i; j--)&#123;
        if(w[i] &gt; w[j]) dp2[i] = max(dp2[i], dp2[j] + 1);
    &#125;
    ans = max(ans, dp2[i]);
&#125;
cout &lt;&lt; ans &lt;&lt; endl;
</code></pre><h3 id="AcWing-登山"><a href="#AcWing-登山" class="headerlink" title="AcWing|登山"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNi8=">AcWing|登山</span></h3><ul><li>两端求 $LIS$，最后遍历每个点。</li></ul><pre><code class="cpp">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
for(int i = 1; i &lt;= n; i++)&#123;
    dp1[i] = 1;
    for(int j = 1; j &lt; i; j++)&#123;
        if(w[i] &gt; w[j]) dp1[i] = max(dp1[i], dp1[j] + 1);
    &#125;
&#125;
for(int i = n; i &gt;= 1; i--)&#123;
    dp2[i] = 1;
    for(int j = n; j &gt; i; j--)&#123;
        if(w[i] &gt; w[j]) dp2[i] = max(dp2[i], dp2[j] + 1);
    &#125;
&#125;
int ans = 0;
for(int i = 1; i &lt;= n; i++) ans = max(ans, dp1[i] + dp2[i] - 1);
cout &lt;&lt; ans &lt;&lt; endl;
</code></pre><h3 id="AcWing-合唱队形"><a href="#AcWing-合唱队形" class="headerlink" title="AcWing|合唱队形"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDg0Lw==">AcWing|合唱队形</span></h3><ul><li>与 <em>登山</em> 几乎一致。</li></ul><pre><code class="cpp">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
for(int i = 1; i &lt;= n; i++)&#123;
    dp1[i] = 1;
    for(int j = 1; j &lt; i; j++)&#123;
        if(w[i] &gt; w[j]) dp1[i] = max(dp1[i], dp1[j] + 1);
    &#125;
&#125;
for(int i = n; i &gt;= 1; i--)&#123;
    dp2[i] = 1;
    for(int j = n; j &gt; i; j--)&#123;
        if(w[i] &gt; w[j]) dp2[i] = max(dp2[i], dp2[j] + 1);
    &#125;
&#125;
int ans = 0;
for(int i = 1; i &lt;= n; i++) ans = max(ans, dp1[i] + dp2[i] - 1);
cout &lt;&lt; n - ans &lt;&lt; endl;
</code></pre><h3 id="AcWing-友好城市"><a href="#AcWing-友好城市" class="headerlink" title="AcWing|友好城市"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNC8=">AcWing|友好城市</span></h3><ul><li>对一端的城市排序后即可转换成 $LIS$ 问题。</li><li>简单数据版本</li></ul><pre><code class="cpp">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; city[i].first &gt;&gt; city[i].second;
sort(city + 1, city + n + 1);
for(int i = 1; i &lt;= n; i++)&#123;
    dp[i] = 1;
    for(int j = 1; j &lt; i; j++)&#123;
        if(city[i].second &gt; city[j].second) dp[i] = max(dp[i], dp[j] + 1);
    &#125;
    ans = max(ans, dp[i]);
&#125;
cout &lt;&lt; ans &lt;&lt; endl;
</code></pre><ul><li>加强数据版本（使用二分）</li></ul><pre><code class="cpp">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; city[i].first &gt;&gt; city[i].second;
sort(city + 1, city + n + 1);
for(int i = 1; i &lt;= n; i++)&#123;
    int l = 0, r = ans;
    while(l &lt; r)&#123;
        int mid = l + r + 1 &gt;&gt; 1;
        if(dp[mid] &lt; city[i].second) l = mid;
        else r = mid - 1;
    &#125;
    ans = max(ans, l + 1);
    dp[l + 1] = city[i].second;
&#125;
cout &lt;&lt; ans &lt;&lt; endl;

// 或者使用 lower_bound

*lower_bound(dp + 1, dp + ans + 1, city[i].second) = city[i].second;
</code></pre><h3 id="AcWing-最大上升子序列和"><a href="#AcWing-最大上升子序列和" class="headerlink" title="AcWing|最大上升子序列和"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxOC8=">AcWing|最大上升子序列和</span></h3><pre><code class="cpp">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
for(int i = 1; i &lt;= n; i++)&#123;
    dp[i] = w[i];
    for(int j = 1; j &lt; i; j++)&#123;
        if(w[i] &gt; w[j]) dp[i] = max(dp[i], dp[j] + w[i]);
    &#125;
    ans = max(ans, dp[i]);
&#125;
cout &lt;&lt; ans &lt;&lt; endl;
</code></pre><h3 id="AcWing-拦截导弹"><a href="#AcWing-拦截导弹" class="headerlink" title="AcWing|拦截导弹"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxMi8=">AcWing|拦截导弹</span></h3><details><summary>贪心证明</summary><a href="https://www.acwing.com/solution/content/52042/">贪心证明</a></details><ul><li>$O(n^2)$ dp + 贪心<ul><li>题目的第二问，对于第 $i$ 号导弹，要么选择末尾导弹高度最小的拦截系统，要么新创一个拦截系统，用一个数字即每套拦截系统此时所拦截的最后一个导弹高度，来表示该系统。</li><li>这样就可以得到一个数组，数组最终长度就是所需要的最少拦截系统数。</li></ul></li></ul><pre><code class="cpp">int cnt = 0, ans = 0;
for(int i = 1; i &lt;= n; i++)&#123;
    dp[i] = 1;
    for(int j = 1; j &lt; i; j++)&#123;
        if(h[i] &lt;= h[j]) dp[i] = max(dp[i], dp[j] + 1);
    &#125;
    ans = max(ans, dp[i]);
    // 更新子序列
    int k = 0;
    while(k &lt; cnt &amp;&amp; q[k] &lt; h[i]) k++;
    if(k == cnt) q[cnt++] = h[i];
    else q[k] = h[i];
&#125;
cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;
</code></pre><ul><li>$O(nlogn)$ 贪心 + 贪心</li></ul><pre><code class="cpp">//cnt表示导弹系统数，ans表示一个系统最多能拦截的导弹数
int cnt = 0, ans = 0;
int a;
while(cin &gt;&gt; a)
&#123;
    //pos1表示以a结尾的最长不升子序列长度
    int pos1 = upper_bound(f, f + ans, a, greater&lt;int&gt;()) - f; // 数组降序所以加上参数
    if(pos1 == ans) f[ans++] = a;
    else f[pos1] = a;

    int pos2 = lower_bound(g, g + cnt, a) - g;
    if(pos2 == cnt) g[cnt++] = a;
    else g[pos2] = a;
&#125;
cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;
</code></pre><h3 id="AcWing-导弹防御系统🌸"><a href="#AcWing-导弹防御系统🌸" class="headerlink" title="AcWing|导弹防御系统🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTg5Lw==">AcWing|导弹防御系统</span>🌸</h3><details><summary>迭代加深解法</summary>一般平均答案深度较低时可以采用这种方式。 <a href="https://www.acwing.com/solution/content/4258/">迭代加深题解</a></details><ul><li>我们很自然地会想到 $LIS$ 算法，不过这里的条件是一套防御系统的导弹拦截高度要么一直上升要么一直下降，所以用 $LIS$ 是不正确的。</li><li>而在 $LIS$ 中，最核心的思想在于能否将一个元素加入到序列中，只与这个序列目前的最后一个元素有关。<ul><li>因此用 $up[k]$ 和 $down[k]$ 记录第 $k$ 套上升（下降）系统目前所拦截的最后一个导弹。</li><li>$dfs(u, su, sd)$ 意味着已有 $su$ 个上升，$sd$ 个下降，正在处理第 $u$ 个数。</li></ul></li><li>在扩展节点时存在一个贪心策略<ul><li>假设现在要把一个数放入一个上升序列，那么一定是所有能放入的上升序列中，最后一个元素最大的那一个。</li><li>对于上升序列，能放入最大的那个就放入最大的那个。</li></ul></li><li>复杂度 $O(n2^n)$</li></ul><pre><code class="cpp">int q[N], ans, up[N], down[N], n;
void dfs(int u, int su, int sd) &#123;
    if (su + sd &gt;= ans) return; // ans不可能再小了
    if (u == n) &#123;
        ans = su + sd;  // su, sd 分别表示 len(up[]), len(down[])
        return;
    &#125;
    // 情况1：将当前数放到上升子序列中
    int k = 0;
    while (k &lt; su &amp;&amp; up[k] &gt;= q[u]) k++;
    int t = up[k];
    up[k] = q[u];
    if (k &lt; su) dfs(u + 1, su, sd);
    else dfs(u + 1, su + 1, sd);
    up[k] = t;
    // 情况2：将当前数放到下降子序列中。
    k = 0;
    while (k &lt; sd &amp;&amp; down[k] &lt;= q[u]) k++;
    t = down[k];
    down[k] = q[u];
    if (k &lt; sd) dfs(u + 1, su, sd);
    else dfs(u + 1, su, sd + 1);
    down[k] = t;
&#125;
void solve()&#123;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i];
    ans = n;
    dfs(0, 0, 0);
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-最大公共上升子序列🌸"><a href="#AcWing-最大公共上升子序列🌸" class="headerlink" title="AcWing|最大公共上升子序列🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjc0Lw==">AcWing|最大公共上升子序列</span>🌸</h3><ul><li>这题是 <em>最长上升子序列</em> 和 <em>最长公共子序列</em> 的结合版，在状态表示和状态计算上都融合了这两道题的方法。</li><li>状态表示<ul><li>$f[i][j]$ 代表所有 $a[1 \sim j]$ 中以 $b[j]$ 结尾的公共上升子序列的集合。</li><li>$f[i][j]$ 的值等于该集合的子序列中长度的最大值。</li></ul></li><li>状态计算<ul><li>首先依据公共子序列中是否包含 $a[i]$，将 $f[i][j]$ 所代表的集合划分成两个不重不漏的子集：<ol><li>不包含 $a[i]$ 的子集，最大值是 $f[i - 1][j]$。</li><li>包含 $a[i]$ 的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在 $b[]$ 中是哪个数。<ul><li>子序列只包含 $b[j]$ 一个数，长度是 $1$.</li><li>子序列的倒数第二个数是 $b[1]$ 的集合，最大长度是 $f[i - 1][1] + 1$。</li><li>…</li><li>子序列的倒数第二个数是 $b[j - 1]$ 的集合，最大长度是 $f[i - 1][j - 1] + 1$。</li></ul></li></ol></li><li>如果直接按上述思路实现，需要三重循环。</li></ul></li></ul><pre><code class="cpp">for (int i = 1; i &lt;= n; i ++ )&#123;
    for (int j = 1; j &lt;= n; j ++ )&#123;
        f[i][j] = f[i - 1][j];
        if (a[i] == b[j])&#123;
            int maxv = 1;
            for (int k = 1; k &lt; j; k ++ )
                if (a[i] &gt; b[k])
                    maxv = max(maxv, f[i - 1][k] + 1);
            f[i][j] = max(f[i][j], maxv);
        &#125;
    &#125;
&#125;
</code></pre><ul><li>然后我们发现每次循环求得的 $maxv$ 是满足 $a[i] &gt; b[k]$ 的 $f[i - 1][k] + 1$ 的前缀最大值。因此可以直接将 $maxv$ 提到第一层循环外面，减少重复计算，此时只剩下两重循环。</li><li>最终答案枚举子序列结尾取最大值即可。</li><li>时间复杂度 $O(n^2)$</li></ul><pre><code class="cpp">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
for(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i];
for(int i = 1; i &lt;= n; i++)&#123;
    int maxv = 1;
    for(int j = 1; j &lt;= n; j++)&#123;
        f[i][j] = f[i - 1][j];
        if(a[i] == b[j]) f[i][j] = max(f[i][j], maxv);
        if(a[i] &gt; b[j]) maxv = max(maxv, f[i - 1][j] + 1);
    &#125;
&#125;
int ans = 0;
for(int i = 1; i &lt;= n; i++) ans = max(ans, f[n][i]);
cout &lt;&lt; ans &lt;&lt; endl;
</code></pre><hr><h2 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h2><h3 id="AcWing-采药"><a href="#AcWing-采药" class="headerlink" title="AcWing|采药"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDI1Lw==">AcWing|采药</span></h3><ul><li>01 背包裸题</li></ul><pre><code class="cpp">int T, M;
cin &gt;&gt; T &gt;&gt; M;
for(int i = 1; i &lt;= M; i++) cin &gt;&gt; t[i] &gt;&gt; w[i];
for(int i = 1 ;i &lt;= M; i++)&#123;
    for(int j = T; j &gt;= t[i]; j--)&#123;
        dp[j] = max(dp[j], dp[j - t[i]] + w[i]);
    &#125;
&#125;
cout &lt;&lt; dp[T] &lt;&lt; endl;
</code></pre><h3 id="AcWing-装箱问题"><a href="#AcWing-装箱问题" class="headerlink" title="AcWing|装箱问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyNi8=">AcWing|装箱问题</span></h3><pre><code class="cpp">int V, n;
cin &gt;&gt; V &gt;&gt; n;
for(int i = 1; i &lt;= n; i++)&#123;
    int v;
    cin &gt;&gt; v;
    for(int j = V; j &gt;= v; j--)&#123;
        dp[j] = max(dp[j], dp[j - v] + v);
    &#125;
&#125;
cout &lt;&lt; V - dp[V] &lt;&lt; endl;
</code></pre><h3 id="AcWing-二位费用的背包问题"><a href="#AcWing-二位费用的背包问题" class="headerlink" title="AcWing|二位费用的背包问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOC8=">AcWing|二位费用的背包问题</span></h3><pre><code class="cpp">int n, V, M;
cin &gt;&gt; n &gt;&gt; V &gt;&gt; M;
for(int i = 1; i &lt;= n; i++)&#123;
    int v, m, w;
    cin &gt;&gt; v &gt;&gt; m &gt;&gt; w;
    for(int j = V; j &gt;= v; j--)&#123;
        for(int k = M; k &gt;= m; k--)&#123;
            dp[j][k] = max(dp[j][k], dp[j - v][k - m] + w);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[V][M] &lt;&lt; endl;
</code></pre><h3 id="AcWing-宠物小精灵之收服"><a href="#AcWing-宠物小精灵之收服" class="headerlink" title="AcWing|宠物小精灵之收服"></a><a href="">AcWing|宠物小精灵之收服</a></h3><ul><li>在背包问题中，体积 $w$ 与价值 $v$ 是可以互逆的！可以将 $f[i]$ 表示为体积为 $i$ 能装的最大价值，也可以将 $f[i]$ 表示为价值为 $i$ 所需的最小体积。两者等价，我们只需要选择范围较小的那维作为体就可以了！这直接影响到时空复杂度。</li><li>这题就是个案例。</li><li>同时，该题也是个 <strong>01 背包</strong> 的扩展 —— <strong>二维费用 01 背包问题</strong></li><li>把 <em>野生宝可梦</em> 看作物品，则捕捉他需要的 <em>精灵球</em> 个数就是第一费用，战斗时皮卡丘要减少的血量就是第二费用。</li><li>最后答案要求物品数量最多，因此我们可以用状态的属性来表示选择的物品数</li></ul><pre><code class="cpp">int N, M, K;
cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;	// 精灵球数量；皮卡丘初始的体力值、野生小精灵的数量
for(int i = 1; i &lt;= K; i++)&#123;
    int v1, v2;
    cin &gt;&gt; v1 &gt;&gt; v2;
    for(int j = N; j &gt;= v1; j--)&#123;
        for(int k = M - 1; k &gt;= v2; k--)&#123;
            dp[j][k] = max(dp[j][k], dp[j - v1][k - v2] + 1);
        &#125;
    &#125;
&#125;
int cost_health = M;	// 消耗的体力值的最小值
for(int i = 0; i &lt;= M - 1; i++)&#123;
    if(dp[N][i] == dp[N][M - 1]) cost_health = min(cost_health, i);
&#125;
cout &lt;&lt; dp[N][M - 1] &lt;&lt; &quot; &quot; &lt;&lt; M - cost_health &lt;&lt; endl;
</code></pre><h3 id="AcWing-多重背包问题-Ⅲ🌸"><a href="#AcWing-多重背包问题-Ⅲ🌸" class="headerlink" title="AcWing|多重背包问题 Ⅲ🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNi8=">AcWing|多重背包问题 Ⅲ</span>🌸</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUzNTA3Lw==">详细证明</span></li><li>求滑动窗口内的最大值<ul><li>滑动窗口大小随每种物品可选个数变化</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 200010;
int n, m; // 种类数，总体积大小
int f[N], g[N], q[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++)&#123;
        int v, w, s;
        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        memcpy(g, f, sizeof(f));
        for(int j = 0; j &lt; v; j++)&#123; // 枚举余数
            int hh = 0, tt = -1;
            for(int k = j; k &lt;= m; k += v)&#123;
                if(hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh++;
                while(hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt--;
                q[++tt] = k;
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; f[m] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-潜水员"><a href="#AcWing-潜水员" class="headerlink" title="AcWing|潜水员"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMi8=">AcWing|潜水员</span></h3><ul><li>只要有一维的体积为 $0$ ，则另一维一定为 $0$。</li><li>若有一维小于 $0$ ，则可以看作是从 $0$ 开始转移。</li><li>求最小值</li></ul><pre><code class="cpp">memset(dp, 0x3f, sizeof(dp));
dp[0][0] = 0;
int n, m, q;
cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
for(int i = 1; i &lt;= q; i++)&#123;
    int a, b, w;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
    for(int j = n; j &gt;= 0; j--)&#123;
        for(int k = m; k &gt;= 0; k--)&#123;
            dp[j][k] = min(dp[j][k], dp[max(0, j - a)][max(0, k - b)] + w);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[n][m] &lt;&lt; endl;
</code></pre><h3 id="AcWing-数字组合"><a href="#AcWing-数字组合" class="headerlink" title="AcWing|数字组合"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjgwLw==">AcWing|数字组合</span></h3><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
dp[0] = 1;
for(int i = 1; i &lt;= n; i++)&#123;
    int x;
    cin &gt;&gt; x;
    for(int j = m; j &gt;= x; j--)&#123;
        dp[j] += dp[j - x];
    &#125;
&#125;
cout &lt;&lt; dp[m] &lt;&lt; endl;
</code></pre><h3 id="AcWing-庆功会"><a href="#AcWing-庆功会" class="headerlink" title="AcWing|庆功会"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMS8=">AcWing|庆功会</span></h3><ul><li>多重背包裸题，朴素版即可 AC 。</li></ul><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= n; i++)&#123;
    int v, w, s;
    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
    for(int j = m; j &gt;= v; j--)&#123;
        for(int k = 0; k &lt;= s &amp;&amp; k * v &lt;= j; k++)&#123;
            dp[j] = max(dp[j], dp[j - v * k] + w * k);
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[m] &lt;&lt; endl;
</code></pre><h3 id="AcWing-买书"><a href="#AcWing-买书" class="headerlink" title="AcWing|买书"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyNS8=">AcWing|买书</span></h3><ul><li>完全背包经典优化<br>$\quad f(i, j) \quad &#x3D; ; f(i-1, j)+f(i-1, j-v_{i})+\cdots+f \left (i-1, j-s v_{i} \right)$<br>$f\left (i, j-v_{i}\right) &#x3D; \qquad \qquad \quad ; f\left (i-1, j-v_{i}\right)+\cdots+f\left (i-1, j-s v_{i}\right)$</li><li>同时，观察到该转移方程对于第 $i$ 阶段的状态，只会使用第 $i-1$ 层和第 $i$ 层的状态。因此我们也可以采用 01 背包的空间优化方案</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int v[4] = &#123;10, 20, 50, 100&#125;;
int dp[1010];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    dp[0] = 1;
    for(int i = 0; i &lt; 4; i++)&#123;
        for(int j = v[i]; j &lt;= n; j++)&#123;
            dp[j] += dp[j - v[i]];
        &#125;
    &#125;
    cout &lt;&lt; dp[n] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-背包问题求具体方案"><a href="#AcWing-背包问题求具体方案" class="headerlink" title="AcWing|背包问题求具体方案"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTIv">AcWing|背包问题求具体方案</span></h3><ul><li>先正序保存物品的体积和价值，然后倒序 dp ，就可以按正序逆推出字典序最小的方案了。</li></ul><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];
for(int i = n; i &gt;= 1; i--)&#123;
    for(int j = 0; j &lt;= m; j++)&#123;
        dp[i][j] = dp[i + 1][j];
        if(j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]);
    &#125;
&#125;
int t = m;
for(int i = 1; i &lt;= n; i++)&#123;
    if(t &gt;= v[i] &amp;&amp; dp[i][t] == dp[i + 1][t - v[i]] + w[i])&#123;
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        t -= v[i];
    &#125;
&#125;
</code></pre><h3 id="AcWing-机器分配"><a href="#AcWing-机器分配" class="headerlink" title="AcWing|机器分配"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNS8=">AcWing|机器分配</span></h3><ul><li>可以将此题看作分组背包问题，每个公司仅能选择 $k$ 个机器，总体积为 $m$ ，即为总共 $m$ 个机器。</li></ul><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = 1; j &lt;= m; j++)&#123;
        cin &gt;&gt; w[i][j];
    &#125;
&#125;
for(int i = n; i &gt;= 1; i--)&#123;
    for(int j = 0; j &lt;= m; j++)&#123;
        for(int k = 0; k &lt;= j; k++)&#123;
            dp[i][j] = max(dp[i][j], dp[i + 1][j - k] + w[i][k]);
        &#125;
    &#125;
&#125;
int j = m;
for(int i = 1; i &lt;= n; i++)&#123;
    for(int k = 0; k &lt;= j; k++)&#123;
        if(dp[i][j] == dp[i + 1][j - k] + w[i][k])&#123;
            way[i] = k;
            j -= k;
            break;
        &#125;
    &#125;
&#125;
cout &lt;&lt; dp[1][m] &lt;&lt; endl;
for(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; way[i] &lt;&lt; endl;
</code></pre><h3 id="AcWing-金明的预算方案"><a href="#AcWing-金明的预算方案" class="headerlink" title="AcWing|金明的预算方案"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDg5Lw==">AcWing|金明的预算方案</span></h3><ul><li>可以把每种主件和附属的附件组合的方案全列举出来进行选择，用二进制进行枚举。<ul><li>每种主件的搭配方案共 $2^2$ 种。</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 32010, M = 70;
int dp[N];
PII master[M];
vector&lt;PII&gt; servant[M];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; i++)&#123;
        int v, p, q;
        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;
        if(!q) master[i] = &#123;v, v * p&#125;;
        else servant[q].push_back(&#123;v, v * p&#125;);
    &#125;
    for(int i = 1; i &lt;= m; i++)&#123;
        if (master[i]. x)&#123;		// 判断是否为主件，且价值是否不是 0.
            for(int j = n; j &gt;= 0; j--)&#123;
                auto &amp;s = servant[i];
                for(int k = 0; k &lt; 1 &lt;&lt; s.size(); k++)&#123;
                    int v = master[i].x, w = master[i].y;
                    for(int l = 0; l &lt; s.size(); l++)&#123;
                        if(k &gt;&gt; l &amp; 1) v += s[l].x, w += s[l].y;
                    &#125;
                    if(j &gt;= v) dp[j] = max(dp[j], dp[j - v] + w);
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[n] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-开心的金明"><a href="#AcWing-开心的金明" class="headerlink" title="AcWing|开心的金明"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDI4Lw==">AcWing|开心的金明</span></h3><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= m; i++)&#123;
    int v, p;
    cin &gt;&gt; v &gt;&gt; p;
    for(int j = n; j &gt;= v; j--)&#123;
        dp[j] = max(dp[j], dp[j - v] + v * p);
    &#125;
&#125;
cout &lt;&lt; dp[n] &lt;&lt; endl;
</code></pre><h3 id="AcWing-货币系统"><a href="#AcWing-货币系统" class="headerlink" title="AcWing|货币系统"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMy8=">AcWing|货币系统</span></h3><ul><li>同上 <em>买书</em> 一题</li></ul><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i];
dp[0] = 1;
for(int i = 1; i &lt;= n; i++)&#123;
    for(int j = v[i]; j &lt;= m; j++)&#123;
        dp[j] += dp[j - v[i]];
    &#125;
&#125;
cout &lt;&lt; dp[m] &lt;&lt; endl;
</code></pre><h3 id="AcWing-货币系统-NOIP2018"><a href="#AcWing-货币系统-NOIP2018" class="headerlink" title="AcWing|货币系统 NOIP2018"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTM0Lw==">AcWing|货币系统 NOIP2018</span></h3><ul><li>题意<ul><li>定义一个货币系统 $(n, a)$ ：一共有 $n$ 种货币，每种货币对应面值为 $a_i$。</li><li>每种货币可以使用任意多个，进行线性组合：</li><li>$k &#x3D; x_1a_1 + x_2a_2 + \cdots + x_na_n$，其中 $X_i\in Z \quad (i &#x3D; 1, 2, \cdots)$</li><li>$k$ 为该货币系统 $(n, a)$ 能够 <strong>线性表示</strong> 的数值 （本题的系数必须为非负整数，因此<strong>与线性代数中的线性表出不一致</strong>）</li><li>定义 $(n, a) \text { 和 }(m, b) \text { 等价 } \Leftrightarrow \forall k \in Z^{+}$，$k$ 如果能被 $a$ 线性表出，则 $k$ 也能被 $b$ 线性表出，反之则都不能。</li></ul></li><li>分析<ul><li>由已知每种货币可以使用 <em>无穷多</em> 信息可以初步判断是完全背包的变种。</li><li>假设货币系统中存在一个元素可以被其他的元素线性表示的话，该元素则可以认为是无效的。</li><li>因此我们需要求出该货币系统的最大无关向量组。</li><li>我们可以利用数论中 <strong>埃氏筛法</strong> 的思想。<ul><li>对于一个无效的元素，它只会被小于它的元素线性表示。所以我们需要先行排序。</li><li>而我们在做完全背包的适合，需要求出所有恰好能被前 $i$ 个物品选出的体积的方案，即在完全背包求方案数的过程中，统计那些 <em>初始不能被满足</em> 的物品体积的个数。</li></ul></li></ul></li></ul><pre><code class="cpp">int n;
cin &gt;&gt; n;
for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
sort(a + 1, a + 1 + n);
dp[0] = 1;
int m = a[n], ans = 0;
for(int i = 1; i &lt;= n; i++)&#123;
    if(!dp[a[i]]) ans++;
    for(int j = a[i]; j &lt;= m; j++)&#123;
        dp[j] += dp[j - a[i]];
    &#125;
&#125;
cout &lt;&lt; ans &lt;&lt; endl;
</code></pre><h3 id="AcWing-混合背包问题"><a href="#AcWing-混合背包问题" class="headerlink" title="AcWing|混合背包问题"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNy8=">AcWing|混合背包问题</span></h3><ul><li>01 背包可以看作是可选次数最多为 $1$ 的多重背包。</li></ul><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
for(int i = 1; i &lt;= n; i++)&#123;
    int v, w, s;
    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
    if(s == 0)&#123;
        for(int j = v; j &lt;= m; j++) dp[j] = max(dp[j], dp[j - v] + w);
    &#125;else&#123;
        if(s == -1) s = 1;
        for(int j = 1; j &lt;= s; j &lt;&lt;= 1)&#123;
            for(int k = m; k &gt;= j * v; k--) dp[k] = max(dp[k], dp[k - j * v] + j * w);
            s -= j;
        &#125;
        if(s) for(int k = m; k &gt;= s * v; k--) dp[k] = max(dp[k], dp[k - s * v] + s * w);
    &#125;
&#125;
cout &lt;&lt; dp[m] &lt;&lt; endl;
</code></pre><h3 id="AcWing-有依赖的背包问题🌸"><a href="#AcWing-有依赖的背包问题🌸" class="headerlink" title="AcWing|有依赖的背包问题🌸"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAv">AcWing|有依赖的背包问题</span>🌸</h3><ul><li>题意<ul><li>有依赖的背包问题是指物品之间存在依赖关系，这种依赖关系可以用一棵树来表示，要是我们想要选择子节点就必须连同其父节点一起选。</li></ul></li><li>分析<ul><li>按照以往线性背包 DP 的状态转移，第 $i$ 件物品只会依赖第 $i - 1$ 物品的状态。假如本题也采用该种状态依赖关系的话，对于节点 $i$ ，我们需要枚举他所有子节点的组合共 $2^k$ 种，再枚举体积，时间复杂度会变得十分高。</li><li>因此我们转换思考方式，枚举<strong>每个状态分给子节点的体积</strong></li><li>时间复杂度为 $O (N \times V \times V)$</li></ul></li><li><strong>状态表示</strong><ul><li>集合：所有从以 $u$ 为根的子树中选，且总体积不超过 $j$ 的方案。</li><li>属性：Max</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
int dp[N][N];
int v[N], w[N];
int h[N], e[N], ne[N], idx;
int n, m;
void add(int a, int b)&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
void dfs(int u)&#123;
    for(int i = h[u]; ~i; i = ne[i])&#123;   // 循环物品组
        int son = e[i];
        dfs(son);
        // 分组背包
        for(int j = m - v[u]; j &gt;= 0; j--)&#123;     // 循环体积
            for(int k = 0; k &lt;= j; k++)&#123;        // 循环决策
                dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[son][k]);
            &#125;
        &#125;
    &#125;
    // 将物品 u 加进去
    for(int i = m; i &gt;= v[u]; i--) dp[u][i] = dp[u][i - v[u]] + w[u];
    for(int i = 0; i &lt; v[u]; i++) dp[u][i] = 0;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));
    int root;
    for(int i = 1; i &lt;= n; i++)&#123;
        int p;
        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;
        if(p == -1) root = i;
        else add(p, i);
    &#125;
    dfs(root);
    cout &lt;&lt; dp[root][m] &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-背包问题求方案数"><a href="#AcWing-背包问题求方案数" class="headerlink" title="AcWing|背包问题求方案数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEv">AcWing|背包问题求方案数</span></h3><ul><li>首先题目中要求 <strong>最优选法的方案数</strong>, 且为 01 背包求解最优方案。</li><li>$dp[i]$ 表示背包容积恰好为 $i$ 时的最大价值和。</li><li>$ans[i]$ 表示背包容积恰好为 $i$ 时取最优解的方案。</li></ul><pre><code class="cpp">int n, m;
cin &gt;&gt; n &gt;&gt; m;
memset(dp, -0x3f, sizeof(dp));
ans[0] = 1, dp[0] = 0;
for(int i = 1; i &lt;= n; i++)&#123;
    int v, w;
    for(int j = m; j &gt;= v; j--)&#123;
    cin &gt;&gt; v &gt;&gt; w;
        int maxv = max(dp[j], dp[j - v] + w);
        int cnt = 0;
        if(maxv == dp[j]) cnt += ans[j];
        if(maxv == dp[j - v] + w) cnt += ans[j - v];
        dp[j] = maxv, ans[j] = cnt % MOD;
    &#125;
&#125;
int res = *max_element(dp, dp + m + 1);
int cnt = 0;
for(int i = 0; i &lt;= m; i++)&#123;
    if(dp[i] == res)&#123;
        cnt = (cnt + ans[i]) % MOD;
    &#125;
&#125;
cout &lt;&lt; cnt &lt;&lt; endl;
</code></pre><h3 id="AcWing-能量石🌖"><a href="#AcWing-能量石🌖" class="headerlink" title="AcWing|能量石🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNzM2Lw==">AcWing|能量石</span>🌖</h3><ul><li>题意<ul><li>共有 $N$ 块能量石，吃掉它的时间是 $S_i$ ，获得的能量是 $E_i$，每单位时间内损失的能量是 $L_i$。在刚吃每块能量石时就能立刻获得它的能量，不会继续衰减，且无法中断整个过程。求最终获得的最大能量。</li></ul></li><li>分析<ul><li>先进行 <strong>贪心</strong> 将问题转化，使用<em>交换位置法</em> ，假设对任意两个有能量剩余的能量石 $s_i, s_j$，交换位置后两个宝石的贡献总和不会变得更大，即 $E_i + E_j - (S_i \times L_j \le E_i + E_j - (S_J \times L_i)$，化简后为 $S_i \times L_j \le S_j \times L_i$。我们只需要按照该条件对能量石进行排序。</li><li>对于其它形式的放置方法，必然可以通过上面的条件交换某满足的两项来获得更小值。</li><li>因此，我们只需要按照 01 背包的方法，对其进行动态规划。</li><li>$dp[i]$ 表示当前恰好花费 $i$ 单位时间得到的最大能量。</li><li>初始状态 $dp[0] &#x3D; 0$。</li></ul></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010;
struct Stone
&#123;
    int s, e, l;
    bool operator&lt;(const Stone &amp;w) const&#123;
        return s * w.l &lt; w.s * l;
    &#125;
&#125;stones[110];
int dp[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int T;
    cin &gt;&gt; T;
    for(int C = 1; C &lt;= T; C++)&#123;
        int n, m = 0;
        cin &gt;&gt; n;
        for(int i = 1; i &lt;= n; i++)&#123;
            cin &gt;&gt; stones[i].s &gt;&gt; stones[i].e &gt;&gt; stones[i].l;
            m += stones[i].s;
        &#125;
        sort(stones + 1, stones + n + 1);
        memset(dp, -0x3f, sizeof(dp));
        dp[0] = 0;
        for(int i = 1; i &lt;= n; i++)&#123;
            int s = stones[i].s, e = stones[i].e, l = stones[i].l;
            for(int j = m; j &gt;= s; j--)&#123;
                dp[j] = max(dp[j], dp[j - s] + e - (j - s) * l);
            &#125;
        &#125;
        int ans = *max_element(dp, dp + m + 1);
        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; C &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;
    &#125;
&#125;
</code></pre><hr><h2 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h2><ul><li>把结果扩展成过程</li></ul><h3 id="AcWing-大盗阿福"><a href="#AcWing-大盗阿福" class="headerlink" title="AcWing|大盗阿福"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA1MS8=">AcWing|大盗阿福</span></h3><ul><li>状态表示 $f[i, 0], f[i, 1]$<ul><li>集合：所有走了 $i$ 步，且当前位于状态 $j$ 的所有走法</li><li>属性：Max</li></ul></li><li>状态机入口时一定是状态 $0$，因此需要将 $dp[0][1]$ 置为负无穷</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;
int dp[N][2], w[N];
void solve()&#123;
    int n; cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    dp[0][0] = 0, dp[0][1] = -INF;
    for(int i = 1; i &lt;= n; i++)&#123;
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
        dp[i][1] = dp[i - 1][0] + w[i];
    &#125;
    cout &lt;&lt; max(dp[n][0], dp[n][1]) &lt;&lt; endl;
&#125;
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t; cin &gt;&gt; t;
    while(t--) solve();
&#125;
</code></pre><h3 id="AcWing-股票买卖-Ⅳ"><a href="#AcWing-股票买卖-Ⅳ" class="headerlink" title="AcWing|股票买卖 Ⅳ"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA1OS8=">AcWing|股票买卖 Ⅳ</span></h3><ul><li>状态表示 $f[i, j, 0], f[i, j, 1]$<ul><li>集合：$f[i, j, 0]$ 表示第 $i$ 天，已经进行完第 $j$ 次交易，且手中无货。$f[i, j, 1]$ 表示第 $i$ 天，正在进行第 $j$ 次交易，且手中有货。</li><li>属性：Max</li></ul></li><li>初始化为 $0$ 表示该状态合法，初始化为 $-INF$ 表示为不合法</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, K = 110, INF = 0x3f3f3f3f;
int dp[N][K][2], w[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, k; cin &gt;&gt; n &gt;&gt; k;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    memset(dp, -0x3f, sizeof(dp));
    for(int i = 0; i &lt;= n; i++) dp[i][0][0] = 0; // 注意从第 0 天开始
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= k; j++)&#123;
            dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + w[i]);
            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - w[i]);
        &#125;
    &#125;
    int ans = 0;
    for(int i = 1; i &lt;= k; i++) ans = max(ans, dp[n][i][0]);
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-股票买卖-Ⅴ"><a href="#AcWing-股票买卖-Ⅴ" class="headerlink" title="AcWing|股票买卖 Ⅴ"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA2MC8=">AcWing|股票买卖 Ⅴ</span></h3><ul><li>有三个状态，「手中有货」、「手中无货的第 $1$ 天 」、「手中无货的第 $\ge 2$ 天 」</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;
int dp[N][3], w[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n; cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];
    dp[0][0] = dp[0][1] = -INF;
    dp[0][2] = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - w[i]);
        dp[i][1] = dp[i - 1][0] + w[i];
        dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);
    &#125;
    cout &lt;&lt; max(dp[n][1], dp[n][2]) &lt;&lt; endl;
&#125;
</code></pre><h3 id="AcWing-设计密码🌖"><a href="#AcWing-设计密码🌖" class="headerlink" title="AcWing|设计密码🌖"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA1NC8=">AcWing|设计密码</span>🌖</h3><ul><li>状态表示 $f(i, j)$<ul><li>集合：到第 $i$ 的字母时，匹配到子串中（next 数组）中状态是 $j$ 时所有方案的数量</li></ul></li><li>本题以 $j$ 的位置为状态机</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzU1NDQ5Lw==">线性DP + KMP自动机模型</span> | <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzI4MDIyLw==">思路详解</span></li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 55, mod = 1e9 + 7;
char s[N];
int dp[N][N], ne[N];
int main()&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int n, m;
    cin &gt;&gt; n &gt;&gt; s + 1;
    m = strlen(s + 1);
    for(int i = 2, j = 0; i &lt;= m; i++)&#123;
        while(j &amp;&amp; s[i] != s[j + 1]) j = ne[j];
        if(s[i] == s[j + 1]) j++;
        ne[i] = j;
    &#125;
    dp[0][0] = 1;
    for(int i = 0; i &lt; n; i++)&#123;
        for(int j = 0; j &lt; m; j++)&#123;
            for(char ch = &#39;a&#39;; ch &lt;= &#39;z&#39;; ch++)&#123;
                int ptr = j;
                while(ptr &amp;&amp; s[ptr + 1] != ch) ptr = ne[ptr];
                if(s[ptr + 1] == ch) ptr++;
                dp[i + 1][ptr] = (dp[i + 1][ptr] + dp[i][j]) % mod;
            &#125;
        &#125;
    &#125;
    int ans = 0;
    for(int i = 0; i &lt; m; i++) ans = (ans + dp[n][i]) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
</code></pre><hr><h2 id="单调队列优化-DP"><a href="#单调队列优化-DP" class="headerlink" title="单调队列优化 DP"></a>单调队列优化 DP</h2><hr><h2 id="斜率优化-DP"><a href="#斜率优化-DP" class="headerlink" title="斜率优化 DP"></a>斜率优化 DP</h2><div class="tags"><a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="ic i-tag"></i> 模板</a> <a href="/tags/%E9%A2%98%E9%9B%86/" rel="tag"><i class="ic i-tag"></i> 题集</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-07 09:05:11" itemprop="dateModified" datetime="2022-09-07T09:05:11+08:00">2022-09-07</time> </span><span id="post/动态规划题集.html" class="item leancloud_visitors" data-flag-title="动态规划题集" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Retsa <i class="ic i-at"><em>@</em></i>Retsa</li><li class="link"><strong>本文链接：</strong> <a href="https://asterzc19.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html" title="动态规划题集">https://asterzc19.github.io/post/动态规划题集.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;06&#x2F;8e1dc72d6a2cd665.jpg" title="位运算合集"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 算法</span><h3>位运算合集</h3></a></div><div class="item right"><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2022&#x2F;09&#x2F;05&#x2F;d77d62850e952780.jpg" title="搜索题集"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>搜索题集</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%83%8C%E5%8C%85"><span class="toc-number">1.1.</span> <span class="toc-text">01 背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">1.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E2%85%A0"><span class="toc-number">1.3.</span> <span class="toc-text">多重背包问题 Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E2%85%A1"><span class="toc-number">1.4.</span> <span class="toc-text">多重背包问题 Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">分组背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7-DP"><span class="toc-number">2.</span> <span class="toc-text">线性 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">2.1.</span> <span class="toc-text">数字三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E2%85%A0"><span class="toc-number">2.2.</span> <span class="toc-text">最长上升子序列 Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E2%85%A1"><span class="toc-number">2.3.</span> <span class="toc-text">最长上升子序列 Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">2.5.</span> <span class="toc-text">最短编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">2.6.</span> <span class="toc-text">编辑距离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4-DP"><span class="toc-number">3.</span> <span class="toc-text">区间 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">3.1.</span> <span class="toc-text">石子合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%8E%AF%E5%BD%A2%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">3.2.</span> <span class="toc-text">AcWing|环形石子合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE"><span class="toc-number">3.3.</span> <span class="toc-text">AcWing|能量项链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.4.</span> <span class="toc-text">AcWing|凸多边形的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">AcWing|加分二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%A3%8B%E7%9B%98%E5%88%86%E5%89%B2"><span class="toc-number">3.6.</span> <span class="toc-text">AcWing|棋盘分割</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E7%B1%BB-DP"><span class="toc-number">4.</span> <span class="toc-text">计数类 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86"><span class="toc-number">4.1.</span> <span class="toc-text">整数划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">5.</span> <span class="toc-text">记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E9%9B%AA"><span class="toc-number">5.1.</span> <span class="toc-text">滑雪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E5%8E%8B-DP"><span class="toc-number">6.</span> <span class="toc-text">状压 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3%F0%9F%8C%B8"><span class="toc-number">6.1.</span> <span class="toc-text">蒙德里安的梦想🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD-Hamilton-%E8%B7%AF%E5%BE%84%F0%9F%8C%B8"><span class="toc-number">6.2.</span> <span class="toc-text">最短 Hamilton 路径🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%B0%8F%E5%9B%BD%E7%8E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">AcWing|小国王</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%8E%89%E7%B1%B3%E7%94%B0"><span class="toc-number">6.4.</span> <span class="toc-text">AcWing|玉米田</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0-%F0%9F%8C%B8"><span class="toc-number">6.5.</span> <span class="toc-text">AcWing|炮兵阵地 🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F%F0%9F%8C%96"><span class="toc-number">6.6.</span> <span class="toc-text">AcWing|愤怒的小鸟🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2-DP"><span class="toc-number">7.</span> <span class="toc-text">树形 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%F0%9F%8C%B8"><span class="toc-number">7.1.</span> <span class="toc-text">没有上司的舞会🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%A0%91%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84"><span class="toc-number">7.2.</span> <span class="toc-text">AcWing|树的最长路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83"><span class="toc-number">7.3.</span> <span class="toc-text">AcWing|树的中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.4.</span> <span class="toc-text">AcWing|数字转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91"><span class="toc-number">7.5.</span> <span class="toc-text">AcWing|二叉苹果树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F"><span class="toc-number">7.6.</span> <span class="toc-text">AcWing|战略游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%9A%87%E5%AE%AB%E7%9C%8B%E5%AE%88%F0%9F%8C%96"><span class="toc-number">7.7.</span> <span class="toc-text">AcWing|皇宫看守🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D-DP"><span class="toc-number">8.</span> <span class="toc-text">数位 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%BA%A6%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">8.1.</span> <span class="toc-text">AcWing|度的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="toc-number">8.2.</span> <span class="toc-text">AcWing|数字游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-Windy-%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">AcWing|Windy 数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F-%E2%85%A1"><span class="toc-number">8.4.</span> <span class="toc-text">AcWing|数字游戏 Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E4%B8%8D%E8%A6%81-62"><span class="toc-number">8.5.</span> <span class="toc-text">AcWing|不要 62</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">数字三角形模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%91%98%E8%8A%B1%E7%94%9F"><span class="toc-number">9.1.</span> <span class="toc-text">AcWing|摘花生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9"><span class="toc-number">9.2.</span> <span class="toc-text">AcWing|最低通行费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%F0%9F%8C%B8"><span class="toc-number">9.3.</span> <span class="toc-text">AcWing|方格取数🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E4%BC%A0%E7%BA%B8%E6%9D%A1%F0%9F%8C%B8"><span class="toc-number">9.4.</span> <span class="toc-text">AcWing|传纸条🌸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">最长上升子序列模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%80%AA%E7%9B%97%E5%9F%BA%E5%BE%B7%E7%9A%84%E6%BB%91%E7%BF%94%E7%BF%BC"><span class="toc-number">10.1.</span> <span class="toc-text">AcWing|怪盗基德的滑翔翼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E7%99%BB%E5%B1%B1"><span class="toc-number">10.2.</span> <span class="toc-text">AcWing|登山</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2"><span class="toc-number">10.3.</span> <span class="toc-text">AcWing|合唱队形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82"><span class="toc-number">10.4.</span> <span class="toc-text">AcWing|友好城市</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">10.5.</span> <span class="toc-text">AcWing|最大上升子序列和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9"><span class="toc-number">10.6.</span> <span class="toc-text">AcWing|拦截导弹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%AF%BC%E5%BC%B9%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F%F0%9F%8C%B8"><span class="toc-number">10.7.</span> <span class="toc-text">AcWing|导弹防御系统🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%F0%9F%8C%B8"><span class="toc-number">10.8.</span> <span class="toc-text">AcWing|最大公共上升子序列🌸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">背包模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%87%87%E8%8D%AF"><span class="toc-number">11.1.</span> <span class="toc-text">AcWing|采药</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98"><span class="toc-number">11.2.</span> <span class="toc-text">AcWing|装箱问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E4%BA%8C%E4%BD%8D%E8%B4%B9%E7%94%A8%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">AcWing|二位费用的背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%AE%A0%E7%89%A9%E5%B0%8F%E7%B2%BE%E7%81%B5%E4%B9%8B%E6%94%B6%E6%9C%8D"><span class="toc-number">11.4.</span> <span class="toc-text">AcWing|宠物小精灵之收服</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E2%85%A2%F0%9F%8C%B8"><span class="toc-number">11.5.</span> <span class="toc-text">AcWing|多重背包问题 Ⅲ🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%BD%9C%E6%B0%B4%E5%91%98"><span class="toc-number">11.6.</span> <span class="toc-text">AcWing|潜水员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88"><span class="toc-number">11.7.</span> <span class="toc-text">AcWing|数字组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%BA%86%E5%8A%9F%E4%BC%9A"><span class="toc-number">11.8.</span> <span class="toc-text">AcWing|庆功会</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E4%B9%B0%E4%B9%A6"><span class="toc-number">11.9.</span> <span class="toc-text">AcWing|买书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88"><span class="toc-number">11.10.</span> <span class="toc-text">AcWing|背包问题求具体方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%BA%E5%99%A8%E5%88%86%E9%85%8D"><span class="toc-number">11.11.</span> <span class="toc-text">AcWing|机器分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88"><span class="toc-number">11.12.</span> <span class="toc-text">AcWing|金明的预算方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E"><span class="toc-number">11.13.</span> <span class="toc-text">AcWing|开心的金明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">11.14.</span> <span class="toc-text">AcWing|货币系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-NOIP2018"><span class="toc-number">11.15.</span> <span class="toc-text">AcWing|货币系统 NOIP2018</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.16.</span> <span class="toc-text">AcWing|混合背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%F0%9F%8C%B8"><span class="toc-number">11.17.</span> <span class="toc-text">AcWing|有依赖的背包问题🌸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">11.18.</span> <span class="toc-text">AcWing|背包问题求方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%83%BD%E9%87%8F%E7%9F%B3%F0%9F%8C%96"><span class="toc-number">11.19.</span> <span class="toc-text">AcWing|能量石🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">状态机模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E5%A4%A7%E7%9B%97%E9%98%BF%E7%A6%8F"><span class="toc-number">12.1.</span> <span class="toc-text">AcWing|大盗阿福</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96-%E2%85%A3"><span class="toc-number">12.2.</span> <span class="toc-text">AcWing|股票买卖 Ⅳ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96-%E2%85%A4"><span class="toc-number">12.3.</span> <span class="toc-text">AcWing|股票买卖 Ⅴ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-%E8%AE%BE%E8%AE%A1%E5%AF%86%E7%A0%81%F0%9F%8C%96"><span class="toc-number">12.4.</span> <span class="toc-text">AcWing|设计密码🌖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96-DP"><span class="toc-number">13.</span> <span class="toc-text">单调队列优化 DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-DP"><span class="toc-number">14.</span> <span class="toc-text">斜率优化 DP</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Retsa" data-src="/images/iOS.jpg"><p class="name" itemprop="name">Retsa</p><div class="description" itemprop="description">对未来的透支，对过去的偿还</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FzdGVyWkMxOQ==" title="https:&#x2F;&#x2F;github.com&#x2F;AsterZC19"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9Bc3RlclpDMTk=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;AsterZC19"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/AcWing/" title="分类于 AcWing">AcWing</a></div><span><a href="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html" title="线性同余方程">线性同余方程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6.html" title="线段树进阶">线段树进阶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/CodeForces/" title="分类于 CodeForces">CodeForces</a> <i class="ic i-angle-right"></i> <a href="/categories/AtCoder/" title="分类于 AtCoder">AtCoder</a></div><span><a href="/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html" title="题目小集">题目小集</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/Flyme%E6%9B%B4%E6%96%B0.html" title="Flyme 更新日志">Flyme 更新日志</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html" title="高级数据结构题集">高级数据结构题集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html" title="基础算法模板">基础算法模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF.html" title="基础数据结构模板">基础数据结构模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/post/STL%E7%AE%80%E4%BB%8B.html" title="STL 简介">STL 简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%96%87%E7%AB%A0/" title="分类于 文章">文章</a></div><span><a href="/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html" title="注意力使用不完全报告">注意力使用不完全报告</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/post/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html" title="数学知识">数学知识</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Retsa"></i> </span><span class="author" itemprop="copyrightHolder">Retsa @ 回不到的过去</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">292k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:26</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"post/动态规划题集.html",favicon:{show:"嗨~",hide:"呜呜呜"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->