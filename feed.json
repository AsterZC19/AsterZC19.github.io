{
    "version": "https://jsonfeed.org/version/1",
    "title": "Retsa",
    "subtitle": null,
    "icon": "https://asterzc19.github.io/images/favicon.ico",
    "description": "对未来的透支，对过去的偿还",
    "home_page_url": "https://asterzc19.github.io",
    "items": [
        {
            "id": "https://asterzc19.github.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html",
            "url": "https://asterzc19.github.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81.html",
            "title": "网络流",
            "date_published": "2022-08-19T10:00:20.000Z",
            "content_html": "<blockquote>\n<p><strong>网络流</strong>是算法竞赛中的一个重要的<strong>模型</strong>，它分为两部分：网络和流。<br>学习自 Pecco、OI Wiki</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><ul>\n<li><p>首先，请分清楚 <strong>网络</strong>（或者流网络，Flow Network）与 <strong>网络流</strong>（Flow）的概念。</p>\n</li>\n<li><p>网络是指一个有向图 $G ; &#x3D; ; (V, ;E)$ 。</p>\n</li>\n<li><p>每条边都有一个权值 ，称之为容量（Capacity）。</p>\n</li>\n<li><p>其中有两个特殊的点：源点（Source） 和汇点（Sink）。</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-37f837b113bbcb3fe54ce54fd9040832_720w.jpg\"></p>\n</li>\n</ul>\n<h2 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h2><ul>\n<li><strong>流</strong>，顾名思义，就像水流或电流，也具有它们的性质。如果把网络想象成一个自来水管道网络，那流就是其中流动的水。每条边上的流不能超过它的容量，并且对于除了源点和汇点外的所有点（即中继点），流入的流量都等于流出的流量。</li>\n</ul>\n<h1 id=\"网络流的常见问题\"><a href=\"#网络流的常见问题\" class=\"headerlink\" title=\"网络流的常见问题\"></a>网络流的常见问题</h1><ul>\n<li><p>网络流问题中常见的有以下三种：最大流，最小割，费用流。</p>\n</li>\n<li><p>而最常见的问题就是<strong>网络最大流</strong>。假定从源点流出的流量足够多，求能够流入汇点的最大流量。例如对上面那张网络而言，最大流是5，其中1-&gt;3提供2流量，1-&gt;2-&gt;3提供2流量（这有点像木桶原理，某条路径的容量是由最窄的一根水管决定的），1-&gt;2-&gt;4-&gt;3提供1流量（注意这里不是2，因为上条路径已经占用了1-&gt;2的2单位容量，只剩1单位容量可用）。</p>\n</li>\n</ul>\n<h2 id=\"最大流\"><a href=\"#最大流\" class=\"headerlink\" title=\"最大流\"></a>最大流</h2><ul>\n<li>我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。</li>\n</ul>\n<h2 id=\"最小费用最大流\"><a href=\"#最小费用最大流\" class=\"headerlink\" title=\"最小费用最大流\"></a>最小费用最大流</h2><ul>\n<li>最小费用最大流问题是这样的：每条边都有一个费用，代表单位流量流过这条边的开销。我们要在求出最大流的同时，要求花费的费用最小。</li>\n</ul>\n<h2 id=\"最小割\"><a href=\"#最小割\" class=\"headerlink\" title=\"最小割\"></a>最小割</h2><ul>\n<li>割其实就是删边的意思，当然最小割就是割掉 $X$ 条边来让  $S$ 跟 $T$ 不互通。我们要求 $X$ 条边加起来的流量总和最小。这就是最小割问题。</li>\n</ul>\n<h1 id=\"最大流-1\"><a href=\"#最大流-1\" class=\"headerlink\" title=\"最大流\"></a>最大流</h1><h2 id=\"Ford-Fulkerson-算法\"><a href=\"#Ford-Fulkerson-算法\" class=\"headerlink\" title=\"Ford-Fulkerson 算法\"></a>Ford-Fulkerson 算法</h2><ul>\n<li><p>通常用于解决网络最大流。</p>\n</li>\n<li><p>FF算法的核心在于找<strong>增广路</strong>。何谓增广路？例如上图中我首先选择1-&gt;2-&gt;3，这是一条增广路，提供2流量；然后我们相应地<strong>扣除</strong>选择路径上各边的容量，1-&gt;2的容量变成1，2-&gt;3的容量变成0，这时的容量称为<strong>残余容量</strong>。然后我们再找到1-&gt;2-&gt;4-&gt;3这条路径，按残余容量计算流量，它提供1流量（选择这两条路的顺序可以颠倒）。1-&gt;2-&gt;4-&gt;3也是一条增广路。</p>\n</li>\n<li><p><strong>增广路</strong>，是从源点到汇点的路径，其上所有边的残余容量均大于0。FF算法就是不断寻找增广路，直到找不到为止。这个算法不一定正确，可以构造一张图让其出错。</p>\n</li>\n<li><p>为了解决这个错误，我们引入 <strong>反向边</strong>。在建边的同时，在反方向建一条边权为 0 的边。</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-1c4016f73a2e94109fbb8769a1e88566_720w.jpg\"></p>\n</li>\n<li><p>我们仍然选择1-&gt;2-&gt;3-&gt;4，但在扣除正向边的容量时，反向边要<strong>加上</strong>等量的容量。</p>\n</li>\n<li><p><img data-src=\"https://pic4.zhimg.com/80/v2-f19ff404a0932ca1d6bdf713403142cf_720w.jpg\"></p>\n</li>\n<li><p>这时我们可以另外找到一条增广路：1-&gt;3-&gt;2-&gt;4。</p>\n</li>\n<li><p>现在我们同时选择了2-&gt;3和3-&gt;2两条边，我们可以认为，这两条边上的水流 <strong>抵消</strong> 了。所以实际上选择的路径就是1-&gt;3-&gt;4和1-&gt;2-&gt;4。</p>\n</li>\n<li><p>其实可以把反向边理解成一种 <strong>撤销</strong>，走反向边就意味着撤回上次流经正向边的若干流量，这也合理解释了为什么扣除正向边容量时要给反向边加上相应的容量：反向边的容量意味着可以撤回的量。</p>\n</li>\n<li><p>加入了反向边这种反悔机制后，我们就可以保证，当找不到增广路的时候，流到汇点的流量就是最大流。</p>\n</li>\n<li><p>用 dfs 实现的 FF 算法时间复杂度上界是 $O(ef)$ ，其中 $e$ 为边数，$f$ 为最大流：</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">int n, m, s, t;     // s 源点，t 汇点\nbool vis[N];\nint dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t)&#123;\n        return flow;    // 返回这条增广路的流量\n    &#125;\n    vis[u] = 1;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i], c;\n        // 返回的条件是残余容量大于 0，未访问过该点且接下来可以到达终点\n        // 传递下去的流量是边的容量与当前流量中的较小值\n        if(v &gt; 0 &amp;&amp; !vis[j] &amp;&amp; (c = dfs(j, min(v, flow))) != -1)&#123;\n            w[i] -= c;\n            w[i ^ 1] += c;\n            return c;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n</code></pre>\n<ul>\n<li>这个算法的复杂度上界非常高，仍有很多优化空间。</li>\n</ul>\n<h2 id=\"Edmond-Karp-算法\"><a href=\"#Edmond-Karp-算法\" class=\"headerlink\" title=\"Edmond-Karp 算法\"></a>Edmond-Karp 算法</h2><ul>\n<li>EK 算法就是 BFS 实现的 FF 算法。</li>\n</ul>\n<pre><code class=\"cpp\">int n, m, s, t;     // s 源点，t 汇点\nint last[N], flow[N];\ninline int bfs()&#123;\n    memset(last, -1, sizeof(last));\n    queue&lt;int&gt; q;\n    q.push(s);\n    flow[s] = 0x3f3f3f3f;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        if(u == t) break;\n        for(int i = h[u]; ~i; i = ne[i])&#123;\n            int j = e[i], v = w[i];\n            if(v &gt; 0 &amp;&amp; last[j] == -1)&#123;\n                 // 如果残余容量大于 0 且未访问过（所以 last 保持在 -1 ）\n                last[j] = i;\n                flow[j] = min(flow[u], v);\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return last[t] != -1;\n&#125;\ninline int EK()&#123;\n    int maxflow = 0;\n    while(bfs())&#123;\n        maxflow += flow[t];\n        for(int i = t; i != s; i = e[last[i] ^ 1])&#123;\n            // 从汇点原路返回更新残余容量\n            w[last[i]] -= flow[t];\n            w[last[i] ^ 1] += flow[t];\n        &#125;\n    &#125;\n    return maxflow;\n&#125;\n</code></pre>\n<ul>\n<li>为什么在这里 BFS 通常比 DFS 的效果好？因为 DFS 很可能会“绕远路”，而 BFS 可以保证每次找到的都是最短的增广路。它的复杂度上限是 $O(ve^2)$ ，其中 $v$ 为点数。这个算法至少与流的大小无关了，算是多项式算法了，让人稍微安心了一点……</li>\n</ul>\n<h2 id=\"Dinic-算法\"><a href=\"#Dinic-算法\" class=\"headerlink\" title=\"Dinic 算法\"></a>Dinic 算法</h2><ul>\n<li><p>然而，最常用的网络流算法是 Dinic 算法。作为 FF&#x2F;EK 算法的优化，它选择了先用BFS <strong>分层</strong>，再用 DFS 寻找。它的时间复杂度上界是 $O(v^2e)$ 。所谓分层，其实就是预处理出源点到每个点的距离（注意每次循环都要预处理一次，因为有些边可能容量变为 0 不能再走）。我们只往层数高的方向增广，可以保证不走回头路也不绕圈子。</p>\n</li>\n<li><p>我们可以使用 <strong>多路增广</strong> 节省很多花在重复路线上的时间：在某点 DFS 找到一条增广路后，如果还剩下多余的流量未用，继续在该点 DFS 尝试找到更多增广路。</p>\n</li>\n<li><p>此外还有<strong>当前弧优化</strong>。因为在Dinic算法中，一条边增广一次后就不会再次增广了，所以下次增广时不需要再考虑这条边。我们把 head 数组复制一份，但不断更新增广的起点。</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">int n, m, s, t, lv[N], cur[N];      // lv是 每个点的层数，cur 用于当前弧优化标记增广起点\ninline bool bfs()&#123;      // bfs 分层\n    memset(lv, -1, sizeof(lv));\n    queue&lt;int&gt; q;\n    q.push(s);\n    lv[s] = 0;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        for(int i = h[u]; ~i; i = ne[i])&#123;\n            int j = e[i], v = w[i];\n            if(v &gt; 0 &amp;&amp; lv[j] == -1)&#123;\n                lv[j] = lv[u] + 1;\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return lv[t] != -1;     // 如果汇点未访问过说明已经无法达到汇点，此时返回 false\n&#125;\nint dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int i = cur[u]; ~i; i = ne[i])&#123;\n        cur[u] = i;     // 当前弧优化, 更新当前弧\n        int j = e[i], v = w[i];\n        if(v &gt; 0 &amp;&amp; lv[j] == lv[u] + 1)&#123;    // 往层数高的方向增广\n            int c = dfs(j, min(remain, v)); // 尽可能多地传递流量\n            remain -= c;    // 剩余流量减少\n            w[i] -= c;     // 更新残余容量\n            w[i ^ 1] += c; // 增加剩余流量\n        &#125;\n    &#125;\n    return flow - remain;   // 返回传递出去的流量的大小\n&#125;\ninline int dinic()&#123;\n    int ans = 0;\n    memcpy(cur, h, sizeof(h));  // 当前狐优化初始化\n    while(bfs())&#123;\n        ans += dfs();\n        memcpy(cur, h, sizeof(h));  // 当前狐优化初始化\n    &#125;\n    return ans;\n&#125;\n</code></pre>\n<ul>\n<li><p>值得注意的是，这个算法如果用在二分图中复杂度是 $O(v;\\sqrt e)$ ，优于<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NjIyOTcwMA==\">匈牙利算法</span>。</p>\n</li>\n<li><p>这里再提一下<strong>最大流最小割定理</strong>。所谓<strong>割</strong>，就是从网络中选择一些边，使得去掉这些边后，剩下两个不连通的分别包含源点和汇点的点集。割的大小是这些边的容量之和。在所有可行的割中，最小的割称为<strong>最小割</strong>。</p>\n</li>\n<li><p>这个神奇的定理只有短短几个字：<strong>最大流等于最小割</strong>。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"P3376-网络最大流\"><a href=\"#P3376-网络最大流\" class=\"headerlink\" title=\"P3376 | 网络最大流\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzY=\">P3376 | 网络最大流</span></h3><ul>\n<li>模板题</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1210, M = 250010;\nint h[N], e[M], ne[M], w[M], idx;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint n, m, s, t, lv[N], cur[N];\ninline bool bfs()&#123;\n    memset(lv, -1, sizeof(lv));\n    memcpy(cur, h, sizeof(h));\n    queue&lt;int&gt; q;\n    q.push(s);\n    lv[s] = 0;\n    while(!q.empty())&#123;\n        int u = q.front(); q.pop();\n        for(int i = cur[u]; i != -1; i = ne[i])&#123;\n            int j = e[i], v = w[i];\n            if(v &gt; 0 &amp;&amp; lv[j] == -1)&#123;\n                lv[j] = lv[u] + 1;\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return lv[t] != -1;\n&#125;\nint dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i];\n        if(v &gt; 0 &amp;&amp; lv[j] == lv[u] + 1)&#123;\n            int tmp = dfs(j, min(remain, v));\n            remain -= tmp;\n            w[i] -= tmp;\n            w[i ^ 1] += tmp;\n        &#125;\n    &#125;\n    return flow - remain;\n&#125;\ninline int dinic()&#123;\n    int ans = 0;\n    while(bfs())&#123;\n        ans += dfs();\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int u, v, c;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;\n        add(u, v, c);\n        add(v, u, 0);  // 反向边边权为 0\n    &#125;\n    cout &lt;&lt; dinic() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h2 id=\"二者取一式问题\"><a href=\"#二者取一式问题\" class=\"headerlink\" title=\"二者取一式问题\"></a>二者取一式问题</h2><ul>\n<li><p>二者取一式问题可以这样描述：将若干元素 $e1, e2,…,en$ 划分到两个集合 $A,B$ 中。对于元素 $e_i$ ，它被划分到 $A$ 或 $B$ 中分别能获得一个 $a_{e_i}$ 或 $b_{e_i}$ 的分值。除此之外，还给出若干个组合 $C_i ;⊆;A$ ，当组合中的元素被同时划分到 $A$ 或 $B$ 时，可以获得额外的分值 $a_i^′$ 或 $b_i^′$ 。求最大的分值。</p>\n</li>\n<li><p>这个问题可以被转化为网络流中的<strong>最小割</strong>问题。如果我们把 $A$ 作为源点， $B$ 作为汇点，那么这个网络的一个<strong>割</strong>就是一种划分方法。如果没有组合的话，我们很容易就能建出这样的模型：</p>\n</li>\n<li><p><img data-src=\"https://pic4.zhimg.com/80/v2-8ca41bb30358f5b4d95addf974e497c7_720w.jpg\"></p>\n</li>\n<li><p>当我们去割它时，与A连通的点代表放到 $A$ 集合中，与B连通的点代表放到 $B$ 集合中。当这个割是最小割时，剩下的边的容量和是最大的，故设最小割为 <code>cut</code>，边权总和为 <code>sum</code>，则所求最大分值为 <code>sum-cut</code>。</p>\n</li>\n<li><p>现在我们考虑组合。假设 $C_1&#x3D;{e_1,e_2}$ ，且对应的额外分值为 $a_1^′$ 和 $b_1^′$ 。我们从 $A$ 点伸出一条容量为 $a_1^′$ 的边通向虚点 $X$ ：</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-7d33e345ace0c6873f633477c30ad9ba_720w.jpg\"></p>\n</li>\n<li><p>现在我们的需求是：只有当1、2点都被归入 $A$ 所在点集时，$X$ 才与 $A$ 连通。</p>\n</li>\n<li><p>反过来想，当 1 被归入 $B$ 所在点集时，要让 $A-&gt;X$ 被割掉。很自然地想到，让 $X$ 连向 1，这样当 1 被归入 $B$ 所在点集时，$A-&gt;X-&gt;1$ 必然会断，否则 $A$ 就与 $B$ 连通了。但如何确保割掉的是 $A-&gt;X$ 而不是 $X-&gt;1$ 呢？只要令 $X-&gt;1$ 的容量为$INF$ 即可，无穷大边不会被割掉。2 号点同理。</p>\n</li>\n<li><p><img data-src=\"https://pic4.zhimg.com/80/v2-3f06c22d87598fc1b5c1774376d303c3_720w.jpg\"></p>\n</li>\n<li><p>好了，这就是我们需要的模型。这时我们求最小割 <code>cut</code>，并记非无穷边权和为 <code>sum</code>，那么跟刚刚一样，<code>sum-cut</code> 就是所求分数。</p>\n</li>\n</ul>\n<h3 id=\"P1361-小M的作物\"><a href=\"#P1361-小M的作物\" class=\"headerlink\" title=\"P1361 | 小M的作物\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEzNjE=\">P1361 | 小M的作物</span></h3><ul>\n<li>标准的二者取一式问题。</li>\n<li>调整了初始化 <code>cur</code> 数组的位置，否则会导致 tle</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1510, M = 2e6 + 10;\nint h[N &lt;&lt; 1], e[M], ne[M], w[M], idx;\ninline void add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\ninline int read()&#123;\n    int x = 0, f = 1; char ch = getchar();\n    while(!isdigit(ch))&#123;if(ch == &#39;-&#39;) f = -1; ch = getchar();&#125;\n    while(isdigit(ch)) x = x * 10 + ch - &#39;0&#39;, ch = getchar();\n    return x * f;\n&#125;\nint n, m, s, t, lv[N &lt;&lt; 1], cur[N &lt;&lt; 1];\ninline bool bfs()&#123;\n    memset(lv, -1, sizeof(lv));\n    queue&lt;int&gt; q;\n    q.push(s);\n    lv[s] = 0;\n    while(!q.empty())&#123;\n        int u = q.front(); q.pop();\n        for(int i = cur[u]; i != -1; i = ne[i])&#123;\n            int j = e[i], v = w[i];\n            if(lv[j] == -1 &amp;&amp; v &gt; 0)&#123;\n                lv[j] = lv[u] + 1;\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return lv[t] != -1;\n&#125;\ninline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i];\n        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;\n            int tmp = dfs(j, min(remain, v));\n            remain -= tmp;\n            w[i] -= tmp;\n            w[i ^ 1] += tmp;\n            if(!remain)&#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return flow - remain;\n&#125;\ninline int dinic()&#123;\n    int ans = 0;\n    memcpy(cur, h, sizeof(h));\n    while(bfs())&#123;\n        //int tmp;\n        ans += dfs();\n        memcpy(cur, h, sizeof(h));\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    //cin.tie(0)-&gt;sync_with_stdio(false);\n    n = read();\n    s = 0, t = n + 1;\n    int sum = 0, cnt = t;\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x = read();\n        add(0, i, x);\n        add(i, 0, 0);\n        sum += x;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x = read();\n        add(i, n + 1, x);\n        add(n + 1, i, 0);\n        sum += x;\n    &#125;\n    cin &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int k = read(), a = read(), b = read();\n        add(0, ++cnt, a);\n        add(cnt, 0, 0);\n        add(++cnt, n + 1, b);\n        add(n + 1, cnt, 0);\n        sum += a + b;\n        while(k--)&#123;\n            int c = read();\n            add(cnt - 1, c, 0x3f3f3f3f);\n            add(c, cnt - 1, 0);\n            add(c, cnt, 0x3f3f3f3f);\n            add(cnt, c, 0);\n        &#125;\n    &#125;\n    printf(&quot;%d\\n&quot;, sum - dinic());\n&#125;\n</code></pre>\n<h2 id=\"路径覆盖问题\"><a href=\"#路径覆盖问题\" class=\"headerlink\" title=\"路径覆盖问题\"></a>路径覆盖问题</h2><ul>\n<li><p>这里说的路径覆盖，是在 <strong>DAG</strong>（有向无环图）上进行的，是指用找出尽可能少的一系列路径，使这些路径经过 DAG 上的所有点恰好各一次。</p>\n</li>\n<li><p>我们可以使用下面这样的思路：最开始，把每个点自己作为一条路径（这时一共有 $n$ 条路径），然后不断地将已有的路径<strong>首尾相连</strong>，合并成更长的路径，直到所有点被覆盖为止。</p>\n</li>\n<li><p>接下来，我们以这张DAG为例：</p>\n</li>\n<li><p><img data-src=\"https://pic1.zhimg.com/80/v2-cf1624121bc7f130adc1bb859c6c22f4_720w.jpg\"></p>\n</li>\n<li><p>建网络流模型。我们把原图上的每个点<strong>拆</strong>成两个点（对于点<code>x</code>，可以把从它拆出去的点记为<code>x+n</code>），其中一个点与源点相连，另一个与汇点相连。</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-8be6911cfe0dff2357ef750e93487466_720w.jpg\"></p>\n</li>\n<li><p>然后对于原 DAG 上的边 $A-&gt;B$，我们在网络中连接上 $A-&gt;B’$：</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-9115ac6cc2e0dd24ff8cb08bcc55694e_720w.jpg\"></p>\n</li>\n<li><p>这里每一条边的容量均为 $1$。现在我说：跑一遍最大流，便能得到最大合并路径数，再用点数去减即得最小路径覆盖数。这几乎是显然的：从 $A$ 点到 $B’$ 点的每一条流，都代表着一次合并。而从源点只给每个点输送 $1$ 单位流量，又保证了每个点只被经过一次。</p>\n</li>\n<li><p>实际上，这里本质上就是二分图匹配，所以用<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NjIyOTcwMA==\">匈牙利算法</span>也是可以的，复杂度略差一点。</p>\n</li>\n</ul>\n<h3 id=\"P2764-最小路径覆盖问题\"><a href=\"#P2764-最小路径覆盖问题\" class=\"headerlink\" title=\"P2764 | 最小路径覆盖问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI3NjQ=\">P2764 | 最小路径覆盖问题</span></h3><ul>\n<li>这道题有个麻烦点在于，需要输出方案。</li>\n<li>如何输出方案？一种思路是在跑完最大流后再 dfs 一遍，但那样未免麻烦，我们其实可以在增广途中就用一个数组 <code>nxt[]</code> 记录每个点的下一个点。例如，如果使用 Dinic算法，可以在 dfs 函数内部稍微加两句：</li>\n</ul>\n<pre><code class=\"cpp\">inline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i];\n        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;\n            int c = dfs(j, min(remain, v));\n            remain -= c;\n            w[i] -= c;\n            w[i ^ 1] += c;\n            if(c)&#123;  // 只有增广成功才修改 nxt\n                nxt[u] = j - n;\n                // 如果选择用 x+n 记录从点 x 拆出的点，这里就这样写，记录下一个点\n            &#125;\n        &#125;\n    &#125;\n    return flow - remain;\n&#125;\n</code></pre>\n<ul>\n<li>然后遍历起点，分别找到对应的路径输出：</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = h[t]; ~i; i = ne[i])&#123;\n    if(w[i ^ 1])&#123;\n        int p = e[i] - n;\n        while(p != s)&#123;\n            cout &lt;&lt; p &lt;&lt; &#39; &#39;;\n            p = nxt[p];\n        &#125;\n        cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li><p>这个遍历起点的方式可以注意一下。什么样的点是起点呢？如果 $A’$ 到汇点的边的残余容量为 $1$，说明没有点流向 $A’$ 点，也就是说 $A$ 是起点。</p>\n</li>\n<li><p>完整代码</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 310, M = 2e4 + 10;\nint h[N], e[M], ne[M], w[M], idx;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint n, m, s, t, lv[N], cur[N];\ninline bool bfs()&#123;\n    memset(lv, -1, sizeof(lv));\n    queue&lt;int&gt; q;\n    q.push(s);\n    lv[s] = 0;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int j = e[i], v = w[i];\n            if(lv[j] == -1 &amp;&amp; v &gt; 0)&#123;\n                lv[j] = lv[u] + 1;\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return lv[t] != -1;\n&#125;\nint nxt[N];\ninline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i];\n        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;\n            int c = dfs(j, min(remain, v));\n            remain -= c;\n            w[i] -= c;\n            w[i ^ 1] += c;\n            if(c)&#123;  // 只有增广成功才修改 nxt\n                nxt[u] = j - n;\n                // 如果选择用 x+n 记录从点 x 拆出的点，这里就这样写，记录下一个点\n            &#125;\n        &#125;\n    &#125;\n    return flow - remain;\n&#125;\ninline int dinic()&#123;\n    int ans = 0;\n    memcpy(cur, h, sizeof(h));\n    while(bfs())&#123;\n        ans += dfs();\n        memcpy(cur, h, sizeof(h));\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    s = 0, t = 2 * n + 1;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b + n, 1);\n        add(b + n, a, 0);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        add(s, i, 1);\n        add(i, s, 0);\n        add(i + n, t, 1);\n        add(t, i + n, 0);\n    &#125;\n    int ans = dinic();\n    for(int i = h[t]; ~i; i = ne[i])&#123;\n        if(w[i ^ 1])&#123;\n            int p = e[i] - n;\n            while(p != s)&#123;\n                cout &lt;&lt; p &lt;&lt; &#39; &#39;;\n                p = nxt[p];\n            &#125;\n            cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    cout &lt;&lt; n - ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"P2765-魔术球问题\"><a href=\"#P2765-魔术球问题\" class=\"headerlink\" title=\"P2765 | 魔术球问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI3NjU=\">P2765 | 魔术球问题</span></h3><ul>\n<li><p>这题乍一看跟网络流关系不大（好像也确实有其他做法），但如果我们把每根柱子看作一条路径，和为完全平方数的关系看作一条边的话，这完全就是DAG的路径覆盖问题了：</p>\n</li>\n<li><p><img data-src=\"https://pic2.zhimg.com/80/v2-28f84cb18d1c6082bb7ec61cead634b5_720w.jpg\"></p>\n</li>\n<li><p>因为 $n$ 的范围很小，我们只需要一步一步建图，每添加一个新点就求一次最大流。如果某时刻求出的最小路径覆盖已经超过了 $n$ ，那说明加入这个点前的点的数量就是答案。</p>\n</li>\n<li><p>这个题还有一个小坑点，拆点时不能拆成 $x$ 和 $x+n$ ，因为这道题里的 $n$ 并不是点数，而是路径数。</p>\n</li>\n<li><p>完整代码</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 4010, M = 4e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[M], ne[M], w[M], idx;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n    e[idx] = a, w[idx] = 0, ne[idx] = h[b], h[b] = idx++;\n&#125;\nint n, s, t, lv[N], cur[N];\ninline bool bfs()&#123;\n    memset(lv, -1, sizeof(lv));\n    queue&lt;int&gt; q;\n    q.push(s);\n    lv[s] = 0;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int j = e[i], v = w[i];\n            if(lv[j] == -1 &amp;&amp; v &gt; 0)&#123;\n                lv[j] = lv[u] + 1;\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return lv[t] != -1;\n&#125;\nint nxt[N];\ninline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i];\n        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;\n            int c = dfs(j, min(remain, v));\n            remain -= c;\n            w[i] -= c;\n            w[i ^ 1] += c;\n            if(c)&#123;\n                nxt[u] = j &gt;&gt; 1;\n            &#125;\n        &#125;\n    &#125;\n    return flow - remain;\n&#125;\ninline int dinic()&#123;\n    int ans = 0;\n    memcpy(cur, h, sizeof(h));\n    while(bfs())&#123;\n        ans += dfs();\n        memcpy(cur, h, sizeof(h));\n    &#125;\n    return ans;\n&#125;\ninline bool check(int x)&#123;\n    int ans = sqrt(x);\n    if(ans * ans == x) return true;\n    return false;\n&#125;\nint pre[N &lt;&lt; 2], ans[N &lt;&lt; 2];\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n;\n    s = 0, t = 1;\n    memset(h, -1, sizeof(h));\n    int num = 0, tot = 0;\n    while(1)&#123;\n        tot++, num++;\n        add(s, num &lt;&lt; 1, 1);\n        add(num &lt;&lt; 1 | 1, t, 1);\n        for(int i = 1; i &lt; num; i++)&#123;\n            if(check(i + num))&#123;\n                add(i &lt;&lt; 1, num &lt;&lt; 1 | 1, 1);\n            &#125;\n        &#125;\n        tot -= dinic();\n        /*\n            dinic每次求出新增加的最大匹配\n            dinic()==1，新加入的num和之前的数字匹配成功，放在了以前的柱子上\n                用tot-dinic相当于去掉了新加入的没用的柱子\n            dinic()==0，新加入的num和之前的数字无法匹配，放到新加入的柱子上\n        */\n        if(tot &gt; n) break;\n    &#125;\n    memset(pre, -1, sizeof(pre));\n    cout &lt;&lt; num - 1 &lt;&lt; &#39;\\n&#39;;\n    for(int i = 1; i &lt;= num - 1; i++)&#123;\n        int u = i &lt;&lt; 1;     // 左点\n        for(int j = h[u]; ~j; j = ne[j])&#123;\n            int k = e[j], v = w[j ^ 1];\n            if(v &gt; 0 &amp;&amp; k &gt;&gt; 1)&#123;\n                pre[k &gt;&gt; 1] = i;\n                ans[i] = k &gt;&gt; 1;\n            &#125;\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= num - 1; i++)&#123;\n        if(pre[i] &lt; 0)&#123;    // 判断起点\n            int x = i;\n            cout &lt;&lt; x &lt;&lt; &quot; &quot;;\n            while(ans[x])&#123;\n                cout &lt;&lt; ans[x] &lt;&lt; &quot; &quot;;\n                x = ans[x];\n            &#125;\n            cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"最小割-1\"><a href=\"#最小割-1\" class=\"headerlink\" title=\"最小割\"></a>最小割</h1><ul>\n<li><p>对于一个网络流图 $G; &#x3D;; (V, E)$，其割的定义为一种 <strong>点的划分方式</strong>：将所有的点划分为 $S$ 和 $T$ 两个集合，其中源点 $s \\in S$ ，汇点 $t \\in T$。</p>\n</li>\n<li><p>最小割就是求得一个割，使得割的容量最小。</p>\n</li>\n<li><p><strong>最大流最小割定理</strong> ：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaXdpa2kub3JnL2dyYXBoL2Zsb3cvbWluLWN1dC8jXzU=\">证明</span></p>\n</li>\n</ul>\n<h2 id=\"割边数量\"><a href=\"#割边数量\" class=\"headerlink\" title=\"割边数量\"></a>割边数量</h2><ul>\n<li>如果需要在最小割的前提下最小化割边数量，那么先求出最小割，把没有满流的边容量改成 ，满流的边容量改成 ，重新跑一遍最小割就可求出最小割边数量；如果没有最小割的前提，直接把所有边的容量设成 ，求一遍最小割就好了。</li>\n</ul>\n<h2 id=\"二者取一式问题-1\"><a href=\"#二者取一式问题-1\" class=\"headerlink\" title=\"二者取一式问题\"></a>二者取一式问题</h2><ul>\n<li>于此不再赘述，同上网络流。</li>\n</ul>\n<h3 id=\"P2774-方格取数问题\"><a href=\"#P2774-方格取数问题\" class=\"headerlink\" title=\"P2774 | 方格取数问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI3NzQ=\">P2774 | 方格取数问题</span></h3><ul>\n<li>题意<ul>\n<li>有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>相邻时，横坐标或纵坐标相差仅为 1，所以两个相邻点的横纵坐标之和的奇偶性不同。</li>\n<li>因此，奇偶性相同的点必然不互斥，把互斥的点连边就会形成一个二分图。</li>\n<li>为了实现能删掉一个元素，表示不取这个格子，且删掉的代价就是方格的权值，还能实现反悔，所以使用最小割。</li>\n<li>源点连向二分图的一个点集（横纵坐标之和为奇数的那些方格），边权为点权。删一条边表示不取这个方格。</li>\n<li>二分图的另一个点集连向超级汇，边权还是点权。删边也表示不取此点。</li>\n<li>二分图内部的边，连接着互斥的点。边权全部赋为 $INF$，以保证在最小割中不被删。</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e4 + 10, M = 1e5 + 10;\nint h[N], e[M], w[M], ne[M], idx;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint n, m, s, t, lv[N], cur[N];\ninline bool bfs()&#123;\n    memset(lv, -1, sizeof(lv));\n    queue&lt;int&gt; q;\n    q.push(s);\n    lv[s] = 0;\n    while(q.size())&#123;\n        int u = q.front();\n        q.pop();\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(w[i] &gt; 0 &amp;&amp; lv[j] == -1)&#123;\n                lv[j] = lv[u] + 1;\n                q.push(j);\n            &#125;\n        &#125;\n    &#125;\n    return lv[t] != -1;\n&#125;\ninline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    for(int&amp; i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], v = w[i];\n        if(lv[j] == lv[u] + 1 &amp;&amp; v &gt; 0)&#123;\n            int k = dfs(j, min(remain, v));\n            w[i] -= k;\n            w[i ^ 1] += k;\n            remain -= k;\n        &#125;\n    &#125;\n    return flow - remain;\n&#125;\ninline int dinic()&#123;\n    int ans = 0;\n    memcpy(cur, h, sizeof(h));\n    while(bfs())&#123;\n        ans += dfs();\n        memcpy(cur, h, sizeof(h));\n    &#125;\n    return ans;\n&#125;\ninline int getid(int x, int y)&#123;\n    return (x - 1) * m + y;\n&#125;\nint dx[4] = &#123;0, 0, 1, -1&#125;, dy[4] = &#123;1, -1, 0, 0&#125;;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    s = 0, t = n * m + 1;\n    LL sum = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            int x;\n            cin &gt;&gt; x;\n            sum += x;\n            int id = getid(i, j);\n            if((i + j) &amp; 1)&#123;\n                add(s, id, x);\n                add(id, s, 0);\n                for(int k = 0; k &lt; 4; k++)&#123;\n                    int nx = i + dx[k], ny = j + dy[k];\n                    if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) continue;\n                    int nid = getid(nx, ny);\n                    add(id, nid, 0x3f3f3f3f);\n                    add(nid, id, 0);\n                &#125;\n            &#125;else&#123;\n                add(id, t, x);\n                add(t, id, 0);\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; sum - dinic() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h2 id=\"最大权值闭合图\"><a href=\"#最大权值闭合图\" class=\"headerlink\" title=\"最大权值闭合图\"></a>最大权值闭合图</h2><ul>\n<li><p>最大权值闭合图，即给定一张有向图，每个点都有一个权值（可以为正或负或 0 ），你需要选择一个权值和最大的子图，使得子图中每个点的后继都在子图中。</p>\n</li>\n<li><p>做法：建立超级源点 $s$ 和超级汇点 $t$，若节点 $u$ 权值为正，则 $s$ 向 $u$ 连一条有向边，边权即为该点点权；若节点 $u$ 权值为负，则由 $u$ 向 $t$ 连一条有向边，边权即为该点点权的相反数。原图上所有边权改为 $INF$ 。跑网络最大流，将所有正权值之和减去最大流，即为答案。</p>\n</li>\n</ul>\n<h1 id=\"最小费用最大流-1\"><a href=\"#最小费用最大流-1\" class=\"headerlink\" title=\"最小费用最大流\"></a>最小费用最大流</h1><ul>\n<li><p>我们现在来考虑比一般的<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjIzNzU1MzE=\">网络流</span>复杂一点的一个模型：<strong>最小费用最大流</strong>（<em>Minimum Cost Maximum Flow，</em><strong>MCMF</strong>）。</p>\n</li>\n<li><p>现在网络上的每条边，除了容量外，还有一个属性：<strong>单位费用</strong>。一条边上的费用等于流量×单位费用。我们知道，网络最大流往往可以用多种不同的方式达到，所以现在要求：在保持流最大的同时，找到总费用最少的一种。</p>\n</li>\n<li><p>如下图，有多种方式可以达到最大流 3，但是 S-&gt;3-&gt;T (2) + S-&gt;3-&gt;2-&gt;T (1) 这种流法的费用是 7×2+5×1&#x3D;<strong>19</strong>，而 S-&gt;3-&gt;T (2) + S-&gt;1-&gt;2-&gt;T (1) 这种流法的费用则是7×2+4×1&#x3D;<strong>18</strong>，后者比前者的费用更低。事实上，后者正是这个网络的最小费用最大流。</p>\n</li>\n<li><p><img data-src=\"https://pic4.zhimg.com/80/v2-5d0c4b670cfeb4927613e780ffe206fb_720w.jpg\"></p>\n</li>\n<li><p>其实这个问题很好解决。我们已经知道，只要建了反向边，无论增广的顺序是怎样，都能求出最大流。所以我们只需要每次都增广费用最少的一条路径即可。</p>\n</li>\n</ul>\n<h2 id=\"SSP-算法\"><a href=\"#SSP-算法\" class=\"headerlink\" title=\"SSP 算法\"></a>SSP 算法</h2><ul>\n<li><p>SSP（Successive Shortest Path）算法是一个贪心的算法。它的思路是每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p>\n</li>\n<li><p>如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。此时需要先使用消圈算法消去图上的负圈。</p>\n</li>\n<li><p>只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。</p>\n</li>\n<li><p>具体地，把<strong>EK算法</strong> 里的BFS换成 SPFA :</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">int h[N], e[M], ne[M], w[M], c[M], idx;     // 新增一维费用\nvoid add(int a, int b, int x, int y)&#123;\n    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint n, m, s, t, last[N], flow[N], dis[N];\nbool st[N];\nbool spfa()&#123;\n    queue&lt;int&gt; q;\n    memset(dis, 0x3f, sizeof(dis));\n    memset(last, -1, sizeof(last));\n    memset(st, 0, sizeof(st));\n    flow[s] = INF;\n    dis[s] = 0;\n    q.push(s);\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        st[u] = 0;\n        for(int i = h[u]; ~i; i = ne[i])&#123;\n            int j = e[i], x = w[i], y = c[i];\n            if(dis[j] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;       // 容量大于0才增广\n                dis[j] = dis[u] + y;\n                flow[j] = min(flow[u], x);\n                last[j] = i;\n                if(!st[j])&#123;\n                    st[j] = 1;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return last[t] != -1;\n&#125;\ninline pair&lt;int, int&gt; MCMF()&#123;\n    int maxflow = 0, mincost = 0;\n    while(spfa())&#123;\n        maxflow += flow[t];\n        mincost += flow[t] * dis[t];\n        for(int i = t; i != s; i = e[last[i] ^ 1])&#123;\n            w[last[i]] -= flow[t];\n            w[last[i] ^ 1] += flow[t];\n        &#125;\n    &#125;\n    return &#123;maxflow, mincost&#125;;\n&#125;\nint main()&#123;\n    // 建边\n    int u, v, a, b;\n    add(u, v, a, b);\n    add(v, u, 0, -b);\n&#125;\n</code></pre>\n<ul>\n<li><p>反向边的费用是正向边的相反数（只要你知道建反向边的目的，这应该是显然的）。</p>\n</li>\n<li><p>这和一般的EK算法没多大区别，毕竟SPFA可以看作一种特殊的BFS。当然，也可以把EK用<strong>dinic</strong>取代，这样有时会有很大优化，有时不太明显。（dinic是否采用当前弧优化也比较玄学，有时候不用当前弧优化反而更快。）</p>\n</li>\n<li><p>下为 Dinic 算法实现</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">int h[N], e[M], ne[M], w[M], c[M], idx;     // 新增一维费用\nvoid add(int a, int b, int x, int y)&#123;\n    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint n, m, s, t, dis[N];\nint cur[N];\nbool st[N], vis[N];\ninline bool spfa()&#123;\n    queue&lt;int&gt; q;\n    fill(dis, dis + N, INF);\n    copy(cur, cur + N, h);\n    dis[s] = 0;\n    q.push(s);\n    st[s] = true;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        st[u] = false;\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int j = e[i], x = w[i], y = c[i];\n            if(dis[j] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;\n                dis[j] = dis[u] + y;\n                if(!st[j])&#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return dis[t] != INF;\n&#125;\ninline int dfs(int u = s, int flow = INF)&#123;\n    if(u == t) return flow;\n    vis[u] = true;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], x = w[i], y = c[i];\n        if(!vis[j] &amp;&amp; dis[j] == dis[u] + y &amp;&amp; x &gt; 0)&#123;\n            int c = dfs(j, min(remain, x));\n            remain -= c;\n            w[i] -= c;\n            w[i ^ 1] += c;\n        &#125;\n    &#125;\n    vis[u] = false;\n    return flow - remain;\n&#125;\ninline pair&lt;int, int&gt; dinic()&#123;\n    int maxflow = 0, mincost = 0;\n    while(spfa())&#123;\n        int flow = dfs();\n        maxflow += flow;\n        mincost += flow * dis[t];\n    &#125;\n    return &#123;maxflow, mincost&#125;;\n&#125;\n</code></pre>\n<h3 id=\"P4452-航班安排\"><a href=\"#P4452-航班安排\" class=\"headerlink\" title=\"P4452 | 航班安排\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ0NTI=\">P4452 | 航班安排</span></h3><ul>\n<li>网络流重点在于建图。</li>\n<li>本题对请求进行拆点，拆点后两个点之间连价值为 $c$，流量为 1 的边，代表每一个请求只能执行一次。</li>\n<li>对于一个请求，如果00时刻可以从 0 机场飞到该请求的起点机场，那么源点向该请求连价值为 (-飞行费用)，流量为 INF 的边，同理，若一个请求的结束时间，加上它的结束机场飞回 0 的时间小于等于总的时间限制，该请求向汇点连边。</li>\n<li>但是每次执行完一个请求并未规定一定要飞回 0 机场，也可以飞去其他请求的起点机场，所以两两枚举请求，如果满足时间条件也进行连边。</li>\n<li>最后考虑有 k 架飞机，所以再建一个源点，向原来的源点连费用为 0，流量为 k 的边即可。</li>\n<li>稍微改下 spfa 函数，让其跑最长路。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 510, M = 1e6 + 10, INF = 0x3f3f3f3f;\nint h[N], e[M], ne[M], w[M], c[M], idx;\nvoid add(int a, int b, int x, int y)&#123;\n    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;\n    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;\n&#125;\nstruct Node&#123;\n    int a, b, s, t, c;\n&#125;query[N];\nint s, t, cur[N], dis[N];\nbool st[N], vis[N];\ninline bool spfa()&#123;\n    queue&lt;int&gt; q;\n    fill(dis, dis + N, -INF);\n    memcpy(cur, h, sizeof(cur));\n    dis[s] = 0;\n    q.push(s);\n    st[s] = true;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        st[u] = false;\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int j = e[i], x = w[i], y = c[i];\n            if(dis[j] &lt; dis[u] + y &amp;&amp; x &gt; 0)&#123;\n                dis[j] = dis[u] + y;\n                if(!st[j])&#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return dis[t] != -0x3f3f3f3f;\n&#125;\ninline int dfs(int u = s, int flow = INF)&#123;\n    if(u == t) return flow;\n    vis[u] = true;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], x = w[i], y = c[i];\n        if(!vis[j] &amp;&amp; dis[j] == dis[u] + y &amp;&amp; x &gt; 0)&#123;\n            int c = dfs(j, min(remain, x));\n            remain -= c;\n            w[i] -= c;\n            w[i ^ 1] += c;\n        &#125;\n    &#125;\n    vis[u] = false;\n    return flow - remain;\n&#125;\ninline LL dinic()&#123;\n    LL ans = 0;\n    while(spfa())&#123;\n        int tmp = dfs();\n        ans += (LL) tmp * dis[t];\n    &#125;\n    return ans;\n&#125;\nint g[N][N], f[N][N];\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    int n, m, k, ed;\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; ed;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            cin &gt;&gt; g[i][j];\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            cin &gt;&gt; f[i][j];\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        cin &gt;&gt; query[i].a &gt;&gt; query[i].b &gt;&gt; query[i].s &gt;&gt; query[i].t &gt;&gt; query[i].c;\n        query[i].a++;\n        query[i].b++;\n    &#125;\n    s = 0, t = m * 2 + 5;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        add(i + 1, i + m + 1, 1, query[i].c);\n        if(query[i].t + g[query[i].b][1] &lt;= ed)&#123;\n            add(i + m + 1, t, INF, -f[query[i].b][1]);\n        &#125;\n        if(query[i].s - g[1][query[i].a] &gt;= 0)&#123;\n            add(1, i + 1, INF, -f[1][query[i].a]);\n        &#125;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            if(i != j &amp;&amp; query[i].t + g[query[i].b][query[j].a] &lt;= query[j].s)&#123;\n                add(i + m + 1, j + 1, INF, -f[query[i].b][query[j].a]);\n            &#125;\n        &#125;\n    &#125;\n    add(s, 1, k, 0);\n    cout &lt;&lt; dinic() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"P2050-美食节\"><a href=\"#P2050-美食节\" class=\"headerlink\" title=\"P2050 | 美食节\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIwNTA=\">P2050 | 美食节</span></h3><ul>\n<li>费用流 + 动态开点</li>\n<li>被用到的点很少，因此可以一边跑流一边加点，这样可以省去很多没用的点。</li>\n<li>点数的规模 $(mp + n) \\to (n + m + p)$，边数的规模 $(nmp) \\to (np)$。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vc29sdXRpb24vUDIwNTA=\">详细题解</span></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e5 + 10, M = 3e7 + 10;\nint h[N], e[M], ne[M], w[M], c[M], idx;\nvoid add(int a, int b, int x, int y)&#123;\n    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;\n    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;\n&#125;\n\nint nxt[N], top[N];\nint n, m, s, t, dis[N], cur[N];\nbool st[N], vis[N];\nint p[N], ct[60][120];\ninline bool spfa()&#123;\n    memset(dis, 0x3f, sizeof(dis));\n    memcpy(cur, h, sizeof(h));\n    queue&lt;int&gt; q;\n    q.push(s);\n    dis[s] = 0;\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        st[u] = 0;\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int j = e[i], x = w[i], y = c[i];\n            if(dis[j] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;\n                dis[j] = dis[u] + y;\n                if(!st[j])&#123;\n                    st[j] = 1;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return dis[t] != 0x3f3f3f3f;\n&#125;\ninline int dfs(int u = s, int flow = 0x3f3f3f3f)&#123;\n    if(u == t) return flow;\n    vis[u] = 1;\n    int remain = flow;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int j = e[i], x = w[i], y = c[i];\n        if(!vis[j] &amp;&amp; dis[j] == dis[u] + y &amp;&amp; x &gt; 0)&#123;\n            int tmp = dfs(j, min(remain, x));\n            if(tmp &gt; 0)&#123;\n                remain -= tmp;\n                w[i] -= tmp;\n                w[i ^ 1] += tmp;\n                nxt[u] = j;\n            &#125;\n        &#125;\n    &#125;\n    vis[u] = 0;\n    return flow - remain;\n&#125;\nint sum;\ninline int getid(int x, int y)&#123;\n    return (x - 1) * sum + y;\n&#125;\ninline pair&lt;int, int&gt; dinic()&#123;\n    int maxflow = 0, mincost = 0;\n    while(spfa())&#123;\n        int flow = dfs();\n        maxflow += flow;\n        mincost += flow * dis[t];\n        for(int j = 1; j &lt;= m; j++)&#123;\n            if(nxt[n + getid(j, top[j])] &amp;&amp; top[j] &lt; sum)&#123;\n                top[j]++;\n                int now = n + getid(j, top[j]);\n                for(int i = 1; i &lt;= n; i++)&#123;\n                    add(i, now, 1, ct[i][j] * top[j]);\n                &#125;\n                add(now, t, 1, 0);\n            &#125;\n        &#125;\n    &#125;\n    return &#123;maxflow, mincost&#125;;\n&#125;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; p[i];\n        sum += p[i];\n    &#125;\n    s = m * sum + n + 1, t = s + 1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            cin &gt;&gt; ct[i][j];\n        &#125;\n    &#125;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= n; i++)&#123;\n        add(s, i, p[i], 0);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            add(i, n + getid(j, 1), 1, ct[i][j]);\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        top[i] = 1;\n        add(n + getid(i, 1), t, 1, 0);\n    &#125;\n    auto [x, y] = dinic();\n    cout &lt;&lt; y &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"P3980-志愿者招募\"><a href=\"#P3980-志愿者招募\" class=\"headerlink\" title=\"P3980 | 志愿者招募\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM5ODA=\">P3980 | 志愿者招募</span></h3><ul>\n<li><p>招募的人可以打工一段时间，且只需要支付一次费用，因此需要特殊的建图方式。</p>\n</li>\n<li><p>将人数限制放置在相邻两天之间，并且将志愿者单独建边，覆盖那一段时间。</p>\n</li>\n<li><p>此时我们相当于是把第i天的决策放到了第 $i$ 个点和第 $i+1$ 个点之间的所有边上（就是把所有点排成一排，这两个点之间的那一条位置里的所有边，包括跨过这个区间的志愿者边）</p>\n</li>\n<li><p>需要志愿者？让它们从志愿者边上流过去，同时让人数限制边满流到 $-a[i]$，这样求一个 $1\\to n+1$ 的最大流，流量为 $0$ 的最小费用就是雇佣人的最小费用了</p>\n</li>\n<li><p>为了让这个限制起效，又因为网络流中流量非负，所以我们建立点 $S$ 和 $T$，限制为$INF$，费用为 $0$。</p>\n</li>\n<li><p>同时，我们把之前的人数限制边的流量改成$(INF-a[i])$，这样最终的最大流一定是$INF$，而且限制依然成立</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1010, M = 5e4 + 10, INF = 0x3f3f3f3f;\nint h[N], e[M], ne[M], w[M], c[M], idx;\nvoid add(int a, int b, int x, int y)&#123;\n    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;\n    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;\n&#125;\nint n, m, s, t, dis[N], cur[N];\nbool st[N], vis[N];\ninline bool spfa()&#123;\n    memset(dis, 0x3f, sizeof dis);\n    memcpy(cur, h, sizeof cur);\n    queue&lt;int&gt; q;\n    dis[s] = 0;\n    q.push(s);\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        st[u] = 0;\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int v = e[i], x = w[i], y = c[i];\n            if(dis[v] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;\n                dis[v] = dis[u] + y;\n                if(!st[v])&#123;\n                    st[v] = true;\n                    q.push(v);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return dis[t] != INF;\n&#125;\ninline int dfs(int u = s, int flow = INF)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    vis[u] = true;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int v = e[i], x = w[i], y = c[i];\n        if(!vis[v] &amp;&amp; dis[v] == dis[u] + y &amp;&amp; x &gt; 0)&#123;\n            int tmp = dfs(v, min(remain, x));\n            remain -= tmp;\n            w[i] -= tmp;\n            w[i ^ 1] += tmp;\n        &#125;\n    &#125;\n    vis[u] = false;\n    return flow - remain;\n&#125;\ninline pair&lt;int, int&gt; dinic()&#123;\n    int maxflow = 0, mincost = 0;\n    while(spfa())&#123;\n        int flow = dfs();\n        maxflow += flow;\n        mincost += flow * dis[t];\n    &#125;\n    return &#123;maxflow, mincost&#125;;\n&#125;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        add(i, i + 1, INF - x, 0);\n    &#125;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int u, v, a;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; a;\n        add(u, v + 1, INF, a);\n    &#125;\n    s = 0, t = n + 2;\n    add(s, 1, INF, 0);\n    add(n + 1, t, INF, 0);\n    auto [maxflow, mincost] = dinic();\n    cout &lt;&lt; mincost &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h1 id=\"上下界网络流\"><a href=\"#上下界网络流\" class=\"headerlink\" title=\"上下界网络流\"></a>上下界网络流</h1><ul>\n<li>上下界网络流可以看做普通网络流的升级版，现在对于流量网络，我们不再只关注其流量的<strong>上界</strong>，而是同时关注流量的<strong>上下界</strong>。</li>\n</ul>\n<h3 id=\"无源汇有上下界可行流\"><a href=\"#无源汇有上下界可行流\" class=\"headerlink\" title=\"无源汇有上下界可行流\"></a>无源汇有上下界可行流</h3><ul>\n<li><p>这是上下界网络流中最简单的一种，给定一个没有源点和汇点、每条边的流量有上下界的流量网络，问是否存在一种可行流使得流量平衡。</p>\n</li>\n<li><p><img data-src=\"https://pic1.zhimg.com/80/v2-5c7a4eaa79b5c9da4be7fb03658ba598_720w.jpg\"></p>\n</li>\n<li><p>做法是，我们把它<strong>拆</strong>成两个结构与原图相同的普通网络，一个每条边的容量为原网络对应边的<strong>流量下界</strong>，另一个为对应边的<strong>流量上界与下界之差</strong>。</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-b2894f46d6e7b1f146a7dd5edb6be1d6_720w.jpg\"></p>\n</li>\n<li><p>我们希望下界网络和差网络的流相加后恰好是原图的一个可行流，这首先要求下界网络是满流的（可行流必须达到每条边的下界）。但是下界网络满流后不一定流量平衡，所以我们要对差网络进行一定的修改以弥补这种不平衡。</p>\n</li>\n<li><p>我们分别考虑下界网络的每个点。A点，流入量为3，流出量也为3，所以是平衡的，那么在差网络中，也应该是平衡的，所以不做修改。B点，流入量为3，流出量为1，流入比流出多2，所以我们希望在差网络中，B的流出应该比流入多2，于是我们在差网络中新设一个<strong>源点</strong>，然后加入一条容量为2的<strong>附加边</strong>从源点连向B，这样在差网络平衡时，除去附加边，B点的流出恰好比流入多2，C点与B点类似。D点则相反，因为我们希望在差网络中D点流入比流出多2，所以我们新设一个<strong>汇点</strong>，然后从D点连一条容量为2的附加边到汇点，E点又和D类似。</p>\n</li>\n<li><p>也就是说，如果下界网络中某个点有x的净流入，在差网络中我们就从源点向它连一条容量为x的附加边；相反，如果下界网络中某个点有x的净流出，在差网络中我们就从它向汇点连一条容量为x的附加边。这样，我们把差网络修改如下：</p>\n</li>\n<li><p><img data-src=\"https://pic1.zhimg.com/80/v2-f213c0b0ff05657a1b819179d195ba34_720w.jpg\"></p>\n</li>\n<li><p>在差网络上跑一遍最大流，把每条非附加边的流，加上下界网络的满流，就是一个可行流。但是，如果跑完最大流发现，存在附加边未满流，那说明平衡条件没有得到满足，于是原图不存在可行流。</p>\n</li>\n<li><p>在实际中，是不需要建立下界网络的，只需要对差网络进行操作即可。另外最后判断的时候并无必要遍历所有附加边，而只需要判断所有从源点出发的边，或者判断所有连向汇点的边即可，因为根据网络流的性质，两者容量和应该相等，于是它们要么都满流，要么都不满流。</p>\n</li>\n</ul>\n<h2 id=\"有源汇有上下界可行流\"><a href=\"#有源汇有上下界可行流\" class=\"headerlink\" title=\"有源汇有上下界可行流\"></a>有源汇有上下界可行流</h2><ul>\n<li><p>从汇点到源点连一条下界为 $0$ ，上界为 $∞$ 的附加边，得到一张和原图等价的无源汇流量网络，于是转化成了无源汇有上下界可行流问题。此时从源点到汇点的可行流流量，即为从汇点到源点的那条附加边的流量（注意下界网络中对应边流量为 $0$）。</p>\n</li>\n<li><p>注意，这时候原来的源点和汇点已被处理成普通点，和之后差网络需要额外建立的源、汇点是不同的点，之后如果这两者同时出现，我们记前者为 S 、 T ，后者为 S′ 、 T′ 。</p>\n</li>\n<li><p><img data-src=\"https://pic2.zhimg.com/80/v2-02ceb585a4de85ffcb326000849a251d_720w.jpg\"></p>\n</li>\n</ul>\n<h2 id=\"有源汇有上下界最大流\"><a href=\"#有源汇有上下界最大流\" class=\"headerlink\" title=\"有源汇有上下界最大流\"></a>有源汇有上下界最大流</h2><ul>\n<li><p>按照上一节的方法，我们已经得到了一个可行流，且知道它的流量就是T到S的附加边的流量。</p>\n</li>\n<li><p><img data-src=\"https://pic2.zhimg.com/80/v2-fdfcf569bb5131fce027d0c2d92e52e9_720w.jpg\"></p>\n</li>\n<li><p>要求从 $S$ 到 $T$ 的最大流，我们可以在差网络中把所有附加边删除，然后以 $S$ 与 $T$ 为源点与汇点，再求残余网络的最大流，加上可行流的流量即为原网络的最大流。这是因为，可行流已经保证了流量平衡，那么删去附加边后，我们再跑一次最大流把残余网络“榨干”，最后得到的流仍保证是平衡的。</p>\n</li>\n<li><p><img data-src=\"https://pic3.zhimg.com/80/v2-849e347da5ce4a259c4f346f9082597a_720w.jpg\"></p>\n</li>\n<li><p>当然实际上 $S’$ 与 $T’$ 连接的附加边不需要删，这种出度或入度为 0、又非源汇点的点是不影响最大流的，何况如果存在可行流，它们的残余容量已经为 0 了。</p>\n</li>\n</ul>\n<h2 id=\"有源汇有上下界最小流\"><a href=\"#有源汇有上下界最小流\" class=\"headerlink\" title=\"有源汇有上下界最小流\"></a>有源汇有上下界最小流</h2><ul>\n<li>跟上面几乎完全相同，只需要在拆掉附加边后，<strong>从汇点到源点</strong>，而不是从源点到汇点跑一遍最大流。可行流的流量，减去从汇点到源点的最大流即为答案。如果说上下界最大流是把残量网络“榨干”，那么上下界最小流就是把不需要的流“退回”。</li>\n</ul>\n<h2 id=\"有上下界最小费用可行流\"><a href=\"#有上下界最小费用可行流\" class=\"headerlink\" title=\"有上下界最小费用可行流\"></a>有上下界最小费用可行流</h2><ul>\n<li>和（无&#x2F;有源汇）有上下界可行流的原理相同，也是拆成两个网络。所有附加边的费用设为0。最后的费用是下界网络满流的费用，加上在差网络上跑MCMF后得到的费用之和。而前者即所有边的容量与费用乘积的和。注意，这样求出来的是满足最小费用的可行流，而不是满足流最大的前提下费用最小的流。</li>\n</ul>\n<h2 id=\"P4043-支线剧情\"><a href=\"#P4043-支线剧情\" class=\"headerlink\" title=\"P4043 | 支线剧情\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQwNDM=\">P4043 | 支线剧情</span></h2><ul>\n<li>题意<ul>\n<li>观看一个支线剧情花费一定时间，并且每个支线剧情至少观看一次，将这个条件抽象成网络上的一条边，容量上界为 $\\infty$，下界为 1，费用为 $t_i$。</li>\n<li>由于在每个点都可以退出游戏，于是将每个点向一个虚拟的汇点 $t$ 连边，容量上界为 $\\infty$，下界为 0，费用为 0。</li>\n<li>求解这个源点为 $s&#x3D;1$，汇点为 $t$ 的网络的最小费用可行流即可。</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>由于这是一个有源有汇网络，其中源点 $s$ 与汇点 $t$ 不满足流量守恒性质，所以连边 $t \\to s$ 将其转化为无源无汇网络。</li>\n<li>先让每一条边都满足它的容量下界，可以发现此时有些点并不满足流量守恒性质，于是我们需要补流。</li>\n<li>对于每一个点 $u$，记录它流入流量与流出流量的差</li>\n<li>建立超级源点 $S$，与超级汇点 $T$ 用于补流。然后对于 $d_u$ 分类讨论：<ul>\n<li>$d_u&#x3D;0$，不需要补流。</li>\n<li>$d_u&gt;0$，流入流量多了，连边 $u \\to T$，容量为 $d_u$，将多余流量送入超级汇点 $T$。</li>\n<li>$d_u&lt;0$，流入流量不够，连边 $S \\to u$，容量为 $|d_u|$，让超级源点 $S$ 对其补流。</li>\n</ul>\n</li>\n<li>在新建的网络上跑最小费用最大流即可。</li>\n<li>由于最开始强制给了每条边 1 的流量，最小费用还要加上这个操作的费用才是答案。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 2010, M = 2e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[M], ne[M], w[M], c[M], idx;\nvoid add(int a, int b, int x, int y)&#123;\n    e[idx] = b, w[idx] = x, c[idx] = y, ne[idx] = h[a], h[a] = idx++;\n    e[idx] = a, w[idx] = 0, c[idx] = -y, ne[idx] = h[b], h[b] = idx++;\n&#125;\nint n, s, t, dis[N], cur[N];\nbool st[N], vis[N];\ninline bool spfa()&#123;\n    for(int i = 1; i &lt;= n + 3; i++)&#123;\n        dis[i] = 0x3f3f3f3f;\n    &#125;\n    memcpy(cur, h, sizeof cur);\n    queue&lt;int&gt; q;\n    dis[s] = 0;\n    q.push(s);\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        st[u] = 0;\n        for(int i = cur[u]; ~i; i = ne[i])&#123;\n            int v = e[i], x = w[i], y = c[i];\n            if(dis[v] &gt; dis[u] + y &amp;&amp; x &gt; 0)&#123;\n                dis[v] = dis[u] + y;\n                if(!st[v])&#123;\n                    st[v] = true;\n                    q.push(v);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return dis[t] != INF;\n&#125;\ninline int dfs(int u = s, int flow = INF)&#123;\n    if(u == t) return flow;\n    int remain = flow;\n    vis[u] = true;\n    for(int &amp;i = cur[u]; ~i; i = ne[i])&#123;\n        int v = e[i], x = w[i], y = c[i];\n        if(!vis[v] &amp;&amp; dis[v] == dis[u] + y &amp;&amp; x &gt; 0)&#123;\n            int tmp = dfs(v, min(remain, x));\n            remain -= tmp;\n            w[i] -= tmp;\n            w[i ^ 1] += tmp;\n        &#125;\n    &#125;\n    vis[u] = false;\n    return flow - remain;\n&#125;\ninline pair&lt;int, int&gt; dinic()&#123;\n    int maxflow = 0, mincost = 0;\n    while(spfa())&#123;\n        int flow = dfs();\n        maxflow += flow;\n        mincost += flow * dis[t];\n    &#125;\n    return &#123;maxflow, mincost&#125;;\n&#125;\nint d[N];\nint main()&#123;\n    int ans = 0;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n;\n    memset(h, -1, sizeof h);\n    s = n + 2, t = n + 3;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        for(int j = 1; j &lt;= x; j++)&#123;\n            int a, b;\n            cin &gt;&gt; a &gt;&gt; b;\n            d[a]++, d[i]--;\n            ans += b;\n            add(i, a, INF, b);\n        &#125;\n    &#125;\n    int S = 1, T = n + 1;\n    for(int i = 2; i &lt;= n; i++)&#123;\n        add(i, T, INF, 0);\n    &#125;\n    add(T, S, INF, 0);\n    for(int i = 1; i &lt;= n + 1; i++)&#123;\n        if(d[i] &gt; 0) add(s, i, d[i], 0);\n        if(d[i] &lt; 0) add(i, t, -d[i], 0);\n    &#125;\n    auto [maxflow, mincost] = dinic();\n    cout &lt;&lt; mincost + ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板",
                "学习笔记"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/Flyme%E6%9B%B4%E6%96%B0.html",
            "url": "https://asterzc19.github.io/post/Flyme%E6%9B%B4%E6%96%B0.html",
            "title": "Flyme 更新日志",
            "date_published": "2022-06-30T10:00:20.000Z",
            "content_html": "<blockquote>\n<p>自 2022 年 5 月 1 日起更新，来自 MEIZU 17 。</p>\n</blockquote>\n<h3 id=\"2022-年-6-月-30-日\"><a href=\"#2022-年-6-月-30-日\" class=\"headerlink\" title=\"2022 年 6 月 30 日\"></a>2022 年 6 月 30 日</h3><h4 id=\"Flyme-9-3-0-0A\"><a href=\"#Flyme-9-3-0-0A\" class=\"headerlink\" title=\"Flyme 9.3.0.0A\"></a>Flyme 9.3.0.0A</h4><ul>\n<li>正式版</li>\n</ul>\n<h4 id=\"适配机型\"><a href=\"#适配机型\" class=\"headerlink\" title=\"适配机型\"></a>适配机型</h4><ul>\n<li>魅族 18、18s 系列机型</li>\n<li>魅族 17 系列机型</li>\n</ul>\n<h4 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h4><ul>\n<li><strong>功能调整</strong><ul>\n<li><strong>系统界面</strong>  <ul>\n<li>Alive 壁纸新增轻启、山脉、银河三款息屏样式及四款桌面效果，Alive 息屏支持自定义显示信息，美观更实用  </li>\n<li>桌面新增应用下载安装动画，当从应用商店下载安装新应用时，桌面显示进度并支持点击暂停或继续、长按取消  </li>\n<li>桌面设置支持更换图标包，可更换已下载的主题美化主题图标或已安装的安卓图标包，路径：桌面设置-图标风格  </li>\n<li>桌面支持双击空白处锁屏，开启路径：桌面设置-更多设置-双击锁屏  </li>\n<li>游戏模式新增低电量提示，当电量低于 20% 和 5% 时进行提示</li>\n</ul>\n</li>\n<li><strong>Aicy</strong>  <ul>\n<li>Aicy 识屏新增商品优惠比价，在聊天、商品等界面识别到商品信息时弹出商品比价，并支持领取优惠券  </li>\n<li>Aicy 建议支持复制商品链接时建议打开对应的购物应用，开启路径：设置-Aicy-Aicy 建议-打开购物应用</li>\n</ul>\n</li>\n<li><strong>相机和图库</strong>  <ul>\n<li>相机自动拍照模式支持快速录像，调整长按快门键响应操作：按住快门键进入快速录像，松手结束录像；按住快门键并上滑锁定进入持续录像；向左或向右拖动快门键进入连拍  </li>\n<li>新增图库桌面插件，预览时刻照片及视频，镜头下的美好时刻跃然桌面之上  </li>\n<li>图库编辑新增多款贴纸，文艺又俏皮</li>\n</ul>\n</li>\n<li><strong>手机管家</strong>  <ul>\n<li>新增支持拦截第三方应用通过运营商网络获取手机号码，防止不选择一键注册并登录也会被第三方应用获取手机号码的情况  </li>\n<li>新增支持设置第三方应用启动行为，可选控制应用自启动及应用关联启动行为，路径：手机管家-隐私和权限-自启动管理 &#x2F; 应用行为记录_启动行为  </li>\n<li>优化应用权限管理部分文案显示及选项设置  </li>\n<li>流量管理新增 GB 单位选项</li>\n</ul>\n</li>\n<li><strong>系统</strong>  <ul>\n<li>更新 Android 安全补丁，提升系统安全性  </li>\n<li>计算器修改为计算时显示完整计算算式，优化标准计算器和科学计算器的切换动画，并在切换时不改变计算内容和记录  </li>\n<li>Flyme 妙连新增支持魅族 PANDAER x 猫王 XOG 白金星舟耳机、魅蓝 Blus Air 耳机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>问题改进</strong><ul>\n<li><strong>系统</strong><ul>\n<li>优化多个场景下的异常卡顿问题，提升系统整体流畅度</li>\n<li>修复偶现出现一条短信空通知的问题</li>\n<li>修复偶现 Aicy 纵览插件集合卡片消失的问题</li>\n<li>修复通话记录中的号码添加标记选择自定义会出现闪退的问题</li>\n<li>修复设置账号和同步页面应用列表下方空白遮挡过大的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2022-年-6-月-24-日\"><a href=\"#2022-年-6-月-24-日\" class=\"headerlink\" title=\"2022 年 6 月 24 日\"></a>2022 年 6 月 24 日</h3><ul>\n<li>Flyme 9.3.0.0A</li>\n<li>灰度测试</li>\n<li>适配机型<ul>\n<li>魅族 18、18s 系列机型</li>\n<li>魅族 17 系列机型</li>\n</ul>\n</li>\n<li>更新日志<ul>\n<li>安卓安全补丁更新至 6 月 1 日</li>\n<li>系统调频说明文案优化</li>\n<li>新增桌面图库小组件</li>\n<li>新增桌面空白处双击锁屏</li>\n<li>新增可设置已安装主题的图标和第三方图标包</li>\n<li>Alive 锁屏壁纸优化，新增三种 Alive 锁屏样式，新增桌面壁纸不模糊</li>\n<li>多处动效调整，打断动画优化</li>\n<li>One Mind 更新</li>\n<li>新增自启动管理</li>\n<li>新增手机号码一键登录隐私保护</li>\n<li>新增流量管理“GB”单位</li>\n<li>新增应用商店安装应用时桌面显示预览图标</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2022-年-6-月-22-日\"><a href=\"#2022-年-6-月-22-日\" class=\"headerlink\" title=\"2022 年 6 月 22 日\"></a>2022 年 6 月 22 日</h3><ul>\n<li>Flyme 9.2</li>\n<li>灰度测试，版本号未变</li>\n<li>适配机型<ul>\n<li>魅族 18、18s 系列机型</li>\n<li>魅族 17 系列机型</li>\n</ul>\n</li>\n<li>更新日志<ul>\n<li>新增自启动管理</li>\n<li>新增手机号码一键登录隐私保护</li>\n<li>新增流量管理“GB”单位</li>\n<li>新增应用商店安装应用时桌面显示预览图标</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2022-年-6-月-15-日\"><a href=\"#2022-年-6-月-15-日\" class=\"headerlink\" title=\"2022 年 6 月 15 日\"></a>2022 年 6 月 15 日</h3><ul>\n<li>Flyme 9.2</li>\n<li>灰度测试，版本号未变</li>\n<li>适配机型<ul>\n<li>魅族 18、18s 系列机型</li>\n<li>魅族 17 系列机型</li>\n</ul>\n</li>\n<li>更新日志<ul>\n<li>安卓安全补丁更新至 6 月 1 日</li>\n<li>系统调频说明文案优化</li>\n<li>新增桌面图库小组件</li>\n<li>新增桌面空白处双击锁屏</li>\n<li>新增可设置已安装主题的图标和第三方图标包</li>\n<li>Alive 锁屏壁纸优化，新增三种 Alive 锁屏样式，新增桌面壁纸不模糊</li>\n<li>多处动效调整，打断动画优化</li>\n<li>One Mind 更新</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Flyme",
                "Android",
                "MEIZU"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html",
            "url": "https://asterzc19.github.io/post/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86.html",
            "title": "高级数据结构题集",
            "date_published": "2022-06-09T10:00:20.000Z",
            "content_html": "<blockquote>\n<p>包括并查集、树状数组、线段树、可持久化数据结构、平衡树、AC 自动机。<br>其余数据结构参考自 Pecco 、OI WIKI 以及他人博客。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><h3 id=\"格子游戏\"><a href=\"#格子游戏\" class=\"headerlink\" title=\"格子游戏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI1Mi8=\">格子游戏</span></h3><ul>\n<li>判断是否成环，当且仅当新加入的那条边的两个端点都在同一个集合中。</li>\n<li>二维坐标 $(x, y)$ 转换成一维坐标 $(x \\times n + y)$ （ $x, y$ 均从 0 开始）。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 40010;\nint p[N];\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m, pos = 0;\n    cin &gt;&gt; n &gt;&gt; m;\n    auto getid = [&amp;](int x, int y)&#123;\n        return (x * n + y);\n    &#125;;\n    for(int i = 0; i &lt; n * n; i++) p[i] = i;   // 转换坐标从 0 开始\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int x, y;\n        char op;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;\n        x--, y--;   // 坐标从 0 开始\n        int a = getid(x, y), b;\n        if(op == &#39;R&#39;) b = getid(x, y + 1);\n        else b = getid(x + 1, y);\n        int pa = find(a), pb = find(b);\n        if(pa == pb)&#123;\n            pos = i;\n            break;\n        &#125;\n        p[pa] = pb;\n    &#125;\n    if(!pos) cout &lt;&lt; &quot;draw&quot; &lt;&lt; endl;\n    else cout &lt;&lt; pos &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"搭配购买\"><a href=\"#搭配购买\" class=\"headerlink\" title=\"搭配购买\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI1NC8=\">搭配购买</span></h3><ul>\n<li>维护 size 的并查集 + 01 背包</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010;\nint p[N], v[N], w[N], dp[N];\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m, c;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; v[i] &gt;&gt; w[i];\n        p[i] = i;\n    &#125;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        int pa = find(a), pb = find(b);\n        if(pa != pb)&#123;\n            v[pb] += v[pa];\n            w[pb] += w[pa];\n            p[pa] = pb;\n        &#125;\n    &#125;\n    // 01 背包\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(p[i] == i)&#123;\n            for(int j = c; j &gt;= v[i]; j--)&#123;\n                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[c] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"程序自动分析\"><a href=\"#程序自动分析\" class=\"headerlink\" title=\"程序自动分析\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjM5Lw==\">程序自动分析</span></h3><ul>\n<li>离散化</li>\n<li>将所有相等的条件合并</li>\n<li>依次判断每个不相等的条件</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint p[200010], cnt;\nunordered_map&lt;int, int&gt; mp;\nstruct Query\n&#123;\n    int x, y, e;\n&#125;query[200010];\n\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint get(int x)&#123;\n    if(!mp.count(x)) mp[x] = ++cnt;\n    return mp[x];\n&#125;\nvoid solve()&#123;\n    cnt = 0;\n    mp.clear();\n\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x, y, e;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; e;\n        x = get(x), y = get(y);\n        query[i] = &#123;x, y, e&#125;;\n    &#125;\n    for(int i = 1; i &lt;= cnt; i++) p[i] = i;\n    // 合并所有相等的\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(query[i].e)&#123;\n            int pa = find(query[i].x), pb = find(query[i].y);\n            p[pa] = pb;\n        &#125;\n    &#125;\n    // 检查所有不等的\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!query[i].e)&#123;\n            int pa = find(query[i].x), pb = find(query[i].y);\n            if(pa == pb)&#123;\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n                return;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h3 id=\"银河英雄传说\"><a href=\"#银河英雄传说\" class=\"headerlink\" title=\"银河英雄传说\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQwLw==\">银河英雄传说</span></h3><ul>\n<li>让排头当根节点，维护当前战舰到排头的距离，相对距离 $|d[x] - d[y]| - 1$ 。</li>\n<li>$d[pa] &#x3D; size[pb]$, $size[pb] ; +&#x3D; ; size[pa]$</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 30010;\nint p[N], sz[N], d[N];\nint find(int x)&#123;\n    if(p[x] != x)&#123;\n        int root = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = root;\n    &#125;\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    for(int i = 1; i &lt; N; i++)&#123;\n        p[i] = i;\n        sz[i] = 1;\n    &#125;\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        char op;\n        int x, y;\n        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        if(op == &#39;M&#39;)&#123;\n            int px = find(x), py = find(y);\n            d[px] = sz[py];\n            sz[py] += sz[px];\n            p[px] = py;\n        &#125;else&#123;\n            int px = find(x), py = find(y);\n            if(px == py)&#123;\n                int ans = max(0, abs(d[x] - d[y]) - 1);\n                cout &lt;&lt; ans &lt;&lt; endl;\n            &#125;else&#123;\n                cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"奇偶游戏\"><a href=\"#奇偶游戏\" class=\"headerlink\" title=\"奇偶游戏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQxLw==\">奇偶游戏</span></h3><ul>\n<li>由数据范围知，需要使用离散化。</li>\n<li>题目条件可以转换成求前缀和，求 $S[L,R]$ 中是否有奇数个 1，可以转换成 $S_R - S_{L-1}$ 为奇数，可以再转换成判断 $S_R$ 和 $S_{L_1}$ 奇偶性不同。</li>\n</ul>\n<h4 id=\"扩展域并查集\"><a href=\"#扩展域并查集\" class=\"headerlink\" title=\"扩展域并查集\"></a>扩展域并查集</h4><ul>\n<li>是一种枚举的思路，$x$ 表示如果 $x$ 是偶数情况下，$x+n$ 表示如果 $x$ 是奇数情况下。</li>\n<li>重点是弄清楚同一个集合里的含义。一般情况是某个集合一个条件成立，则其他条件均成立。即集合里保存的是条件。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 40010, Base = N / 2;\nint cnt, p[N];\nunordered_map&lt;int, int&gt; mp;\nint getid(int x)&#123;\n    if(!mp.count(x)) mp[x] = ++cnt;\n    return mp[x];\n&#125;\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt; N; i++) p[i] = i;\n    int pos = m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int l, r;\n        string op;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;\n        l = getid(l - 1), r = getid(r);\n        if(op == &quot;even&quot;)&#123;\n            if(find(l + Base) == find(r))&#123;\n                pos = i - 1;\n                break;\n            &#125;\n            p[find(l)] = find(r);\n            p[find(l + Base)] = find(r + Base);\n        &#125;else&#123;\n            if(find(l) == find(r))&#123;\n                pos = i - 1;\n                break;\n            &#125;\n            p[find(l + Base)] = find(r);\n            p[find(l)] = find(r + Base);\n        &#125;\n    &#125;\n    cout &lt;&lt; pos &lt;&lt; endl;\n&#125;\n</code></pre>\n<h4 id=\"带边权的并查集\"><a href=\"#带边权的并查集\" class=\"headerlink\" title=\"带边权的并查集\"></a>带边权的并查集</h4><ul>\n<li>$d[x]$ 表示 $x$ 与 $p[x]$ 的关系。<ul>\n<li>$0$ 表示同类，$1$ 表示不同类</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 20010;\nint cnt, p[N], d[N];\nunordered_map&lt;int, int&gt; mp;\nint getid(int x)&#123;\n    if(!mp.count(x)) mp[x] = ++cnt;\n    return mp[x];\n&#125;\nint find(int x)&#123;\n    if(p[x] != x)&#123;\n        int root = find(p[x]);\n        d[x] ^= d[p[x]];\n        p[x] = root;\n    &#125;\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt; N; i++) p[i] = i;\n    int pos = m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int l, r;\n        string op;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;\n        l = getid(l - 1), r = getid(r);\n        int pa = find(l), pb = find(r);\n        int t = 0;\n        if(op == &quot;odd&quot;) t = 1;\n        if(pa == pb)&#123;\n            if((d[l] ^ d[r]) != t)&#123;\n                pos = i - 1;\n                break;\n            &#125;\n        &#125;else&#123;\n            p[pa] = pb;\n            d[pa] = d[l] ^ d[r] ^ t; // 构造距离\n        &#125;\n    &#125;\n    cout &lt;&lt; pos &lt;&lt; endl;\n&#125;\n</code></pre>\n<h2 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h2><ol>\n<li>快速求前缀和\t$O(logn)$</li>\n<li>修改某一个数\t$O(logn)$</li>\n</ol>\n<ul>\n<li>基于二进制思想\t$X &#x3D; 2^{i_k} + 2^{i_{k-1}} + 2^{i_{k-2}} + \\cdots + 2^{i_1}$，因此 $1 \\sim x$ 可以被分成 $k$ 段。</li>\n<li>$(X - 2^{i_1}, X], (X - 2^{i_1} - 2^{i_2}, X - 2^{i_1}] \\cdots (0, X - 2^{i_1} - 2^{i_2} \\cdots - 2^{i_k}]$</li>\n<li>$(L, R]$ 长度一定是 $R$ 的二进制表示的最后一位 $1$ 所对应的次幂，即 $[R - lowbit(R) + 1, R]$。</li>\n<li>操作<ul>\n<li>对 $a[x]$ 进行修改 <code>for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;</code></li>\n<li>查询 $a[1 \\sim x]$ 的和 <code>for(int i = x; i; i -= lowbit(i)) res += tr[i];</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"楼兰图腾\"><a href=\"#楼兰图腾\" class=\"headerlink\" title=\"楼兰图腾\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQzLw==\">楼兰图腾</span></h3><ul>\n<li>$tr[x]$ 存储的是区间 $[x - lowbit (x) + 1, x]$ 出现的数的次数，$sum$ 求的是 $1 \\sim x$ 中出现的数的个数。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 200010;\ntypedef long long LL;\nint n;\nint Greater[N], Lower[N];\nint a[N], tr[N];\nint lowbit(int x)&#123;\n    return x &amp; (-x);\n&#125;\nvoid add(int x, int v)&#123;\n    for(; x &lt;= n; x += lowbit(x)) tr[x] += v;\n&#125;\nint sum(int x)&#123;\n    int res = 0;\n    for(; x &gt; 0; x -= lowbit(x)) res += tr[x];\n    return res;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int t = a[i];\n        Greater[i] = sum(n) - sum(t);\n        Lower[i] = sum(t - 1);\n        add(t, 1);\n    &#125;\n    memset(tr, 0, sizeof(tr));\n    LL ans1 = 0, ans2 = 0;\n    for(int i = n; i; i--)&#123;\n        int t = a[i];\n        ans1 += Greater[i] * (LL)(sum(n) - sum(t));\n        ans2 += Lower[i] * (LL)(sum(t - 1));\n        add(t, 1);\n    &#125;\n    cout &lt;&lt; ans1 &lt;&lt; &#39; &#39; &lt;&lt; ans2 &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"一个简单的整数问题-Ⅰ\"><a href=\"#一个简单的整数问题-Ⅰ\" class=\"headerlink\" title=\"一个简单的整数问题 Ⅰ\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ4Lw==\">一个简单的整数问题 Ⅰ</span></h3><ul>\n<li>区间修改，单点查询，直接用差分数组建树维护单点值（前缀和）。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 200010;\nint n;\nint a[N], tr[N];\nint lowbit(int x)&#123;\n    return x &amp; (-x);\n&#125;\nvoid add(int x, int v)&#123;\n    for(; x &lt;= n; x += lowbit(x)) tr[x] += v;\n&#125;\nLL sum(int x)&#123;\n    LL res = 0;\n    for(; x &gt; 0; x -= lowbit(x)) res += tr[x];\n    return res;\n&#125;\nint main()&#123;\n    int m;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for(int i = 1; i &lt;= n; i++) add(i, a[i] - a[i - 1]);\n    while(m--)&#123;\n        char op;\n        int l, r, d;\n        cin &gt;&gt; op;\n        if(op == &#39;Q&#39;)&#123;\n            cin &gt;&gt; d;\n            cout &lt;&lt; sum(d) &lt;&lt; endl;\n        &#125;else&#123;\n            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            add(l, d); add(r + 1, -d);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"一个简单的整数问题-Ⅱ-🌸\"><a href=\"#一个简单的整数问题-Ⅱ-🌸\" class=\"headerlink\" title=\"一个简单的整数问题 Ⅱ 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ0Lw==\">一个简单的整数问题 Ⅱ</span> 🌸</h3><ul>\n<li>区间修改，区间求和</li>\n<li>要在 $O(logn)$ 的时间复杂度内对差分树状数组进行区间查询，需要额外维护一个 $i \\times b_i$ 的差分树状数组。</li>\n<li>$S_n &#x3D; (b_1 + b_2 + \\cdots + b_n) \\times (n + 1) - (1 \\times b_1 + 2 \\times b_2 + \\cdots i \\times b_i)$</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010;\nint n, m;\nint a[N];\nLL tr1[N], tr2[N];  // 维护 b[i] 和 b[i] * i 的前缀和\nint lowbit(int x)&#123;\n    return x &amp; (-x);\n&#125;\nvoid add(LL tr[], int x, LL v)&#123;\n    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;\n&#125;\nLL sum(LL tr[], int x)&#123;\n    LL res = 0;\n    for(int i = x; i; i -= lowbit(i)) res += tr[i];\n    return res;\n&#125;\nLL cal(int x)&#123;\n    return sum(tr1, x) * (x + 1) - (sum(tr2, x));\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int t = a[i] - a[i - 1];\n        add(tr1, i, t); add(tr2, i, (LL)t * i);\n    &#125;\n    while(m--)&#123;\n        char op;\n        int l, r, d;\n        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if(op == &#39;Q&#39;) cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;\n        else&#123;\n            cin &gt;&gt; d;\n            add(tr1, l, d); add(tr2, l, (LL)d * l);     // a[l] += d\n            add(tr1, r + 1, -d); add(tr2, r + 1, -(LL)d * (r + 1));     // a[r] -= d\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"谜一样的牛-🌸\"><a href=\"#谜一样的牛-🌸\" class=\"headerlink\" title=\"谜一样的牛 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ1Lw==\">谜一样的牛</span> 🌸</h3><ul>\n<li>从剩余的数中，找到第 $k$ 小的数。$\\Longleftrightarrow$ 找到一个最小的 $x$，使得 $sum (x) &#x3D; k$。</li>\n<li>删除某个数。$\\Longleftrightarrow$ $add(x, -1)$。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\nint n;\nint h[N], tr[N], ans[N];\nint lowbit(int x)&#123;\n    return x &amp; (-x);\n&#125;\nvoid add(int x, int v)&#123;\n    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;\n&#125;\nint sum(int x)&#123;\n    int res = 0;\n    for(int i = x; i; i -= lowbit(i)) res += tr[i];\n    return res;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) tr[i] = lowbit(i);\n    for(int i = 2; i &lt;= n; i++) cin &gt;&gt; h[i];\n    for(int i = n; i; i--)&#123;\n        int k = h[i] + 1;\n        int l = 1, r = n;\n        while(l &lt; r)&#123;\n            int mid = (l + r) &gt;&gt; 1;\n            if(sum(mid) &gt;= k) r = mid;\n            else l = mid + 1;\n        &#125;\n        ans[i] = l;\n        add(l, -1);\n    &#125;\n    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"CF383C-Propagating-tree\"><a href=\"#CF383C-Propagating-tree\" class=\"headerlink\" title=\"CF383C | Propagating tree\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YzODND\">CF383C | Propagating tree</span></h3><ul>\n<li>题意<ul>\n<li>树上每个节点都有一个权值，有两种操作：<ul>\n<li>给一个节点的权值增加 $val$， 它的子节点权值都增加 $-val$， 它子节点的子节点权值都增加 $-(-val)$，一直到树的底部。</li>\n<li>查询某个节点的权值。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>可以树剖结合线段树维护，我们考虑让深度为奇数的根的子树修改的时候直接加 $val$，偶数的直接减去 $val$。这样我们就消除了所加的子树根结点深度不同的问题，所以我们的懒标记就可以合并了。</li>\n<li>因为先前我们对深度不同的结点做出的调整，所以最后我们只需要在访问到每个点的时候判断一下深度的奇偶性，对应的加减就行了。</li>\n<li>不过我们也可以用树状数组维护一个差分数组 $f[n]$，表示第 $n$ 号节点的修改情况，其中如果 $depth[n]$ 是奇数则记录增加量，否则记录减少量。则题中修改就等同于在 $dfs$ 序上修改一段区间（因为这时候增减已经不影响了）。</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 2e5 + 10;\nint tr[N], l[N], r[N];\nint n, m;\ninline int lowbit(int x)&#123;\n    return x &amp; -x;\n&#125;\ninline void add(int x, int v)&#123;\n    for(; x &lt;= n; x += lowbit(x))\n        tr[x] += v;\n&#125;\ninline int sum(int x)&#123;\n    int ret = 0;\n    for(; x &gt; 0; x -= lowbit(x))\n        ret += tr[x];\n    return ret;\n&#125;\n\nint h[N], e[N &lt;&lt; 1], ne[N &lt;&lt; 1], idx;\ninline void addedge(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint depth[N], tot;\nvoid dfs(int u, int fa)&#123;\n    l[u] = ++tot;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == fa) continue;\n        depth[j] = depth[u] + 1;\n        dfs(j, u);\n    &#125;\n    r[u] = tot;\n&#125;\nint val[N];\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; val[i];\n    &#125;\n    for(int i = 1; i &lt; n; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        addedge(a, b);\n        addedge(b, a);\n    &#125;\n    dfs(1, 0);\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        if(a == 1)&#123;\n            int x;\n            cin &gt;&gt; x;\n            if(depth[b] &amp; 1) add(l[b], x), add(r[b] + 1, -x);\n            else add(l[b], -x), add(r[b] + 1, x);\n        &#125;else&#123;\n            int x = sum(l[b]);\n            if(depth[b] &amp; 1) cout &lt;&lt; val[b] + x &lt;&lt; &#39;\\n&#39;;\n            else cout &lt;&lt; val[b] - x &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h2><ul>\n<li>$pushup$<ul>\n<li>由子节点更新父节点。</li>\n<li>单点修改</li>\n</ul>\n</li>\n<li>$pushdown$ （懒标记、延迟标记）<ul>\n<li>由父节点更新子节点。</li>\n<li>区间修改</li>\n<li>例如： $add$ 懒标记，给以当前节点为根的子树中的每一个节点加上 $add$ 这个数（不包含根节点）<ul>\n<li><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></li>\n<li><code>right.add += root.add, right.sum += (right.r - right.l + 1) * root.add</code></li>\n<li><code>root.add = 0</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>除最后一层是满二叉树，子区间划分 $mid &#x3D; \\left \\lfloor \\frac{l + r}{2}  \\right \\rfloor$ 即 $[L, mid],[mid + 1, R]$，可以用一维数组存整棵树，最多由 $2n - 1 + 2n$ 个点，故需要开 4 倍的空间。</li>\n<li>扫描线法</li>\n<li>操作<ul>\n<li><code>pushup()</code></li>\n<li><code>pushdown()</code></li>\n<li><code>build()</code> 将一段区间初始化为线段树。</li>\n<li><code>modify()</code> 修改单点、修改区间（延迟更新）。</li>\n<li><code>query()</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">build(int u, int l, int r)&#123;\n    tr[u].l = l, tr[u].r = r;\n    if(l == r) return;\n    int mid = l + r &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u); // 一般于此写 pushup 操作\n&#125;\n</code></pre>\n<h3 id=\"动态开点线段树\"><a href=\"#动态开点线段树\" class=\"headerlink\" title=\"动态开点线段树\"></a>动态开点线段树</h3><ul>\n<li>通常来说，线段树占用空间是总区间长 $n$ 的常数倍，空间复杂度是 $O(n)$。然而，有时候 $n$ 很巨大，而我们又不需要使用所有的节点，这时便可以动态开点——不再一次性建好树，而是一边修改、查询一边建立。设总查询次数为 $m$，则这样的总空间复杂度为 $O(m;log;n)$。</li>\n<li>比起普通线段树，动态开点线段树有一个优势，它能够处理零或负数位置。此时，求 $mid$ 时不能用 $(cl + cr) &#x2F; 2$，而要用 $(cl + cr - 1) &#x2F; 2$。</li>\n<li>通常用在没有提供初始数据的场合（例如初始全0），这时更能显示出优势。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n#define ls(x) tr[x].ls\n#define rs(x) tr[x].rs\n#define val(x) tr[x].val\n#define mark(x) tr[x].mark\n// N 一般能开多大开多大，例如内存限制 128M 时可以开到八百万左右\nconst int N = 8e6;\nint L = 1, R = 1e5, cnt = 1;\nstruct Node&#123;\n    int ls, rs;\n    LL val, mark;\n&#125;tr[N];\nvoid push_down(int p, int len)&#123;\n    if(len &lt;= 1) return;\n    if(!ls(p)) ls(p) = ++cnt;\n    if(!rs(p)) rs(p) = ++cnt;\n    val(ls(p)) += mark(p) * (len / 2);\n    mark(ls(p)) += mark(p);\n    val(rs(p)) += mark(p) * (len - len / 2);\n    mark(rs(p)) += mark(p);\n    mark(p) = 0;\n&#125;\nLL query(int u, int l, int r, int cl = L, int cr = R)&#123;\n    if(cl &gt;= l &amp;&amp; cr &lt;= r) return val(u);\n    push_down(u, cr - cl + 1);\n    LL mid = (cl + cr - 1) / 2, ans = 0;\n    if(l &lt;= mid) ans += query(ls(u), l, r, cl, mid);\n    if(r &gt; mid) ans += query(rs(u), l, r, mid + 1, cr);\n    return ans;\n&#125;\nvoid update(int l, int r, int d, int u = 1, int cl = L, int cr = R)&#123;\n    if(cl &gt;= l &amp;&amp; cr &lt;= r)&#123;\n        val(u) += d * (cr - cl + 1);\n        mark(u) += d;\n        return;\n    &#125;\n    push_down(u, cr - cl + 1);\n    LL mid = (cl + cr - 1) / 2;\n    if(l &lt;= mid) update(l, r, d, ls(u), cl, mid);\n    if(r &gt; mid) update(l, r, d, rs(u), mid + 1, cr);\n    val(u) = val(ls(u)) + val(rs(u));\n&#125;\n</code></pre>\n<h4 id=\"CF431E-Chemistry-Experiment\"><a href=\"#CF431E-Chemistry-Experiment\" class=\"headerlink\" title=\"CF431E | # Chemistry Experiment\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y0MzFF\">CF431E | # Chemistry Experiment</span></h4><ul>\n<li>题目中第二种操作需要将 $v$ 体积的水任意分配到 $n$ 支试管里，最小化有水的试管中的最大体积，输出这个最小值，该操作不会造成影响。</li>\n<li>最小化最大值，考虑二分答案，因为只能往小于等于 $mid$ 的试管里面灌，也就是说我们要统计出所有高度小于等于 $mid$ 的试管的数量 $num$，同时也要统计这些试管里面水银的体积 $sum$。如果 $num \\times mid - sum \\ge v$ 这个 $mid$ 就是可行的（自行画图体会）。</li>\n<li>又由于没有区间限制，而且 mid 值不确定，果断上权值线段树 + 动态开点。</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int INF = 1e9;\nconst int N = 1e5 + 10;\nconst double eps = 1e-5;\n#define ls(x) tr[x].ls\n#define rs(x) tr[x].rs\n#define val(x) tr[x].val\n#define sum(x) tr[x].sum\n#define sz(x) tr[x].sz\nstruct Node&#123;\n    int ls, rs;\n    LL sz, sum;\n&#125;tr[N &lt;&lt; 6];\nint idx, root;\nint w[N];\nint n, q, m = 1e9 + 10;\nvoid pushup(Node&amp; u, Node&amp; l, Node&amp; r)&#123;\n    u.sz = l.sz + r.sz;\n    u.sum = l.sum + r.sum;\n&#125;\nvoid modify(int&amp; u, int l, int r, int x, int v)&#123;\n    if(!u) u = ++idx;\n    tr[u].sz += v, tr[u].sum += x * v;\n    if(l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    if(x &lt;= mid) modify(ls(u), l, mid, x, v);\n    else modify(rs(u), mid + 1, r, x, v);\n&#125;\nNode query(int u, int l, int r, int ql, int qr)&#123;\n    if(!u) return &#123;0, 0, 0, 0&#125;;\n    if(ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u];\n    int mid = (l + r) &gt;&gt; 1;\n    if(qr &lt;= mid) return query(ls(u), l, mid, ql, qr);\n    if(ql &gt; mid) return query(rs(u), mid + 1, r, ql, qr);\n    Node res, left = query(ls(u), l, mid, ql, qr), right = query(rs(u), mid + 1, r, ql, qr);\n    pushup(res, left, right);\n    return res;\n&#125;\n\nbool check(double mid, LL v)&#123;\n    LL up = floor(mid);\n    if(up &gt; m) up = m;\n    Node ans = query(root, 0, m, 0, up);\n    double remain = 1.0 * ans.sz * mid - ans.sum - v;\n    return remain &gt;= eps;\n&#125;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cout &lt;&lt; fixed &lt;&lt; setprecision(5);\n    cin &gt;&gt; n &gt;&gt; q;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; w[i];\n        modify(root, 0, m, w[i], 1);\n    &#125;\n    while(q--)&#123;\n        int op;\n        LL a, b;\n        cin &gt;&gt; op;\n        if(op == 1)&#123;\n            cin &gt;&gt; a &gt;&gt; b;\n            modify(root, 0, m, w[a], -1);\n            w[a] = b;\n            modify(root, 0, m, w[a], 1);\n        &#125;else&#123;\n            cin &gt;&gt; a;\n            double l = 0, r = 1e15;\n            while(r - l &gt; eps)&#123;\n                double mid = (l + r) / 2;\n                if(check(mid, a)) r = mid;\n                else l = mid;\n            &#125;\n            cout &lt;&lt; l &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"最大数-🌸\"><a href=\"#最大数-🌸\" class=\"headerlink\" title=\"最大数 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI3Ny8=\">最大数</span> 🌸</h3><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 200010;\nint m, p;\nstruct Node\n&#123;\n    int l, r;\n    int v;      // 区间[l, r]中的最大值\n&#125;tr[N * 4];\n\nvoid pushup(int u)&#123;     // 由子节点的信息，更新父节点的信息\n    tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);\n&#125;\nvoid build(int u, int l, int r)&#123;\n    tr[u] = &#123;l, r&#125;;\n    if(l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\nint query(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].v;    // 区间[l, r]在当前节点的区间内\n    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n    int v = 0;\n    if(l &lt;= mid) v = query(u &lt;&lt; 1, l, r);\n    if(r &gt; mid) v = max(v, query(u &lt;&lt; 1 | 1, l, r));\n    return v;\n&#125;\nvoid modify(int u, int x, int v)&#123;\n    if(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;\n    else&#123;\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(x &lt;= mid) modify(u &lt;&lt; 1, x, v);\n        else modify(u &lt;&lt; 1 | 1, x, v);\n        pushup(u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n = 0, last = 0;\n    cin &gt;&gt; m &gt;&gt; p;\n    build(1, 1, m);\n    int x;\n    while(m--)&#123;\n        char op;\n        cin &gt;&gt; op &gt;&gt; x;\n        if(op == &#39;Q&#39;)&#123;\n            last = query(1, n - x + 1, n);\n            cout &lt;&lt; last &lt;&lt; endl;\n        &#125;else&#123;\n            modify(1, n + 1, ((long long)last + x) % p);\n            n++;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"你能回答这些问题吗-🌸\"><a href=\"#你能回答这些问题吗-🌸\" class=\"headerlink\" title=\"你能回答这些问题吗 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ2Lw==\">你能回答这些问题吗</span> 🌸</h3><ul>\n<li>维护每个区间后缀最大和，前缀最大和，区间和，区间最大子段和。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 500010;\nint n, m;\nint w[N];\nstruct Node\n&#123;\n    int l, r;\n    int sum, lmax, rmax, tmax;\n&#125;tr[N * 4];\nvoid pushup(Node &amp;u, Node &amp;l, Node &amp;r)&#123;\n    u.sum = l.sum + r.sum;\n    u.lmax = max(l.lmax, l.sum + r.lmax);\n    u.rmax = max(r.rmax, r.sum + l.rmax);\n    u.tmax = max(max(l.tmax, r.tmax), l.rmax + r.lmax);\n&#125;\nvoid pushup(int u)&#123;\n    pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);\n&#125;\nvoid build(int u, int l, int r)&#123;\n    if(l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;\n    else&#123;\n        tr[u] = &#123;l, r&#125;;\n        int mid = (l + r) &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\nvoid modify(int u, int x, int v)&#123;\n    if(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;\n    else&#123;\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(x &lt;= mid) modify(u &lt;&lt; 1, x, v);\n        else modify(u &lt;&lt; 1 | 1, x, v);\n        pushup(u);\n    &#125;\n&#125;\nNode query(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u];\n    else&#123;\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(r &lt;= mid) return query(u &lt;&lt; 1, l, r);\n        else if(l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r);\n        else&#123;\n            auto left = query(u &lt;&lt; 1, l, r);\n            auto right = query(u &lt;&lt; 1 | 1, l, r);\n            Node res;\n            pushup(res, left, right);\n            return res;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    build(1, 1, n);\n    int x, y;\n    while(m--)&#123;\n        int op;\n        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        if(op == 1)&#123;\n            if(x &gt; y) swap(x, y);\n            cout &lt;&lt; query(1, x, y).tmax &lt;&lt; endl;\n        &#125;else&#123;\n            modify(1, x, y);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"区间最大公约数-🌸\"><a href=\"#区间最大公约数-🌸\" class=\"headerlink\" title=\"区间最大公约数 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ3Lw==\">区间最大公约数</span> 🌸</h3><ul>\n<li>最大公约数<ul>\n<li>一定存在 $(x, y, z) ; &#x3D; ; (x, y - x, z - y)$</li>\n<li>用线段树维护所有差分的值。单点修改，区间查询。</li>\n<li>$gcd(a[l], gcd(b[l + 1], b[l + 2], \\cdots b[r]))$</li>\n</ul>\n</li>\n<li>区间 $[l, r]$ 增加一个数<ul>\n<li>差分思想，将区间加减变成单点加减。</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzEwNDcv\">详细题解</span></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 500010;\nint n, m;\nLL w[N];\nstruct Node&#123;\n    int l, r;\n    LL sum, d;\n&#125;tr[N * 4];\nLL gcd(LL a, LL b)&#123;\n    return b == 0 ? a : gcd(b, a % b);\n&#125;\nvoid pushup(Node &amp;u, Node &amp;l, Node &amp;r)&#123;\n    u.sum = l.sum + r.sum;\n    u.d = gcd(l.d, r.d);\n&#125;\nvoid pushup(int u)&#123;\n    pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);\n&#125;\nvoid build(int u, int l, int r)&#123;\n    if(l == r)&#123;\n        LL b = w[r] - w[r - 1];\n        tr[u] = &#123;l, r, b, b&#125;;\n    &#125;else&#123;\n        tr[u] = &#123;l, r&#125;;\n        int mid = (l + r) &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\nvoid modify(int u, int x, LL v)&#123;\n    if(tr[u].l == x &amp;&amp; tr[u].r == x)&#123;\n        LL b = tr[u].sum + v;\n        tr[u] = &#123;x, x, b, b&#125;;\n    &#125;else&#123;\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(x &lt;= mid) modify(u &lt;&lt; 1, x, v);\n        else modify(u &lt;&lt; 1 | 1, x, v);\n        pushup(u);\n    &#125;\n&#125;\nNode query(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u];\n    else&#123;\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(r &lt;= mid) return query(u &lt;&lt; 1, l, r);\n        else if(l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r);\n        else&#123;\n            auto left = query(u &lt;&lt; 1, l, r);\n            auto right = query(u &lt;&lt; 1 | 1, l, r);\n            Node res;\n            pushup(res, left, right);\n            return res;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    build(1, 1, n);\n    \n    int l, r;\n    LL d;\n    char op;\n    while(m--)&#123;\n        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if(op == &#39;Q&#39;)&#123;\n            auto left  = query(1, 1, l);\n            Node right(&#123;0, 0, 0, 0&#125;);\n            if(l + 1 &lt;= r) right = query(1, l + 1, r);\n            cout &lt;&lt; abs(gcd(left.sum, right.d)) &lt;&lt; endl;    // 需要正数\n        &#125;else&#123;\n            cin &gt;&gt; d;\n            modify(1, l, d);\n            if(r + 1 &lt;= n) modify(1, r + 1, -d);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"一个简单的整数问题-Ⅱ-🌸-1\"><a href=\"#一个简单的整数问题-Ⅱ-🌸-1\" class=\"headerlink\" title=\"一个简单的整数问题 Ⅱ 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ0Lw==\">一个简单的整数问题 Ⅱ</span> 🌸</h3><ul>\n<li>信息<ul>\n<li>$sum$ 如果考虑当前节点及子节点上的所有标记，当前区间和是多少。</li>\n<li>$add$ 懒标记，给以当前节点为根的子树中的每一个节点加上 $add$ 这个数（不包含根节点）<ul>\n<li><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></li>\n<li><code>right.add += root.add, right.sum += (right.r - right.l + 1) * root.add</code></li>\n<li><code>root.add = 0</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010;\nint n, m;\nint w[N];\nstruct Node&#123;\n    int l, r;\n    LL sum, add;\n&#125;tr[N * 4];\nvoid pushup(int u)&#123;\n    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;\n&#125;\nvoid pushdown(int u)&#123;\n    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];\n    if(root.add)&#123;\n        left.add += root.add, left.sum += (LL)(left.r - left.l + 1) * root.add;\n        right.add += root.add, right.sum += (LL)(right.r - right.l + 1) * root.add;\n        root.add = 0;\n    &#125;\n&#125;\nvoid build(int u, int l, int r)&#123;\n    if(l == r) tr[u] = &#123;l, r, w[l], 0&#125;;\n    else&#123;\n        tr[u] = &#123;l, r&#125;;\n        int mid = (l + r) &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\nvoid modify(int u, int l, int r, int d)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;\n        tr[u].sum += (LL)(tr[u].r - tr[u].l + 1) * d;\n        tr[u].add += d;\n    &#125;else&#123;      // 分裂\n        pushdown(u);\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, d);\n        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d);\n        pushup(u);\n    &#125;\n&#125;\nLL query(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;\n    pushdown(u);\n    int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n    LL sum = 0;\n    if(l &lt;= mid) sum = query(u &lt;&lt; 1, l, r);\n    if(r &gt; mid) sum += query(u &lt;&lt; 1 | 1, l, r);\n    return sum;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    build(1, 1, n);\n    char op;\n    int l, r, d;\n    while(m--)&#123;\n        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if(op == &#39;C&#39;)&#123;\n            cin &gt;&gt; d;\n            modify(1, l, r, d);\n        &#125;else&#123;\n            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"亚特兰蒂斯-🌸🌸\"><a href=\"#亚特兰蒂斯-🌸🌸\" class=\"headerlink\" title=\"亚特兰蒂斯 🌸🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjQ5Lw==\">亚特兰蒂斯</span> 🌸🌸</h3><ul>\n<li>在 $y$ 轴建立线段树，每一个矩形的左边权值为 $1$，右边权值为 $-1$ </li>\n<li>线段树中的节点信息<ul>\n<li>$cnt$ 当前区间整个被覆盖次数</li>\n<li>$len$ 不考虑祖先节点 $cnt$ 的前提下，$cnt &gt; 0$ 的区间总长。</li>\n</ul>\n</li>\n<li>本题考虑扫描线的特殊性质<ul>\n<li>永远只考虑根节点的信息，即 <code>query</code> 时不会调用 <code>pushdown</code></li>\n<li>所有操作都是成对出现，且先加后减</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\nstruct Segment&#123;\n    double x, y1, y2;\n    int k;\n    bool operator &lt; (const Segment &amp;t) const&#123;\n        return x &lt; t.x;\n    &#125;\n&#125;seg[N * 2];\nstruct Node&#123;\n    int l, r;\n    int cnt;\n    double len;\n&#125;tr[N * 8];\nvector&lt;double&gt; origin;\n\nint find(double y)&#123;\n    return lower_bound(origin.begin(), origin.end(), y) - origin.begin();\n&#125;\nvoid pushup(int u)&#123;\n    if(tr[u].cnt) tr[u].len = origin[tr[u].r + 1] - origin[tr[u].l];\n    else if(tr[u].l != tr[u].r) tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len;\n    else tr[u].len = 0;\n&#125;\nvoid build(int u, int l, int r)&#123;\n    tr[u] = &#123;l, r, 0, 0&#125;;\n    if(l != r)&#123;\n        int mid = (l + r) &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r);\n    &#125;\n&#125;\nvoid modify(int u, int l, int r, int k)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;\n        tr[u].cnt += k;\n        pushup(u);\n    &#125;else&#123;\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, k);\n        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k);\n        pushup(u);\n    &#125;\n&#125;\nvoid solve(int n)&#123;\n    origin.clear();\n    for(int i = 0, j = 0; i &lt; n; i++)&#123;\n        double x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        seg[j++] = &#123;x1, y1, y2, 1&#125;;\n        seg[j++] = &#123;x2, y1, y2, -1&#125;;\n        origin.push_back(y1), origin.push_back(y2);\n    &#125;\n    sort(origin.begin(), origin.end());\n    origin.erase(unique(origin.begin(), origin.end()), origin.end());\n    build(1, 0, origin.size() - 2);\n    sort(seg, seg + n * 2);\n    double ans = 0;\n    for(int i = 0; i &lt; n * 2; i++)&#123;\n        if (i &gt; 0) ans += tr[1]. len * (seg[i]. x - seg[i - 1]. x);\n        modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k);\n    &#125;\n    cout &lt;&lt; &quot;Total explored area: &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; endl;\n    cout &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t = 1, n;\n    while(cin &gt;&gt; n &amp;&amp; n)&#123;\n        cout &lt;&lt; &quot;Test case #&quot; &lt;&lt; t++ &lt;&lt; endl;\n        solve(n);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"维护序列-🌸\"><a href=\"#维护序列-🌸\" class=\"headerlink\" title=\"维护序列 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI3OS8=\">维护序列</span> 🌸</h3><ul>\n<li>先乘后加</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010;\nint n, p, m;\nint w[N];\nstruct Node&#123;\n    int l, r;\n    int sum, add, mul;\n&#125;tr[N * 4];\n\nvoid pushup(int u)&#123;\n    tr[u].sum = (tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum) % p;\n&#125;\nvoid eval(Node &amp;t, int add, int mul)&#123;\n    t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + 1) * add) % p;\n    t.mul = ((LL)t.mul * mul) % p;\n    t.add = ((LL)t.add * mul + add) % p;\n&#125;\nvoid pushdown(int u)&#123;\n    eval(tr[u &lt;&lt; 1], tr[u].add, tr[u].mul);\n    eval(tr[u &lt;&lt; 1 | 1], tr[u].add, tr[u].mul);\n    tr[u].add = 0, tr[u].mul = 1;\n&#125;\nvoid build(int u, int l, int r)&#123;\n    if(l == r) tr[u] = &#123;l, r, w[r], 0, 1&#125;;\n    else&#123;\n        tr[u] = &#123;l, r, 0, 0, 1&#125;;\n        int mid = (l + r) &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\nvoid modify(int u, int l, int r, int add, int mul)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) eval(tr[u], add, mul);\n    else&#123;\n        pushdown(u);\n        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n        if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, add, mul);\n        if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, add, mul);\n        pushup(u);\n    &#125;\n&#125;\nint query(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;\n    pushdown(u);\n    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n    int sum = 0;\n    if(l &lt;= mid) sum = query(u &lt;&lt; 1, l, r);\n    if(r &gt; mid) sum = (sum + query(u &lt;&lt; 1 | 1, l, r)) % p;\n    return sum;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; p;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    build(1, 1, n);\n\n    cin &gt;&gt; m;\n    while(m--)&#123;\n        int t, l, r, d;\n        cin &gt;&gt; t &gt;&gt; l &gt;&gt; r;\n        if(t == 1)&#123;\n            cin &gt;&gt; d;\n            modify(1, l, r, 0, d);\n        &#125;else if(t == 2)&#123;\n            cin &gt;&gt; d;\n            modify(1, l, r, d, 1);\n        &#125;else&#123;\n            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"可持久化数据结构\"><a href=\"#可持久化数据结构\" class=\"headerlink\" title=\"可持久化数据结构\"></a>可持久化数据结构</h2><ul>\n<li>$trie$ 的可持久化</li>\n<li>线段树的可持久化–主席树</li>\n<li>可持久化的<strong>前提</strong>是本身的拓扑结构不变</li>\n<li>解决什么样的问题？<ul>\n<li>可以存下来数据结构的所有历史版本</li>\n<li>核心思想<ul>\n<li>只记录每个版本与前一个版本不同的地方</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最大异或和-🌸🌸🌸\"><a href=\"#最大异或和-🌸🌸🌸\" class=\"headerlink\" title=\"最大异或和 🌸🌸🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI3OS8=\">最大异或和</span> 🌸🌸🌸</h3><ul>\n<li>可持久化 $trie$ 树</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzQ2NTM0Lw==\">详细题解</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUxNDE5Lw==\">代码详解</span></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 600010, M = N * 25;\nint n, m;\nint s[N];\nint tr[M][2];\nint max_id[M];\nint root[N], idx;\n// i是第i个插入的数的i, p是上一个插入的数的节点号, q是当前节点号, k是现在取到第k位\nvoid insert(int i, int k, int p, int q)&#123;\n    if(k &lt; 0)&#123;\n        max_id[q] = i;  // 记录当前节点(可能会被后面公用)所能到达的最大范围i\n        return;\n    &#125;\n    int v = s[i] &gt;&gt; k &amp; 1;\n    if(p) tr[q][v ^ 1] = tr[p][v ^ 1];  // 相当于复制\n    tr[q][v] = ++idx;\n    insert(i, k - 1, tr[p][v], tr[q][v]);\n    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);\n&#125;\nint query(int r, int C, int L)&#123;\n    int p = r;\n    for(int i = 23; i &gt;= 0; i--)&#123;\n        int v = C &gt;&gt; i &amp; 1;\n        if(max_id[tr[p][v ^ 1]] &gt;= L) p = tr[p][v ^ 1];\n        else p = tr[p][v];\n    &#125;\n    return C ^ s[max_id[p]];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    max_id[0] = -1;\n    root[0] = ++idx;\n    insert(0, 23, 0, root[0]);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        s[i] = s[i - 1] ^ x;\n        root[i] = ++idx;\n        insert(i, 23, root[i - 1], root[i]);\n    &#125;\n    char op;\n    int l, r, x;\n    while(m--)&#123;\n        cin &gt;&gt; op;\n        if(op == &#39;A&#39;)&#123;\n            cin &gt;&gt; x;\n            n++;\n            s[n] = s[n - 1] ^ x;\n            root[n] = ++idx;\n            insert(n, 23, root[n - 1], root[n]);\n        &#125;else&#123;\n            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;\n            cout &lt;&lt; query(root[r - 1], x ^ s[n], l - 1) &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"第k小数-🌸🌸🌸\"><a href=\"#第k小数-🌸🌸🌸\" class=\"headerlink\" title=\"第k小数 🌸🌸🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU3Lw==\">第k小数</span> 🌸🌸🌸</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUxNDU2Lw==\">题解</span></li>\n<li>可持久化线段树<ul>\n<li>难以进行区间修改操作</li>\n</ul>\n</li>\n<li>离散化</li>\n<li>在数值上建立线段树，维护每个数值区间中一共有多少个数</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010, M = 10010;\nint n, m;\nint a[N];\nvector&lt;int&gt; nums;\nstruct Node&#123;\n    int l, r;\n    int cnt;\n&#125;tr[N * 4 + N * 17];\nint root[N], idx;\n\nint find(int x)&#123;\n    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();\n&#125;\nint build(int l, int r)&#123;\n    int p = ++idx;\n    if(l == r) return p;\n    int mid = l + r &gt;&gt; 1;\n    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);\n    return p;\n&#125;\nint insert(int p, int l, int r, int x)&#123;\n    int q = ++idx;\n    tr[q] = tr[p];\n    if(l == r)&#123;\n        tr[q].cnt++;\n        return q;\n    &#125;\n    int mid = l + r &gt;&gt; 1;\n    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x);\n    else tr[q].r = insert(tr[p].r, mid + 1, r, x);\n    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;\n    return q;\n&#125;\nint query(int q, int p, int l, int r, int k)&#123;\n    if(l == r) return r;\n    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;\n    int mid = l + r &gt;&gt; 1;\n    if(k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k);\n    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; a[i];\n        nums.push_back(a[i]);\n    &#125;\n    sort(nums.begin(), nums.end());\n    nums.resize(unique(nums.begin(), nums.end()) - nums.begin());\n    root[0] = build(0, nums.size() - 1);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));\n    &#125;\n    while(m--)&#123;\n        int l, r, k;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n        cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"可持久化线段树模板\"><a href=\"#可持久化线段树模板\" class=\"headerlink\" title=\"可持久化线段树模板\"></a>可持久化线段树模板</h3><ul>\n<li>例题：区间 k 个数最大和</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 200010, M = 20010;\nint n, m, k, x;\nint a[N];\nvector&lt;int&gt; nums;\nstruct Node&#123;\n    int l, r, cnt;\n    LL sum, val;        // cnt 记录出现次数，sum 记录和，val 记录值\n&#125;tr[N * 40];\nint root[N], idx;\n\nint find(int x)&#123;\n    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();\n&#125;\nint build(int l, int r)&#123;\n    int p = ++idx;\n    if(l == r) return p;\n    int mid = l + r &gt;&gt; 1;\n    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);\n    return p;\n&#125;\nint insert(int p, int l, int r, int x, int val)&#123;\n    int q = ++idx;\n    tr[q] = tr[p];\n    tr[q].cnt++, tr[q].sum += val;\n    if(l == r)&#123;\n        tr[q].val = val;\n        return q;\n    &#125;\n    int mid = l + r &gt;&gt; 1;\n    if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x, val);\n    else tr[q].r = insert(tr[p].r, mid + 1, r, x, val);\n    return q;\n&#125;\n// 查询前 k 大值，因为节点存的是值，所以找大的，先从右边找。\nLL query(int q, int p, int l, int r, int k)&#123;\n    if(l == r) return tr[q].val * k;    // 因为一个值可能出现多次，那么计算答案的时候要把他们都算上\n    int cnt = tr[tr[q].r].cnt - tr[tr[p].r].cnt;\n    int mid = l + r &gt;&gt; 1;\n    if(k &lt;= cnt) return query(tr[q].r, tr[p].r, mid + 1, r, k);\n    else return query(tr[q].l, tr[p].l, l, mid, k - cnt) + tr[tr[q].r].sum - tr[tr[p].r].sum;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; a[i];\n        nums.push_back(a[i]);\n    &#125;\n    for(int i = 1; i &lt; nums.size(); i++)&#123;\n        nums[i] += nums[i - 1];\n    &#125;\n/*     sort(nums.begin(), nums.end());\n    nums.resize(unique(nums.begin(), nums.end()) - nums.begin()); */\n    root[0] = build(0, nums.size() - 1);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]), a[i]);\n    &#125;\n    while(m--)&#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        if(nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &gt;= x)&#123;\n            cout &lt;&lt; &quot;Y\\n&quot;;\n        &#125;else&#123;\n            cout &lt;&lt; &quot;N\\n&quot;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"动态开点可持久化线段树\"><a href=\"#动态开点可持久化线段树\" class=\"headerlink\" title=\"动态开点可持久化线段树\"></a>动态开点可持久化线段树</h3><ul>\n<li>例题为 区间第 k 小</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10, INF = 1e9;\nstruct Node&#123;\n    int l, r;\n    int cnt;\n&#125;tr[N &lt;&lt; 5];\nint n, m, idx , root[N], a[N];\n\nvoid insert(int &amp;u, int v, int l, int r, int x)&#123;\n    u = ++ idx;\n    tr[u] = tr[v];\n    tr[u].cnt ++ ;\n    if(l == r) return ;\n    int mid = l + r &gt;&gt; 1;\n    if(x &lt;= mid) insert(tr[u].l, tr[v].l, l, mid, x);\n    else insert(tr[u].r, tr[v].r, mid + 1, r, x);\n&#125;\n\nint query(int p, int q, int l, int r, int k)&#123;\n    if(l == r) return l;\n    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;\n    int mid = l + r &gt;&gt; 1;\n    if(k &lt;= cnt) return query(tr[p].l, tr[q].l, l, mid, k);\n    if(k &gt; cnt) return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);\n&#125;\n\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1 ; i &lt;= n ; i ++ )&#123;\n        cin &gt;&gt; a[i];\n        insert(root[i], root[i - 1], -INF, INF, a[i]);\n    &#125;\n    for(int i = 1 ; i &lt;= m ; i ++ )&#123;\n        int l, r, k;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n        cout &lt;&lt; query(root[l - 1], root[r], -INF, INF, k) &lt;&lt; endl;\n    &#125;\n    \n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"Treap-平衡树\"><a href=\"#Treap-平衡树\" class=\"headerlink\" title=\"Treap - 平衡树\"></a>Treap - 平衡树</h2><ul>\n<li>Binary Search Tree + heap<ul>\n<li>BST，当前节点的左子树中的任何一个点的权值小于当前节点的权值；当前节点的右子树中的任何一个点的权值大于当前节点的权值<ul>\n<li>动态维护有序序列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>支持插入、删除、找前驱&#x2F;后继、最大&#x2F;最小、求某个值的排名、求排名是 $k$ 的数是哪个、比某个数小的最大值、比某个数大的最小值</li>\n</ul>\n<h3 id=\"AcWing-普通平衡树\"><a href=\"#AcWing-普通平衡树\" class=\"headerlink\" title=\"AcWing|普通平衡树\"></a><a href=\"\">AcWing|普通平衡树</a></h3><ul>\n<li>模板</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nstruct Node&#123;\n    int l, r;\n    int key;    // 二叉搜索树权值\n    int val;    // 大根堆的随机权值\n    int cnt, sz;\n&#125;tr[N];\n\n// Treap 在以关键码构成二叉搜索树的同时, 还满足堆的性质, 且堆的权重随机, 这使得 Treap 的期望复杂度是 log n\n\nint root, idx, n;\n// 更新父节点 sz 信息\nvoid pushup(int p)&#123;\n    tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz + tr[p].cnt;\n&#125;\n// 创建一个叶节点\nint get_node(int key)&#123;\n    tr[++idx].key = key;\n    tr[idx].val = rand();\n    tr[idx].cnt = tr[idx].sz = 1;\n    return idx;\n&#125;\n//初始化平衡树 左右哨兵 \n//如果查询的结果可能不存在，那加上哨兵之后可以保证查询的结果一定存在，就不需要在查询过程中特判无解\nvoid build()&#123;\n    get_node(-INF), get_node(INF);\n    root = 1, tr[1].r = 2;\n    pushup(root);\n&#125;\n// 右旋\nvoid zig(int &amp;p)&#123;\n    // 根变了, 传引用\n    // 旋转的时候传 root, root 会变化,我们希望 root 还是真正的 root, 故用 root\n    // p 始终指向根\n    int q = tr[p].l;\n    tr[p].l = tr[q].r;\n    tr[q].r = p;\n    p = q;\n    pushup(tr[p].r);\n    pushup(p);\n    // 不需要更新 p 是因为看着右旋图, 右旋之前 y 左是 A + B , y 右是 C, 旋过之后实际上 y 左是 A, y 右是 B + C,\n    // 但是不更新 p,由于有 tr[q].r = p, 相当于 y 的 size 由左侧的 A + B 和右侧的 C 构成, 不影响最终 size\n    // 但是 p 的 r 要更新, 因为 r 由 B 和 C 构成( r 旋前只有 C )\n&#125;\n// 左旋\nvoid zag(int &amp;p)&#123;\n    int q = tr[p].r;\n    tr[p].r = tr[q].l;\n    tr[q].l = p;\n    p = q;\n    pushup(tr[p].l);\n    pushup(p);\n&#125;\n// 插入值 key, 从根开始\nvoid insert(int &amp;p, int key)&#123;   // p 是每一层根节点的指针\n    if(!p) p = get_node(key);\n    else if(tr[p].key == key) tr[p].cnt++;\n    else if(tr[p].key &gt; key)&#123;\n        // 当前节点值大于 key, 说明应该在左子树插入\n        insert(tr[p].l, key);\n        // 由于在左子树插入, 插入左侧后左子树 val 可能大于根节点, 左大右旋, 保证堆的性质\n        if(tr[tr[p].l].val &gt; tr[p].val) zig(p);\n    &#125;else&#123;\n        insert(tr[p].r, key);\n        if(tr[tr[p].r].val &gt; tr[p].val) zag(p);\n    &#125;\n    pushup(p);  // p 是每一层的根的指针, 自底向上更新 p   \n&#125;\nvoid remove(int &amp;p, int key)&#123;\n    if(!p) return ;\n    if(tr[p].key == key)&#123;\n        if(tr[p].cnt &gt; 1) tr[p].cnt--;\n        else if(tr[p].l || tr[p].r)&#123;\n            // 当前节点只有一个可以且有左儿子或右儿子\n            if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)&#123;\n                // 只存在左儿子(左 val &gt; 右 val_0) 或左 val &gt; 右 val \n                zig(p);\n                remove(tr[p].r, key);\n            &#125;else&#123;\n                // 若存在右儿子且左val&lt;右val \n                // 左儿子也可能不存在, 不存在的话左儿子的 val 就是 0 , 肯定 &lt;= 右儿子的 val ( val 最小为 0 ), 这个模板隐含了判存在操作\n                zag(p);\n                remove(tr[p].l, key);\n            &#125;\n        &#125;else&#123;\n            // 不存在左右子树,是叶子节点\n            p = 0;\n        &#125;\n    &#125;else if(tr[p].key &gt; key) remove(tr[p].l, key);\n    else remove(tr[p].r, key);\n    pushup(p);\n&#125;\n// 没有修改,不需要引用\n// 通过数值找排名\nint get_rank_by_key(int p, int key)&#123;\n    if(!p) return 0;\n    if(tr[p].key == key) return tr[tr[p].l].sz + 1; //左子树的 size + 1 (同样的数值中最靠左的)\n    if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key);\n    return tr[tr[p].l].sz + tr[p].cnt + get_rank_by_key(tr[p].r, key); // 去右边找的时候找的是在右子树中的排名, 需要加上左子树和根的 cnt\n&#125;\n// 通过排名找数值\nint get_key_by_rank(int p, int rank)&#123;\n    if(!p) return INF;\n    if(tr[tr[p].l].sz &gt;= rank) return get_key_by_rank(tr[p].l, rank); // 左边的个数 &gt;=rank, 说明数值在左边\n    if(tr[tr[p].l].sz + tr[p].cnt &gt;= rank) return tr[p].key;\n    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].sz - tr[p].cnt); // 去右子树中找数值, 排名应该先减去左子树 size + cnt\n&#125;\n// 找到严格小于key的最大数\nint get_prev(int p, int key)&#123;\n    if(!p) return -INF;\n    if(tr[p].key &gt;= key) return get_prev(tr[p].l, key); // 当前大于 key, 右子树不考虑\n    return max(tr[p].key, get_prev(tr[p].r, key));  // 左子树都小于 key 所以不如 key 更好, 所以考虑当前 key 和右子树\n\n&#125;\n// 找到严格大于key的最小数\nint get_next(int p, int key)&#123;\n    if(!p) return INF;\n    if(tr[p].key &lt;= key)return get_next(tr[p].r, key); // 当前小于key, 左子树不考虑\n    return min(tr[p].key, get_next(tr[p].l, key)); // 右子树都大于 key 所以不如 key 更好, 所以考虑当前 key 和左子树\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    build();\n    int n;\n    cin &gt;&gt; n;\n    while(n--)&#123;\n        int op, x;\n        cin &gt;&gt; op &gt;&gt; x;\n        if(op == 1) insert(root, x);\n        else if(op == 2) remove(root, x);\n        else if(op == 3) cout &lt;&lt; get_rank_by_key(root, x) - 1 &lt;&lt; &#39;\\n&#39;;\n        else if(op == 4) cout &lt;&lt; get_key_by_rank(root, x + 1) &lt;&lt; &#39;\\n&#39;;\n        else if(op == 5) cout &lt;&lt; get_prev(root, x) &lt;&lt; &#39;\\n&#39;;\n        else cout &lt;&lt; get_next(root, x) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Splay-平衡树\"><a href=\"#Splay-平衡树\" class=\"headerlink\" title=\"Splay 平衡树\"></a>Splay 平衡树</h2><pre><code class=\"cpp\">平衡二叉树\nset/map 红黑树(代码长) == splay(代码适中,支持很多操作)\ntreap(有局限,一些操作做不了)\nAVL\n多叉树\nB树 B+树\n\n操作:\n    左旋 \n    右旋 (维护的是中序遍历不变)\n             右旋\n              -&gt;\n         z           z\n        /           //\n       y           x    \n      / \\         / \\\\\n     x   c       A   y\n    / \\            // \\\n   A   B           B   C\n   AxByc           AxByc\n             左旋\n              -&gt;\n   =线代表变得关系\n   -代表不变的关系\n   可以发现由于要维护中序遍历,最左和最右的关系是不变的\n    插入\n    查询\n 每操作一个节点 均将该节点旋转到树根\nsplay(x,k) 将点x旋转至点k下\n1   \n       z      y    x\n      /      / \\    \\ \n     y      x   z    y\n    /                 \\\n   x                   z    \n        先转y     转x\n    每转一次x往上走两格 直到某个点下面为止\n2     z       z   x\n     /       /   / \\\n    y       x   y   z\n     \\     /\n      x   y\n       先转x     转x\n\n插入\n1  找到x插入位置\n   把x转到根\n2  将一个序列插到y的后面\n    ---------------\n            y z\n    2.1 找y的后继z \n    2.2 将y转到根       splay(y,0)\n    2.3 将z转到y的下面  spaly(z,y)\n   y\n    \\\n     z\n    /\n  null(因为z和y之间没有数,所以z左子树为空) \n   2.4 将序列插入到z的左子树 \n删除\n   -----------------\n     L-1 L   R R+1\n   1 将L-1转到根节点\n   2 将R+1转到L-1下面\n   此时R+1的左子树=[L,R]\n   3 将R+1的左儿子置为空Null\n本题\n维护信息\n   1 子树总点数 size 用于递归查找位置\n   2 懒标记     flag 整个区间是否需要翻转\n\npushup(u)用两个儿子信息维护根节点信息\n  tr[u].size = tr[u&lt;&lt;1].size+tr[u&lt;&lt;1|1].size\n写在旋转最后\n\npushdown(u)下传懒标记,先更新子树\n    swap(tr[u&lt;&lt;1],tr[u&lt;&lt;1|1])(要翻转整颗子树，要先把左右两个儿子翻转，然后递归翻转左右两棵子树)\n    将标记下传 t[u&lt;&lt;1] = t[u&lt;&lt;1|1] = t[u]\n    将当前标记清空  t[u] = 0\n写在递归之前\n\nsplay保证中序遍历是当前序列的顺序\n\n\n\n--------------------------------------------------------------------------\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n, m;\nstruct Node\n&#123;\n    int s[2], p, v;//儿子,父节点,编号\n    int size, flag;//子树节点个数, 有没有翻转\n\n    void init(int _v, int _p)\n    &#123;\n        v = _v, p = _p;\n        size = 1;\n    &#125;\n&#125;tr[N];\nint root, idx;\n\nvoid pushup(int x)\n&#123;\n    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;\n&#125;\n\nvoid pushdown(int x)\n&#123;\n    // 如果当前子树需要翻转 48.34\n    if (tr[x].flag)\n    &#123;\n        //要翻转整颗子树，要先把左右两个儿子翻转，然后递归翻转左右两棵子树\n        swap(tr[x].s[0], tr[x].s[1]);\n        tr[tr[x].s[0]].flag ^= 1;//翻转标记往下传\n        tr[tr[x].s[1]].flag ^= 1;//翻转标记往下传\n        tr[x].flag = 0;//当前标记清空\n    &#125;\n&#125;\n\n/*\n          z\n         /\n        y\n       /\n      x  \n    k=0表示x是y的左儿子；k=1表示x是y的右儿子\n         z           z\n        /           //   --1\n       y           x    \n      / \\         / \\\\   --2\n     x   c       A   y\n    / \\      3--   // \\\n   A   B           B   C \n   AxByc           AxByc\n             左旋\n              -&gt;\n   =线代表变得关系\n   -代表不变的关系\n   可以发现由于要维护中序遍历,最左和最右的关系是不变的\n   体现在rotate中就三条边\n   k代表左,k^1代表右\n*/\nvoid rotate(int x)\n&#123;\n    int y = tr[x].p, z = tr[y].p;\n    int k = tr[y].s[1] == x;  // k=0表示x是y的左儿子；k=1表示x是y的右儿子\n    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;// 边1 z原来的儿子y变为x  x的父节点变为z\n    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;// 边3 y的左儿子变为x的右儿子B,x的右儿子的父节点变为y\n    tr[x].s[k ^ 1] = y, tr[y].p = x;// 边2 x的右儿子变为y,y的父节点变为x\n    pushup(y), pushup(x);// A,B,C三个点信息没变,但x,y子树信息变了,又y在x下面,所以先维护更新y子树,再维护更新x子树\n&#125;\n/*\n1   \n       z      y    x\n      /      / \\    \\ \n     y      x   z    y\n    /                 \\\n   x                   z    \n        先转y     转x\n    每转一次x往上走两格 直到某个点下面为止\n2     z       z   x\n     /       /   / \\\n    y       x   y   z\n     \\     /\n      x   y\n       先转x     转x\n*/\nvoid splay(int x, int k)\n&#123;\n    while (tr[x].p != k)\n    &#123;\n        int y = tr[x].p, z = tr[y].p;\n        if (z != k)\n        // 如果是折线关系  ==  x是y的右/左儿子 且 y是z的左/右儿子  一0一1\n            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);//折线rotate两次x\n            else rotate(y);//直线rotate 一次y一次x\n        rotate(x);\n    &#125;\n    if (!k) root = x;//如果k==0 根节点更新为x\n&#125;\n// 按大插右 小插左的二叉树插法 插入节点\nvoid insert(int v)\n&#123;\n    int u = root, p = 0;\n    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];//一直往下递归直到u为null\n    u = ++ idx;\n    if (p) tr[p].s[v &gt; tr[p].v] = u;//如果有父节点,父节点儿子信息更新为u\n    tr[u].init(v, p);//初始化点u的值和父节点\n    splay(u, 0);//插入后将当前点u转到根节点上\n&#125;\n/*\n                 k\n                / \\\n tr[u&lt;&lt;1].size    \n 如果左子树个数&gt;=k 则去左子树里看\n 如果左子树个数=k-1,则u就是中序遍历第k个点\n 否则去右子树里看,k-=tr[u&lt;&lt;1].size-1\n*/\nint get_k(int k)\n&#123;\n    int u = root;\n    while (true)\n    &#123;\n        pushdown(u);\n        if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0];\n        else if (tr[tr[u].s[0]].size + 1 == k) return u;\n        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];\n    &#125;\n    return -1;//找不到返回-1\n&#125;\n//中序遍历\nvoid output(int u)\n&#123;\n    pushdown(u);\n    // 如果u有左儿子 先递归输出左儿子\n    if (tr[u].s[0]) output(tr[u].s[0]);\n    // 如果u不是哨兵输出当前点\n    if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v);\n    // 如果u有右儿子 递归输出右儿子\n    if (tr[u].s[1]) output(tr[u].s[1]);\n&#125;\n\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    for (int i = 0; i &lt;= n + 1; i ++ ) insert(i);//插入哨兵 0,n+1 防止L-1和R+1越界\n    while (m -- )\n    &#123;\n        int l, r;\n        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);\n        //因为哨兵要翻转的从[L,R]变为[L+1,R+1] 则要找L和R+2作为L+1的前继和R+1的后继\n        l = get_k(l), r = get_k(r + 2);\n        // 左端点l转到根,右端点r转到左端点下面\n        splay(l, 0), splay(r, l);\n        // 只要将r的左子树[L+1,R+1]翻转\n        tr[tr[r].s[0]].flag ^= 1;\n    &#125;\n    output(root);\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"P3391-文艺平衡树\"><a href=\"#P3391-文艺平衡树\" class=\"headerlink\" title=\"P3391 | 文艺平衡树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzOTE=\">P3391 | 文艺平衡树</span></h3><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010, INF = 0x3f3f3f3f;\nstruct Node&#123;\n    int s[2], p, v;\n    int sz, flag;\n    void init(int _v, int _p)&#123;\n        v = _v, p = _p;\n        sz = 1;\n    &#125;\n&#125;tr[N];\nint root, idx, n, m;\n\nvoid pushup(int x)&#123;\n    tr[x].sz = tr[tr[x].s[0]].sz + tr[tr[x].s[1]].sz + 1;\n&#125;\nvoid pushdown(int x)&#123;\n    if(tr[x].flag)&#123;\n        swap(tr[x].s[0], tr[x].s[1]);\n        tr[tr[x].s[0]].flag ^= 1;\n        tr[tr[x].s[1]].flag ^= 1;\n        tr[x].flag = 0;\n    &#125;\n&#125;\nvoid rotate(int x)&#123;\n    int y = tr[x].p, z = tr[y].p;\n    int k = tr[y].s[1] == x;\n    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;\n    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;\n    tr[x].s[k ^ 1] = y, tr[y].p = x;\n    pushup(y), pushup(x);\n&#125;\nvoid splay(int x, int k)&#123;\n    while(tr[x].p != k)&#123;\n        int y = tr[x].p, z = tr[y].p;\n        if(z != k)&#123;\n            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);\n            else rotate(y);\n        &#125;\n        rotate(x);\n    &#125;\n    if(!k) root = x;\n&#125;\nvoid insert(int v)&#123;\n    int u = root, p = 0;\n    while(u)&#123;\n        p = u, u = tr[u].s[v &gt; tr[u].v];\n    &#125;\n    u = ++idx;\n    if(p) tr[p].s[v &gt; tr[p].v] = u;\n    tr[u].init(v, p);\n    splay(u, 0);\n&#125;\nint get_k(int k)&#123;\n    int u = root;\n    while(1)&#123;\n        pushdown(u);\n        if(tr[tr[u].s[0]].sz &gt;= k) u = tr[u].s[0];\n        else if(tr[tr[u].s[0]].sz + 1 == k) return u;\n        else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];\n    &#125;\n    return -1;\n&#125;\nvoid output(int u)&#123;\n    pushdown(u);\n    if(tr[u].s[0]) output(tr[u].s[0]);\n    if(tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) cout &lt;&lt; tr[u].v &lt;&lt; &quot; &quot;;\n    if(tr[u].s[1]) output(tr[u].s[1]);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt;= n + 1; i++)&#123;\n        insert(i);\n    &#125;\n    while(m--)&#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        l = get_k(l), r = get_k(r + 2);\n        splay(l, 0), splay(r, l);\n        tr[tr[r].s[0]].flag ^= 1;\n    &#125;\n    output(root);\n&#125;\n</code></pre>\n<h3 id=\"P3369-普通平衡树\"><a href=\"#P3369-普通平衡树\" class=\"headerlink\" title=\"P3369 | 普通平衡树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjk=\">P3369 | 普通平衡树</span></h3><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nstruct Node&#123;\n    int s[2], p, v;\n    int sz, flag;\n    int cnt;\n\n    void init(int _v, int _p)&#123;\n        v = _v, p = _p;\n        sz = 1;\n        cnt = 1;\n    &#125;\n&#125;tr[N];\nint root, idx;\nvoid pushup(int u)&#123;\n    tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + tr[u].cnt;\n&#125;\nvoid rotate(int x)&#123;\n    int y = tr[x].p, z = tr[y].p;\n    int k = tr[y].s[1] == x;\n    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;\n    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;\n    tr[x].s[k ^ 1] = y, tr[y].p = x;\n    pushup(y), pushup(x);\n&#125;\nvoid splay(int x, int k)&#123;\n    while(tr[x].p != k)&#123;\n        int y = tr[x].p, z = tr[y].p;\n        if(z != k)&#123;\n            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);\n            else rotate(y);\n        &#125;\n        rotate(x);\n    &#125;\n    if(!k) root = x;\n&#125;\nvoid find(int x)&#123;\n    int p = root;\n    if(!p) return;\n    while(tr[p].s[x &gt; tr[p].v] &amp;&amp; x != tr[p].v)&#123;\n        p = tr[p].s[x &gt; tr[p].v];\n    &#125;\n    splay(p, 0);\n&#125;\nvoid insert(int x)&#123;\n    int p = root, y = 0;\n    while(p != 0 &amp;&amp; x != tr[p].v)&#123;\n        y = p, p = tr[p].s[x &gt; tr[p].v];\n    &#125;\n    if(p != 0)&#123;\n        tr[p].cnt++;\n    &#125;else&#123;\n        p = ++idx;\n        if(y != 0) tr[y].s[x &gt; tr[y].v] = p;\n        tr[p].init(x, y);\n    &#125;\n    splay(p, 0);\n&#125;\nint pre_next(int x, int st)&#123;\n    find(x);\n    int p = root;\n    if(tr[p].v &gt; x &amp;&amp; st == 1)&#123;\n        return p;\n    &#125;\n    if(tr[p].v &lt; x &amp;&amp; st == 0)&#123;\n        return p;\n    &#125;\n    p = tr[root].s[st];\n    while(tr[p].s[st ^ 1] != 0) p = tr[p].s[st ^ 1];\n    return p;\n&#125;\nvoid remove(int x)&#123;\n    int last = pre_next(x, 0);\n    int next = pre_next(x, 1);\n    splay(last, 0), splay(next, last);\n    int k = tr[next].s[0];\n    if(tr[k].cnt &gt; 1)&#123;\n        tr[k].cnt--;\n        splay(k, 0);\n    &#125;else&#123;\n        tr[next].s[0] = 0;\n    &#125;\n&#125;\nint pos(int x)&#123;\n    int p = root;\n    if(tr[p].sz &lt; x)&#123;\n        return -1;\n    &#125;\n    while(1)&#123;\n        if(x &lt;= tr[tr[p].s[0]].sz)&#123;\n            p = tr[p].s[0];\n        &#125;else if(x &gt; tr[tr[p].s[0]].sz + tr[p].cnt)&#123;\n            x -= tr[tr[p].s[0]].sz + tr[p].cnt;\n            p = tr[p].s[1];\n        &#125;else&#123;\n            return p;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n;\n    cin &gt;&gt; n;\n    insert(-INF), insert(INF);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int op, num;\n        cin &gt;&gt; op &gt;&gt; num;\n        if(op == 1)&#123;\n            insert(num);\n        &#125;else if(op == 2)&#123;\n            remove(num);\n        &#125;else if(op == 3)&#123;\n            find(num);\n            cout &lt;&lt; tr[tr[root].s[0]].sz &lt;&lt; &#39;\\n&#39;;\n        &#125;else if(op == 4)&#123;\n            cout &lt;&lt; tr[pos(num + 1)].v &lt;&lt; &#39;\\n&#39;;\n        &#125;else if(op == 5)&#123;\n            cout &lt;&lt; tr[pre_next(num, 0)].v &lt;&lt; &#39;\\n&#39;;\n        &#125;else&#123;\n            cout &lt;&lt; tr[pre_next(num, 1)].v &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"POJ2828-Buy-Tickets\"><a href=\"#POJ2828-Buy-Tickets\" class=\"headerlink\" title=\"POJ2828 | Buy Tickets\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0vUE9KLTI4MjgjYXV0aG9yPUhVQ00yMDE3MzI=\">POJ2828 | Buy Tickets</span></h3><ul>\n<li>题意<ul>\n<li>有 $N$ 个人排队，每一个人都有一个 $val$ 来对应，每一个后来人都会插入当前队伍的某一个位置 $pos$。要求把队伍最后的状态输出。</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>用 splay 模拟一遍即可。</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 2e5 + 10;\nint n, m;\nstruct Node&#123;\n    int s[2], p, v;\n    int sz, flag;\n    void init(int _v, int _p)&#123;\n        v = _v, p = _p;\n        sz = 1;\n    &#125;\n&#125;tr[N];\nint root, idx;\nvoid pushup(int x)&#123;\n    tr[x].sz = tr[tr[x].s[0]].sz + tr[tr[x].s[1]].sz + 1;\n&#125;\nvoid pushdown(int x)&#123;\n    if(tr[x].flag)&#123;\n        swap(tr[x].s[0], tr[x].s[1]);\n        tr[tr[x].s[0]].flag ^= 1;\n        tr[tr[x].s[1]].flag ^= 1;\n        tr[x].flag = 0;\n    &#125;\n&#125;\nvoid rotate(int x)&#123;\n    int y = tr[x].p, z = tr[y].p;\n    int k = tr[y].s[1] == x;\n    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;\n    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;\n    tr[x].s[k ^ 1] = y, tr[y].p = x;\n    pushup(y), pushup(x);\n&#125;\nvoid splay(int x, int k)&#123;\n    while(tr[x].p != k)&#123;\n        int y = tr[x].p, z = tr[y].p;\n        if(z != k)&#123;\n            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);\n            else rotate(y);\n        &#125;\n        rotate(x);\n    &#125;\n    if(!k) root = x;\n&#125;\nint get_k(int k)&#123;\n    int u = root;\n    while(1)&#123;\n        //pushdown(u);\n        if(tr[tr[u].s[0]].sz &gt;= k) u = tr[u].s[0];\n        else if(tr[tr[u].s[0]].sz + 1 == k) return u;\n        else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];\n    &#125;\n    return -1;\n&#125;\nvoid insert(int x, int v)&#123;\n    if(!root)&#123;\n        root = ++idx;\n        tr[root].init(v, 0);\n        return;\n    &#125;\n    if(!x)&#123;\n        int u = root;\n        while(tr[u].s[0]) u = tr[u].s[0];\n        tr[u].s[0] = ++idx;\n        tr[idx].init(v, u);\n        splay(idx, 0);\n        return;\n    &#125;\n    int k = get_k(x);\n    splay(k, 0);\n    root = ++idx;\n    tr[root].init(v, 0);\n    tr[root].s[1] = tr[k].s[1];\n    tr[tr[k].s[1]].p = root;\n    tr[k].s[1] = 0;\n    tr[root].s[0] = k;\n    tr[k].p = root;\n    pushup(k), pushup(root);\n&#125;\nvoid output(int u)&#123;\n    //pushdown(u);\n    if(tr[u].s[0]) output(tr[u].s[0]);\n    printf(&quot;%d &quot;, tr[u].v);\n    if(tr[u].s[1]) output(tr[u].s[1]);\n&#125;\nint main()&#123;\n    while(~scanf(&quot;%d&quot;, &amp;n))&#123;\n        root = idx = 0;\n        memset(tr, 0, sizeof tr);\n        for(int i = 1; i &lt;= n; i++)&#123;\n            int t, x;\n            scanf(&quot;%d %d&quot;, &amp;t, &amp;x);\n            insert(t, x);\n        &#125;\n        output(root);\n        puts(&quot;&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"莫队\"><a href=\"#莫队\" class=\"headerlink\" title=\"莫队\"></a>莫队</h2><ul>\n<li>参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vV0FNb25zdGVyL3AvMTAxMTg5MzQuaHRtbA==\">莫队算法——从入门到黑题</span></li>\n</ul>\n<h3 id=\"普通莫队\"><a href=\"#普通莫队\" class=\"headerlink\" title=\"普通莫队\"></a>普通莫队</h3><ul>\n<li>解决一段区间内不同数的个数</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e6 + 10;\ninline int read()&#123;\n    int x = 0, f = 1;\n    char ch = getchar();\n    while(!isdigit(ch))&#123;\n        if(ch == &#39;-&#39;) f = -1;\n        ch = getchar();\n    &#125;\n    while(isdigit(ch))&#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = getchar();\n    &#125;\n    return x * f;\n&#125;\ninline void write(int x)&#123;\n    if(x &lt; 0)&#123;\n        putchar(&#39;-&#39;);\n        x = -x;\n    &#125;\n    if(x &gt; 9) write(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n&#125;\nint sq;\nstruct query&#123;\n    int l, r, id;\n    // 奇偶化排序\n    bool operator &lt; (const query &amp;o) const&#123;\n        // 这里只需要知道每个元素归属哪个块，而块的大小都是 sqrt(n)，所以可以直接用 l/sq\n        if(l / sq != o.l / sq)&#123;\n            return l &lt; o.l;\n        &#125;\n        if(l / sq &amp; 1)&#123;\n            return r &lt; o.r;\n        &#125;\n        return r &gt; o.r;\n    &#125;\n&#125;Q[N];\nint A[N], ans[N], cnt[N], cur, l = 1, r = 0;\ninline void add(int p)&#123;\n    if(cnt[A[p]] == 0)&#123;\n        cur++;\n    &#125;\n    cnt[A[p]]++;\n&#125;\ninline void del(int p)&#123;\n    cnt[A[p]]--;\n    if(cnt[A[p]] == 0)&#123;\n        cur--;\n    &#125;\n&#125;\nint main()&#123;\n    int n = read();\n    sq = sqrt(n);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        A[i] = read();\n    &#125;\n    int q = read();\n    for(int i = 0; i &lt; q; i++)&#123;\n        Q[i].l = read();\n        Q[i].r = read();\n        Q[i].id = i;\n    &#125;\n    sort(Q, Q + q);\n    for(int i = 0; i &lt; q; i++)&#123;\n        while(l &gt; Q[i].l) add(--l);\n        while(r &lt; Q[i].r) add(++r);\n        while(l &lt; Q[i].l) del(l++);\n        while(r &gt; Q[i].r) del(r--);\n        ans[Q[i].id] = cur;\n    &#125;\n    for(int i = 0; i &lt; q; i++)&#123;\n        write(ans[i]);\n        putchar(&#39;\\n&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"带修莫队\"><a href=\"#带修莫队\" class=\"headerlink\" title=\"带修莫队\"></a>带修莫队</h3><ul>\n<li>加入时间戳，可以做到单点修改</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e6 + 100;\nint a[N], cnt[N], ans[N], bel[N];\nstruct Query&#123;\n    int l, r, time, id;\n&#125;q[N];\nstruct Modify&#123;\n    int pos, color, last;\n&#125;c[N];\nint sz;\nbool cmp(Query a, Query b)&#123;\n    if(bel[a.l] ^ bel[b.l])&#123;\n        return bel[a.l] &lt; bel[b.l];\n    &#125;else&#123;\n        if(bel[a.r] ^ bel[b.r])&#123;\n            return bel[a.r] &lt; bel[b.r];\n        &#125;else&#123;\n            return a.time &lt; b.time;\n        &#125;\n    &#125;\n&#125;\ninline int read()&#123;\n    int x = 0, f = 1;\n    char ch = getchar();\n    while(!isdigit(ch))&#123;\n        if(ch == &#39;-&#39;) f = -1;\n        ch = getchar();\n    &#125;\n    while(isdigit(ch))&#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = getchar();\n    &#125;\n    return x * f;\n&#125;\nint cntq, cntc, cur;\ninline void add1(int p)&#123;\n    if(cnt[a[p]] == 0)&#123;\n        cur++;\n    &#125;\n    cnt[a[p]]++;\n&#125;\ninline void del1(int p)&#123;\n    cnt[a[p]]--;\n    if(cnt[a[p]] == 0)&#123;\n        cur--;\n    &#125;\n&#125;\nint main()&#123;\n    int n = read(), m = read();\n    sz = pow(n, 2.0 / 3.0);\n    int bnum = ceil((double)n / sz);\n    for(int i = 1; i &lt;= bnum; ++i)&#123;\n        for(int j = (i - 1) * sz + 1; j &lt;= i * sz; ++j)&#123;\n            bel[j] = i;\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n; ++i)&#123;\n        a[i] = read();\n    &#125;\n    for(int i = 1; i &lt;= m; ++i)&#123;\n        char op[10];\n        scanf(&quot;%s&quot;, op);\n        if(op[0] == &#39;Q&#39;)&#123;\n            q[++cntq].l = read();\n            q[cntq].r = read();\n            q[cntq].time = cntc;\n            q[cntq].id = cntq;\n        &#125;else if(op[0] == &#39;R&#39;)&#123;\n            c[++cntc].pos = read();\n            c[cntc].color = read();\n        &#125;\n    &#125;\n    sort(q + 1, q + cntq + 1, cmp);\n    int l = 1, r = 0, ctime = 0;\n    for(int i = 1; i &lt;= cntq; ++i)&#123;\n        int ql = q[i].l, qr = q[i].r, qtime = q[i].time;\n        while(l &lt; ql) del1(l++);\n        while(l &gt; ql) add1(--l);\n        while(r &lt; qr) add1(++r);\n        while(r &gt; qr) del1(r--);\n        while(ctime &lt; qtime)&#123;\n            ctime++;\n            if(ql &lt;= c[ctime].pos &amp;&amp; c[ctime].pos &lt;= qr)&#123;\n                cur -= !--cnt[a[c[ctime].pos]] - !cnt[c[ctime].color]++;\n            &#125;\n            swap(a[c[ctime].pos], c[ctime].color);\n        &#125;\n        while(qtime &lt; ctime)&#123;\n            if(ql &lt;= c[ctime].pos &amp;&amp; c[ctime].pos &lt;= qr)&#123;\n                cur -= !--cnt[a[c[ctime].pos]] - !cnt[c[ctime].color]++;\n            &#125;\n            swap(a[c[ctime].pos], c[ctime].color);\n            ctime--;\n        &#125;\n        ans[q[i].id] = cur;\n    &#125;\n    for(int i = 1; i &lt;= cntq; ++i)&#123;\n        printf(&quot;%d\\n&quot;, ans[i]);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"珂朵莉树\"><a href=\"#珂朵莉树\" class=\"headerlink\" title=\"珂朵莉树\"></a>珂朵莉树</h2><ul>\n<li>优雅的暴力</li>\n<li>珂朵莉树的适用范围是有<strong>区间赋值</strong>操作且<strong>数据随机</strong>的题目。其实珂朵莉树看上去并不像是树状数据结构，但因为一般要用到<code>std::set</code>，而<code>std::set</code>是用红黑树实现的，所以也不算名不副实。在随机数据下，珂朵莉树可以达到 $O(n;log⁡;log⁡;n)$ 的复杂度（参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDI3ODYwNzE=\">这篇文章</span>）。</li>\n<li>珂朵莉树的思想在于随机数据下的区间赋值操作很可能让大量元素变为同一个数。所以我们以三元组<code>&lt;l,r,v&gt;</code>的形式保存数据（区间 $[l,r]$ 中的元素的值都是 $v$）：</li>\n</ul>\n<h3 id=\"CF896C-Willem-Chtholly-and-Seniorious\"><a href=\"#CF896C-Willem-Chtholly-and-Seniorious\" class=\"headerlink\" title=\"CF896C | Willem, Chtholly and Seniorious\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y4OTZD\">CF896C | Willem, Chtholly and Seniorious</span></h3><pre><code class=\"cpp\">// 珂朵莉树\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n\nstruct Node&#123;\n    LL l, r;\n    mutable LL v;\n    Node(LL l, LL r, LL v) : l(l), r(r), v(v) &#123;&#125;\n    bool operator &lt; (const Node &amp;rhs) const&#123;\n        return l &lt; rhs.l;\n    &#125;\n&#125;;\n\nLL qpow(LL a, LL b, LL mod)&#123;\n    LL ans = 1;\n    a %= mod;\n    while(b)&#123;\n        if(b &amp; 1) ans = ans * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    &#125;\n    return ans;\n&#125;\n\nset&lt;Node&gt; tr;\n// 分裂区间\nauto split(LL pos)&#123;\n    auto it = tr.lower_bound(Node(pos, 0, 0));\n    if(it != tr.end() &amp;&amp; it-&gt;l == pos)&#123;\n        return it;\n    &#125;\n    it--;\n    auto [l, r, v] = *it;\n    tr.erase(it);\n    tr.insert(&#123;l, pos - 1, v&#125;);\n    return tr.insert(&#123;pos, r, v&#125;).first;\n&#125;\n// 赋值\nvoid assign(LL l, LL r, LL v)&#123;\n    // 强调顺序\n    auto end = split(r + 1), begin = split(l);\n    tr.erase(begin, end);\n    tr.insert(&#123;l, r, v&#125;);\n&#125;\n// 区间加\nvoid add(LL l, LL r, LL v)&#123;\n    auto end = split(r + 1), begin = split(l);\n    for(auto it = begin; it != end; it++)&#123;\n        it-&gt;v += v;\n    &#125;\n&#125;\n// 求区间 k 大值\nLL kth(LL l, LL r, LL k)&#123;\n    auto end = split(r + 1), begin = split(l);\n    // pair 存节点的值和区间长度\n    vector&lt;pair&lt;LL, LL&gt;&gt; v;\n    for(auto it = begin; it != end; it++)&#123;\n        v.push_back(&#123;it-&gt;v, it-&gt;r - it-&gt;l + 1&#125;);\n    &#125;\n    sort(v.begin(), v.end());\n    for(int i = 0; i &lt; v.size(); i++)&#123;\n        k -= v[i].second;\n        if(k &lt;= 0) return v[i].first;\n    &#125;\n&#125;\n// 求区间 n 次方和\nLL sum_of_power(LL l, LL r, LL x, LL y)&#123;\n    LL tot = 0;\n    auto end = split(r + 1), begin = split(l);\n    for(auto it = begin; it != end; it++)&#123;\n        tot = (tot + qpow(it-&gt;v, x, y) * (it-&gt;r - it-&gt;l + 1)) % y;\n    &#125;\n    return tot;\n&#125;\nLL rnd(LL&amp; seed)&#123;\n    LL x = seed;\n    seed = (seed * 7 + 13) % 1000000007;\n    return x;\n&#125;\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(false);\n    LL n, m, seed, vmax;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        LL r = rnd(seed);\n        tr.insert(&#123;i, i, r % vmax + 1&#125;);\n    &#125;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        LL opr = rnd(seed) % 4 + 1, l = rnd(seed) % n + 1, r = rnd(seed) % n + 1, x, y;\n        if(l &gt; r)&#123;\n            swap(l, r);\n        &#125;\n        if(opr == 3)&#123;\n            x = rnd(seed) % (r - l + 1) + 1;\n        &#125;else&#123;\n            x = rnd(seed) % vmax + 1;\n        &#125;\n        if(opr == 4)&#123;\n            y = rnd(seed) % vmax + 1;\n        &#125;\n        switch (opr)\n        &#123;\n        case 1:\n            add(l, r, x);\n            break;\n        \n        case 2:\n            assign(l, r, x);\n            break;\n\n        case 3:\n            cout &lt;&lt; kth(l, r, x) &lt;&lt; &#39;\\n&#39;;\n            break;\n\n        case 4:\n            cout &lt;&lt; sum_of_power(l, r, x, y) &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"树链剖分\"><a href=\"#树链剖分\" class=\"headerlink\" title=\"树链剖分\"></a>树链剖分</h2><ul>\n<li><p>树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。</p>\n</li>\n<li><p>具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。</p>\n</li>\n<li><p><strong>树链剖分</strong>（树剖&#x2F;链剖）有多种形式，如 <strong>重链剖分</strong>，<strong>长链剖分</strong> 和用于 Link&#x2F;cut Tree 的剖分（有时被称作“实链剖分”），大多数情况下（没有特别说明时），“树链剖分”都指“重链剖分”。</p>\n</li>\n<li><p>重链剖分可以将树上的任意一条路径划分成不超过  条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。</p>\n</li>\n<li><p>重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。</p>\n<ol>\n<li>修改 <strong>树上两点之间的路径上</strong> 所有点的值。</li>\n<li>查询 <strong>树上两点之间的路径上</strong> 节点权值的 <strong>和&#x2F;极值&#x2F;其它（在序列上可以用数据结构维护，便于合并的信息）</strong>。</li>\n</ol>\n</li>\n<li><p>除了配合数据结构来维护树上路径信息，树剖还可以用来 （且常数较小）地求 LCA。在某些题目中，还可以利用其性质来灵活地运用树剖。</p>\n</li>\n</ul>\n<h3 id=\"重链剖分\"><a href=\"#重链剖分\" class=\"headerlink\" title=\"重链剖分\"></a>重链剖分</h3><ul>\n<li>定义 <strong>重子节点</strong> 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。</li>\n<li>定义 <strong>轻子节点</strong> 表示剩余的所有子结点。从这个结点到重子节点的边为 <strong>重边</strong>，到其他轻子节点的边为 <strong>轻边</strong>。</li>\n<li>若干条首尾衔接的重边构成 <strong>重链</strong>。</li>\n<li>把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。</li>\n<li>重链剖分有一个重要的性质：<strong>对于节点数为 n 的树，从任意节点向上走到根节点，经过的轻边数量不超过 log⁡n</strong> 。这是因为，如果一个节点连向父节点的边是轻边，就必然存在子树不小于它的兄弟节点，那么父节点对应子树的大小一定超过该节点的两倍。每经过一条轻边，子树大小就翻倍，所以最多只能经过 log⁡n 条。</li>\n<li>我们通过两次dfs来进行重链剖分。第一趟dfs，先得到每个节点的<code>fa</code>（父节点）、<code>sz</code>（子树大小）、<code>dep</code>（深度）、<code>hson</code>（重子节点）：</li>\n</ul>\n<pre><code class=\"cpp\">int fa[N], dep[N], sz[N], hson[N], top[N], dfsn[N], madfsn[N];\nvoid dfs1(int p, int d = 1)&#123;\n    int cnt = 1, maxv = 0;\n    dep[p] = d;\n    for(auto i : g[p])&#123;\n        if(!dep[i])&#123;\n            dfs1(i, d + 1);\n            fa[i] = p;\n            cnt += sz[i];\n            if(sz[i] &gt; maxv)&#123;\n                maxv = sz[i];\n                hson[p] = i;\n            &#125;\n        &#125;\n    &#125;\n    sz[p] = cnt;\n&#125;\n</code></pre>\n<ul>\n<li>第二趟dfs，得到每个节点的<code>top</code>（链头，即所在的重链中深度最小的那个节点）：</li>\n</ul>\n<pre><code class=\"cpp\">// 需要先把根节点的top初始化为自身\nvoid dfs2(int p)&#123;\n    for(auto i : g[p])&#123;\n        if(!top[i])&#123;\n            if(i == hson[p])&#123;\n                top[i] = top[p];\n            &#125;else&#123;\n                top[i] = i;\n            &#125;\n            dfs2(i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"求-LCA\"><a href=\"#求-LCA\" class=\"headerlink\" title=\"求 LCA\"></a>求 LCA</h3><ul>\n<li>树剖可以单次 $O(log;⁡n)$ 地求 LCA，且常数较小。假如我们要求两个节点的 LCA，如果它们在同一条链上，那直接输出深度较小的那个节点就可以了。</li>\n<li>否则，LCA要么在链头深度较小的那条链上，要么就是两个链头的父节点的LCA，但绝不可能在链头深度较大的那条链上。所以我们可以直接把链头深度较大的节点用其链头的父节点代替，然后继续求它与另一者的LCA。</li>\n<li>由于在链上我们可以 $O(1)$ 地跳转，每条链间由轻边连接，而经过轻边的次数又不超过 $log ;n$ ，所以我们实现了 $O(log⁡;n)$ 的 LCA 查询。</li>\n</ul>\n<pre><code class=\"cpp\">int lca(int a, int b)&#123;\n    while (top[a] != top[b])&#123;\n        if (dep[top[a]] &gt; dep[top[b]])\n            a = fa[top[a]];\n        else\n            b = fa[top[b]];\n    &#125;\n    return (dep[a] &gt; dep[b] ? b : a);\n&#125;\n</code></pre>\n<h3 id=\"结合数据结构\"><a href=\"#结合数据结构\" class=\"headerlink\" title=\"结合数据结构\"></a>结合数据结构</h3><ul>\n<li>在进行了树链剖分后，我们便可以配合线段树等数据结构维护树上的信息，这需要我们改一下第二次dfs的代码，我们用<code>dfsn</code>数组记录每个点的<strong>dfs序</strong>，用<code>madfsn</code>数组记录<strong>每棵子树的最大dfs序</strong>：</li>\n</ul>\n<pre><code class=\"cpp\">// 需要先把根节点的top初始化为自身\nint cnt;\nvoid dfs2(int p)&#123;\n    madfsn[p] = dfsn[p] = ++cnt;\n    if(hson[p] != 0)&#123;\n        top[hson[p]] = top[p];\n        dfs2(hson[p]);\n        madfsn[p] = max(madfsn[p], madfsn[hson[p]]);\n    &#125;\n    for(auto i : g[p])&#123;\n        if(!top[i])&#123;\n            top[i] = i;\n            dfs2(i);\n            madfsn[p] = max(madfsn[p], madfsn[i]);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>注意到，<strong>每棵子树的dfs序都是连续的，且根节点dfs序最小</strong>；而且，如果我们优先遍历重子节点，那么<strong>同一条链上的节点的dfs序也是连续的，且链头节点dfs序最小</strong>。</li>\n<li><img data-src=\"https://pic4.zhimg.com/80/v2-2f1a4cdb51812c7a4cd7f0ab22b9566f_720w.jpg\"></li>\n<li>所以就可以用线段树等数据结构维护区间信息（以点权的和为例），例如路径修改（类似于求LCA的过程）：</li>\n</ul>\n<pre><code class=\"cpp\">// 路径修改\nvoid update_path(int x, int y, int z)&#123;\n    while(top[x] != top[y])&#123;\n        if(dep[top[x]] &gt; dep[top[y]])&#123;\n            modify(1, dfsn[top[x]], dfsn[x], z);\n            x = fa[top[x]];\n        &#125;else&#123;\n            modify(1, dfsn[top[y]], dfsn[y], z);\n            y = fa[top[y]];\n        &#125;\n    &#125;\n    if(dep[x] &gt; dep[y])&#123;\n        modify(1, dfsn[top[y]], dfsn[x], z);\n    &#125;else&#123;\n        modify(1, dfsn[top[x]], dfsn[y], z);\n    &#125;\n&#125;\n// 路径查询\nint query_path(int x, int y)&#123;\n    int ans = 0;\n    while(top[x] != top[y])&#123;\n        if(dep[top[x]] &gt; dep[top[y]])&#123;\n            ans += query(1, dfsn[top[x]], dfsn[x]);\n            x = fa[top[x]];\n        &#125;else&#123;\n            ans += query(1, dfsn[top[y]], dfsn[y]);\n            y = fa[top[y]];\n        &#125;\n    &#125;\n    if(dep[x] &gt; dep[y])&#123;\n        ans += query(1, dfsn[top[y]], dfsn[x]);\n    &#125;else&#123;\n        ans += query(1, dfsn[top[x]], dfsn[y]);\n    &#125;\n    return ans;\n&#125;\n// 子树修改\nvoid modify_subtree(int x, int z)&#123;\n    modify(1, dfsn[x], madfsn[x], z);\n&#125;\n// 子树查询\nint query_subtree(int x)&#123;\n    return query(1, dfsn[x], madfsn[x]);\n&#125;\n</code></pre>\n<ul>\n<li>需要注意，建线段树的时候不是按节点编号建，而是按dfs序建</li>\n</ul>\n<pre><code class=\"cpp\">for (int i = 1; i &lt;= n; ++i)\n    B[i] = read();\n// ...\nfor (int i = 1; i &lt;= n; ++i)\n    A[dfsn[i]] = B[i];\nbuild();\n</code></pre>\n<ul>\n<li>当然，不仅可以用线段树维护，有些题也可以使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYzNTMwODI=\">珂朵莉树</span>等数据结构（要求数据不卡珂朵莉树，如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vd3d3Lmx1b2d1LmNvbS5jbi9wcm9ibGVtL1A0MzE1\">这道</span>）。此外，如果需要维护的是边权而不是点权，把每条边的边权下放到深度较深的那个节点处即可，但是查询、修改的时候要注意略过最后一个点。</li>\n</ul>\n<h3 id=\"P2590-树的统计\"><a href=\"#P2590-树的统计\" class=\"headerlink\" title=\"P2590 树的统计\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1OTA=\">P2590 树的统计</span></h3><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 3e4 + 10;\nstruct Node&#123;\n    int l, r;\n    LL sum, maxv;\n&#125;tr[N &lt;&lt; 2];\nLL w[N];\nvoid pushup(int u)&#123;\n    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;\n    tr[u].maxv = max(tr[u &lt;&lt; 1].maxv, tr[u &lt;&lt; 1 | 1].maxv);\n&#125;\nvoid build(int u, int l, int r)&#123;\n    tr[u] = &#123;l, r&#125;;\n    if(l == r)&#123;\n        tr[u].sum = w[l];\n        tr[u].maxv = w[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid);\n    build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n&#125;\nvoid modify(int u, int l, int r, LL v)&#123;\n    if(l == tr[u].l &amp;&amp; r == tr[u].r)&#123;\n        tr[u].sum = v;\n        tr[u].maxv = v;\n        return;\n    &#125;\n    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n    if(l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);\n    if(r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);\n    pushup(u);\n&#125;\nint query_max(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;\n        return tr[u].maxv;\n    &#125;\n    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n    int ans = -0x3f3f3f3f;\n    if(l &lt;= mid) ans = max(ans, query_max(u &lt;&lt; 1, l, r));\n    if(r &gt; mid) ans = max(ans, query_max(u &lt;&lt; 1 | 1, l, r));\n    return ans;\n&#125;\nint query_sum(int u, int l, int r)&#123;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;\n        return tr[u].sum;\n    &#125;\n    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\n    int ans = 0;\n    if(l &lt;= mid) ans = query_sum(u &lt;&lt; 1, l, r);\n    if(r &gt; mid) ans += query_sum(u &lt;&lt; 1 | 1, l, r);\n    return ans;\n&#125;\n\n// 树链剖分\nint h[N], ne[N &lt;&lt; 1], e[N &lt;&lt; 1], idx;\nint fa[N], dep[N], sz[N], hson[N], top[N], dfsn[N], madfsn[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs1(int p, int d = 1)&#123;\n    int cnt = 1, maxv = 0;\n    dep[p] = d;\n    for(int i = h[p]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == fa[p]) continue;\n        if(!dep[j])&#123;\n            dfs1(j, d + 1);\n            cnt += sz[j];\n            fa[j] = p;\n            if(sz[j] &gt; maxv) maxv = sz[j], hson[p] = j;\n        &#125;\n    &#125;\n    sz[p] = cnt;\n&#125;\nint cnt;\nvoid dfs2(int p)&#123;\n    madfsn[p] = dfsn[p] = ++cnt;\n    if(hson[p] != 0)&#123;\n        top[hson[p]] = top[p];\n        dfs2(hson[p]);\n        madfsn[p] = max(madfsn[p], madfsn[hson[p]]);\n    &#125;\n    for(int i = h[p]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == fa[p] || j == hson[p]) continue;\n        if(!top[j])&#123;\n            top[j] = j;\n            dfs2(j);\n            madfsn[p] = max(madfsn[p], madfsn[j]);\n        &#125;\n    &#125;\n&#125;\nint query_path_max(int x, int y)&#123;\n    int ans = -0x3f3f3f3f;\n    while(top[x] != top[y])&#123;\n        if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        ans = max(ans, query_max(1, dfsn[top[x]], dfsn[x]));\n        x = fa[top[x]];\n    &#125;\n    if(dep[x] &gt; dep[y]) swap(x, y);\n    ans = max(ans, query_max(1, dfsn[x], dfsn[y]));\n    return ans;\n&#125;\nint query_path_sum(int x, int y)&#123;\n    int ans = 0;\n    while(top[x] != top[y])&#123;\n        if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        ans += query_sum(1, dfsn[top[x]], dfsn[x]);\n        x = fa[top[x]];\n    &#125;\n    if(dep[x] &gt; dep[y]) swap(x, y);\n    ans += query_sum(1, dfsn[x], dfsn[y]);\n    return ans;\n&#125;\nint num[N];\nint main()&#123;\n    cin.tie(0)-&gt;sync_with_stdio(false);\n    int n;\n    cin &gt;&gt; n;\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt; n; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b);\n        add(b, a);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; num[i];\n    &#125;\n    top[1] = 1;\n    dfs1(1);\n    dfs2(1);\n    for(int i = 1; i &lt;= n; i++)&#123;\n        w[dfsn[i]] = num[i];\n    &#125;\n    build(1, 1, n);\n    int m;\n    cin &gt;&gt; m;\n    while(m--)&#123;\n        string op;\n        int a, b;\n        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;\n        if(op[0] == &#39;C&#39;) modify(1, dfsn[a], dfsn[a], b);\n        else if(op == &quot;QMAX&quot;)&#123;\n            cout &lt;&lt; query_path_max(a, b) &lt;&lt; &#39;\\n&#39;;\n        &#125;else&#123;\n            cout &lt;&lt; query_path_sum(a, b) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板",
                "题集"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html",
            "url": "https://asterzc19.github.io/post/%E5%9B%BE%E8%AE%BA%E9%A2%98%E9%9B%86.html",
            "title": "图论题集",
            "date_published": "2022-03-14T10:00:20.000Z",
            "content_html": "<blockquote>\n<p>包括单源最短路的建图方式、单源最短路的综合应用、单源最短路的扩展应用、Floyd 算法、最小生成树、最小生成树的扩展应用、负环、差分约束、最近公共祖先、强连通分量、双连通分量、二分图、欧拉回路和欧拉路径、拓扑排序等内容</p>\n</blockquote>\n<ul>\n<li>图论的重点在于问题的转化和抽象</li>\n</ul>\n<hr>\n<h2 id=\"单源最短路的建图方式\"><a href=\"#单源最短路的建图方式\" class=\"headerlink\" title=\"单源最短路的建图方式\"></a>单源最短路的建图方式</h2><h3 id=\"AcWing-热浪\"><a href=\"#AcWing-热浪\" class=\"headerlink\" title=\"AcWing|热浪\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzMS8=\">AcWing|热浪</span></h3><ul>\n<li>spfa 不会被卡</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 2510, M = 6200 * 2 + 10;\nint h[N], e[M], ne[M], w[M], idx;\nint dis[N];\nbool st[N];\nint n, m;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid spfa(int x)&#123;\n    memset(dis, 0x3f, sizeof(dis));\n    dis[x] = 0;\n    st[x] = true;\n    queue&lt;int&gt; q;\n    q.push(x);\n    while(!q.empty())&#123;\n        int u = q.front(); q.pop();\n        st[u] = false;\n        for(int i = h[u]; ~i; i = ne[i])&#123;\n            int v = e[i];\n            if(dis[u] + w[i] &lt; dis[v])&#123;\n                dis[v] = dis[u] + w[i];\n                if(!st[v])&#123;\n                    st[v] = true;\n                    q.push(v);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int start, end;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; end;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c); add(b, a, c);\n    &#125;\n    spfa(start);\n    cout &lt;&lt; dis[end] &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-信使\"><a href=\"#AcWing-信使\" class=\"headerlink\" title=\"AcWing|信使\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzMC8=\">AcWing|信使</span></h3><ul>\n<li>对于每个点来说，它接收到信的时间，等于它到指挥部的最短距离</li>\n<li>数据范围很小，可以直接用 Floyd</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 110, M = 210 * 2 + 10;\nint h[N], e[M], ne[M], w[M], idx;\nint dis[N];\nbool st[N];\nint n, m;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint dijkstra(int x)&#123;\n    memset(dis, 0x3f, sizeof(dis));\n    dis[x] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;\n    q.push(&#123;0, x&#125;);\n    while(q.size())&#123;\n        auto t = q.top(); q.pop();\n        int ver = t.second, distance = t.first;\n        if(st[ver]) continue;\n        st[ver] = true;\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dis[j] &gt; distance + w[i])&#123;\n                dis[j] = distance + w[i];\n                q.push(&#123;dis[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(dis[i] == 0x3f3f3f3f) return -1;\n        ans = max(ans, dis[i]);\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c); add(b, a, c);\n    &#125;\n    cout &lt;&lt; dijkstra(1) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-香甜的黄油\"><a href=\"#AcWing-香甜的黄油\" class=\"headerlink\" title=\"AcWing|香甜的黄油\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyOS8=\">AcWing|香甜的黄油</span></h3><ul>\n<li>多源汇最短路问题</li>\n<li>以每一个牧场为终点，全部求一遍最短路之和，找到最小值即可</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 810, M = 3000;\nint h[N], e[M], ne[M], w[M], idx;\nint dis[N], id[N];\nbool st[N];\nint n, p, m;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint spfa(int x)&#123;\n    memset(dis, 0x3f, sizeof(dis));\n    dis[x] = 0;\n    queue&lt;int&gt; q;\n    q.push(x);\n    st[x] = true;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dis[j] &gt; dis[t] + w[i])&#123;\n                dis[j] = dis[t] + w[i];\n                if(!st[j])&#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    int res = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int j = id[i];\n        if(dis[j] == 0x3f3f3f3f) return 0x3f3f3f3f;\n        res += dis[j];\n    &#125;\n    return res;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; id[i];\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c); add(b, a, c);\n    &#125;\n    int ans = 0x3f3f3f3f;\n    for(int i = 1; i &lt;= p; i++) ans = min(ans, spfa(i));\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-最小花费\"><a href=\"#AcWing-最小花费\" class=\"headerlink\" title=\"AcWing|最小花费\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyOC8=\">AcWing|最小花费</span></h3><ul>\n<li>可以转化成从 $A$ 到 $B$ 权值乘积最大的路</li>\n<li>对权值乘积可以取对数转换成加法，且取完对数权值全是非正，所以可以转换成最短路，用 Dijkstra 求</li>\n<li>此处直接乘法做即可</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 2010;\ndouble g[N][N];\ndouble dist[N];\nbool st[N];\nint n, m;\nvoid dijkstra(int x)&#123;\n    dist[x] = 1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            if(!st[j] &amp;&amp; (t == -1 || dist[j] &gt; dist[t])) t = j;\n        &#125;\n        st[t] = 1;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            dist[j] = max(dist[j], dist[t] * g[t][j]);\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cout &lt;&lt; fixed &lt;&lt; setprecision(8);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        double t = (100 - z) / 100.0;\n        g[x][y] = g[y][x] = max(g[x][y], t);\n    &#125;\n    int start, end; cin &gt;&gt; start &gt;&gt; end;\n    dijkstra(start);\n    cout &lt;&lt; (100 / dist[end]) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-最优乘车\"><a href=\"#AcWing-最优乘车\" class=\"headerlink\" title=\"AcWing|最优乘车\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTIyLw==\">AcWing|最优乘车</span></h3><ul>\n<li>每趟巴士的所有站之间可以建立一条权值为 $1$ 的有向边，换乘数可以转换成从起点坐到终点的权值 $-1$</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 510;\nbool g[N][N];\nint dist[N];\nint stop[N];\nint n, m;\nvoid bfs()&#123;\n    queue&lt;int&gt; q;\n    memset(dist, 0x3f, sizeof(dist));\n    q.push(1);\n    dist[1] = 0;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        for(int i = 1; i &lt;= n; i++)&#123;\n            if(g[t][i] &amp;&amp; dist[i] &gt; dist[t] + 1)&#123;\n                dist[i] = dist[t] + 1;\n                q.push(i);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; m &gt;&gt; n;\n    string line;\n    getline(cin, line);\n    while(m--)&#123;\n        getline(cin, line);\n        stringstream ssin(line);\n        int cnt = 0, p;\n        while(ssin &gt;&gt; p) stop[++cnt] = p;\n        for(int j = 1; j &lt;= cnt; j++)&#123;\n            for(int k = j + 1; k &lt;= cnt; k++)&#123;\n                g[stop[j]][stop[k]] = true;\n            &#125;\n        &#125;\n    &#125;\n    bfs();\n    if(dist[n] == 0x3f3f3f3f) cout &lt;&lt; &quot;NO\\n&quot;;\n    else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-昂贵的聘礼\"><a href=\"#AcWing-昂贵的聘礼\" class=\"headerlink\" title=\"AcWing|昂贵的聘礼\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTA1Lw==\">AcWing|昂贵的聘礼</span></h3><ul>\n<li>可以设置一个虚拟源点，边权全为原价购买的价格</li>\n<li>枚举不同等级区间内的最短路，取最小值</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110, INF = 0x3f3f3f3f;\nint n, m;\nint w[N][N], level[N];\nint dist[N];\nbool st[N];\nint dijkstra(int down, int up)&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    memset(st, 0, sizeof(st));\n    dist[0] = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int t = -1;\n        for(int j = 0; j &lt;= n; j++)&#123;\n            if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;\n        &#125;\n        st[t] = 1;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            if(level[j] &gt;= down &amp;&amp; level[j] &lt;= up)&#123;\n                dist[j] = min(dist[j], dist[t] + w[t][j]);\n            &#125;\n        &#125;\n    &#125;\n    return dist[1];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; m &gt;&gt; n;\n    memset(w, 0x3f, sizeof(w));\n    for(int i = 1; i &lt;= n; i++)&#123;\n        w[i][i] = 0;\n        int price, cnt;\n        cin &gt;&gt; price &gt;&gt; level[i] &gt;&gt; cnt;\n        w[0][i] = min(price, w[0][i]);\n        while(cnt--)&#123;\n            int id, cost;\n            cin &gt;&gt; id &gt;&gt; cost;\n            w[id][i] = min(w[id][i], cost);\n        &#125;\n    &#125;\n    int ans = INF;\n    for(int i = level[1] - m; i &lt;= level[1]; i++)&#123;\n        ans = min(ans, dijkstra(i, i + m));\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"单源最短路的综合应用\"><a href=\"#单源最短路的综合应用\" class=\"headerlink\" title=\"单源最短路的综合应用\"></a>单源最短路的综合应用</h2><ul>\n<li>单源最短路与其他算法的结合<ul>\n<li>DFS</li>\n<li>二分</li>\n<li>DP</li>\n<li>拓扑排序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-新年好\"><a href=\"#AcWing-新年好\" class=\"headerlink\" title=\"AcWing|新年好\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzNy8=\">AcWing|新年好</span></h3><ul>\n<li>最短路与 DFS 的结合</li>\n<li>先预处理最短路，之后 DFS 拜访顺序<ul>\n<li>先预处理出从 $1, a, b, c, d, e$ 出发到其他所有点的单源最短路径</li>\n<li>DFS 所有拜访顺序 $5!$，对于每一种拜访顺序，可以通过查表的方式算出最短距离</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 50010, M = 200010, INF = 0x3f3f3f3f;\nint h[N], e[M], ne[M], w[M], idx;\nint dist[6][N], source[6];\nbool st[N];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dijkstra(int start, int dist[])&#123;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;\n    memset(st, 0, sizeof(st));\n    dist[start] = 0;\n    pq.push(&#123;0, start&#125;);\n    while(pq.size())&#123;\n        auto t = pq.top(); pq.pop();\n        int ver = t.second, distance = t.first;\n        if(st[ver]) continue;\n        st[ver] = 1;\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &gt; distance + w[i])&#123;\n                dist[j] = distance + w[i];\n                pq.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint dfs(int u, int start, int dis)&#123;\n    if(u &gt; 5) return dis;\n    int ans = INF;\n    for(int i = 1; i &lt;= 5; i++)&#123;\n        if(!st[i])&#123;\n            int nxt = source[i];\n            st[i] = 1;\n            ans = min(ans, dfs(u + 1, i, dis + dist[start][nxt]));\n            st[i] = 0;\n        &#125;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    memset(dist, 0x3f, sizeof(dist));\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= 5; i++) cin &gt;&gt; source[i];\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c), add(b, a, c);\n    &#125;\n    source[0] = 1;\t// 从这里出发\n    for(int i = 0; i &lt;= 5; i++) dijkstra(source[i], dist[i]);\n    memset(st, 0, sizeof(st));\n    cout &lt;&lt; dfs(1, 0, 0) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-通信线路\"><a href=\"#AcWing-通信线路\" class=\"headerlink\" title=\"AcWing|通信线路\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQyLw==\">AcWing|通信线路</span></h3><ul>\n<li>判断是否能二分的条件是，查找的值是否在分界点上，即分界点左边满足这个性质，右边不满足这个性质<ul>\n<li>定义在 $[0, 1000001]$ 这个区间中的性质如下</li>\n<li>对于区间中的某一个点 $x$，求出从 $1 \\sim N$ 中最少经过几条长度大于 $x$ 的边，假设有 $cnt$ 条，是否满足 $cnt \\le k$</li>\n</ul>\n</li>\n<li>求出从 $1$ 到 $N$ 最少经过几条长度大于 $x$ 的边，可以将所有边分类：如果边长大于 $x$，则边权看成 $1$，否则边权为 $0$<ul>\n<li>因此可以使用双端队列 BFS 来求最短路，时间复杂度 $O(n)$</li>\n</ul>\n</li>\n<li>因此本题即为 <strong>双端队列 + 二分</strong></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010, M = 20010;\nint h[N], e[M], ne[M], w[M], idx;\nint dist[N];\nbool st[N];\nint n, m, k;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool bfs(int x)&#123;\n    memset(st, 0, sizeof(st));\n    memset(dist, 0x3f, sizeof(dist));\n    deque&lt;int&gt; q;\n    q.push_back(1);\n    dist[1] = 0;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop_front();\n        if(st[t]) continue;\n        st[t] = 1;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i], v = w[i] &gt; x;\n            if(dist[j] &gt; dist[t] + v)&#123;\n                dist[j] = dist[t] + v;\n                if(!v) q.push_front(j);\n                else q.push_back(j);\n            &#125;\n        &#125;\n    &#125;\n    return dist[n] &lt;= k;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    while(m--)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c), add(b, a, c);\n    &#125;\n    int l = 0, r = 1e6 + 1;     // r 比边界多 1 判断是否有解\n    while(l &lt; r)&#123;\n        int mid = l + r &gt;&gt; 1;\n        if(bfs(mid)) r = mid;\n        else l = mid + 1;\n    &#125;\n    if(r == 1e6 + 1) cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else cout &lt;&lt; r &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-道路与航线🌖🌖\"><a href=\"#AcWing-道路与航线🌖🌖\" class=\"headerlink\" title=\"AcWing|道路与航线🌖🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ0Lw==\">AcWing|道路与航线</span>🌖🌖</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9hY3Rpdml0eS9jb250ZW50L2NvZGUvY29udGVudC8yNzI2Njgv\">详细题解</span></li>\n<li>道路是双向，边权非负，航线是单向，边权可正可负，但没有自环</li>\n<li><strong>$spfa$ 会被卡掉</strong></li>\n<li>可以把只有道路的几个节点看成一个团，团内用 Dijkstra，团与团之间用拓扑序处理</li>\n<li>单源最短路 + 拓扑排序</li>\n<li>先输入所有双向道路，然后 DFS 出所有连通块，计算两个数组：<em>id</em> 存储每个点属于哪个连通块，<em>block</em> 存储每个连通块里有哪些点</li>\n<li>输入所有航线，同时统计出每个连通块的入度</li>\n<li>按照拓扑序依次处理每个连通块，先将所有入度为 $0$ 的连通块的编号加入队列中，每次从队头取出一个连通块的编号 $bid$，将该 $block[bid]$ 中的所有点加入堆中，然后对堆中所有跑 Dijkstra，每次取出堆中距离最小的点 $ver$，然后遍历 $ver$ 的所有邻点 $j$，如果 $id[ver] &#x3D; id[j]$，那么如果 $j$ 能被更新，则将 $j$ 插入堆中；如果 $id[ver] \\ne id[j]$，则将 $id[j]$ 这个连通块的入度减去 $1$ ，如果减成 $0$ 了，则将其插入拓扑排序的队列中</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 25010, M = 150010, INF = 0x3f3f3f3f;\nint n, mr, mp, S;\nint id[N];\nint h[N], e[M], w[M], ne[M], idx;\nint dist[N], din[N];\nvector&lt;int&gt; block[N];\nint bcnt;\nbool st[N];\nqueue&lt;int&gt; q;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u, int bid)&#123;\n    id[u] = bid, block[bid].push_back(u);\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!id[j]) dfs(j, bid);\n    &#125;\n&#125;\nvoid dijkstra(int bid)&#123;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;\n    for(auto u : block[bid]) pq.push(&#123;dist[u], u&#125;);\n    while(pq.size())&#123;\n        auto t = pq.top(); pq.pop();\n        int ver = t.second, distance = t.first;\n        if(st[ver]) continue;\n        st[ver] = 1;\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(id[j] != id[ver] &amp;&amp; --din[id[j]] == 0) q.push(id[j]);\n            if(dist[j] &gt; dist[ver] + w[i])&#123;\n                dist[j] = dist[ver] + w[i];\n                if(id[j] == id[ver]) pq.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nvoid topsort()&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[S] = 0;\n    for(int i = 1; i &lt;= bcnt; i++)&#123;\n        if(!din[i]) q.push(i);\n    &#125;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        dijkstra(t);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; S;\n    memset(h, -1, sizeof(h));\n    while(mr--)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c), add(b, a, c);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!id[i]) dfs(i, ++bcnt);\n    &#125;\n    while(mp--)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        din[id[b]]++;\n        add(a, b, c);\n    &#125;\n    topsort();\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(dist[i] &gt; INF / 2) cout &lt;&lt; &quot;NO PATH\\n&quot;;\n        else cout &lt;&lt; dist[i] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-最优贸易\"><a href=\"#AcWing-最优贸易\" class=\"headerlink\" title=\"AcWing|最优贸易\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQzLw==\">AcWing|最优贸易</span></h3><ul>\n<li>结合 DP 思想，枚举分界点 $k$ 分开买卖区域，分界点也可买卖<ul>\n<li>由于不是拓扑图，状态的更新可能存在环，因此不能使用动态规划，只能使用最短路的方法</li>\n<li>求 $1 \\to k$ 买入的最小值，$k \\to n$ 卖出的最大值</li>\n<li>通过取能走到 $k$ 的路中买入的最小值，求出在 $k$ 分界点前买入的最小值</li>\n<li>建反向图，求 $n \\to k$ 的路中卖出的最大值</li>\n</ul>\n</li>\n<li>能用 Dijkstra 的核心是从堆中取出的最小值一定不会在之后被更新，而此题无法保证这个条件，因此能用 Bellman-ford，迭代 $k$ 次，可以求出边数不超过 $k - 1$ 条的最短路</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10, M = 2e6 + 10;\nint w[N];\nint hs[N], he[N], e[M], ne[M], idx;\nint n, m;\nint dmin[N], dmax[N];\nbool st[N];\nvoid add(int h[], int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid spfa(int dist[], bool ok, int h[])&#123;\n    queue&lt;int&gt; q;\n    if(ok == 0)&#123;\n        memset(dist, 0x3f, sizeof(dmin));   // 注意初始化的 sizeof\n        dist[1] = w[1];\n        q.push(1);\n    &#125;else&#123;\n        memset(dist, -0x3f, sizeof(dmax));\n        dist[n] = w[n];\n        q.push(n);\n    &#125;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        st[t] = 0;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(ok == 0 &amp;&amp; dist[j] &gt; min(dist[t], w[j]) || ok == 1 &amp;&amp; dist[j] &lt; max(dist[t], w[j]))&#123;\n                dist[j] = (ok == 0 ? min(dist[t], w[j]) : max(dist[t], w[j]));\n                if(!st[j])&#123;\n                    st[j] = 1;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(hs, -1, sizeof(hs));\n    memset(he, -1, sizeof(he));\n\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        if(z == 1) add(hs, x, y), add(he, y, x);\n        else add(hs, x, y), add(he, y, x), add(hs, y, x), add(he, x, y);\n    &#125;\n    spfa(dmin, 0, hs);\n    spfa(dmax, 1, he);\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++) ans = max(ans, dmax[i] - dmin[i]);\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"单源最短路的扩展应用\"><a href=\"#单源最短路的扩展应用\" class=\"headerlink\" title=\"单源最短路的扩展应用\"></a>单源最短路的扩展应用</h2><ul>\n<li>BFS 每个点只入队一次，只出队一次。可以抽象成拓扑图，因为它可以保证被更新的点的父节点一定已经是最短距离了，并且这个点的条数已经被完全更新过了</li>\n<li>Dijkstra 每个点只出队一次。也可以抽象成拓扑图，同理由于每一个出队的点一定已经是最短距离，并且它出队的时候是队列中距离最小的点，这就代表他的最短距离条数已经被完全更新了，所以构成拓扑性质</li>\n<li>Bellman-ford 本身不具备拓扑序，因为更新它的点不一定是最短距离，所以会出错</li>\n</ul>\n<h3 id=\"AcWing-选择最佳路线\"><a href=\"#AcWing-选择最佳路线\" class=\"headerlink\" title=\"AcWing|选择最佳路线\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzOS8=\">AcWing|选择最佳路线</span></h3><ul>\n<li>可以建反向边，把终点当作起点</li>\n<li>本题采用一种适用于多个起点和多个终点的做法<ul>\n<li>假想一个虚拟源点，向每个起点连一个边权为 $0$ 的边</li>\n<li>问题转化为：从虚拟源点出发到终点的最短路径</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 1010, M = 21010, INF = 0x3f3f3f3f;\nint h[N], e[M], w[M], ne[M], idx;\nint dist[N];\nbool st[N];\nint n, m, s;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint dijkstra()&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    memset(st, 0, sizeof(st));\n    dist[0] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;\n    pq.push(&#123;0, 0&#125;);\n    while(pq.size())&#123;\n        auto [dis, ver] = pq.top(); pq.pop();\n        if(st[ver]) continue;\n        st[ver] = 1;\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &gt; dis + w[i])&#123;\n                dist[j] = dis + w[i];\n                pq.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n    if(dist[s] == INF) return -1;\n    return dist[s];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123;\n        memset(h, -1, sizeof(h));\n        idx = 0;    // 别忘了初始化 idx\n        for(int i = 1; i &lt;= m; i++)&#123;\n            int p, q, t;\n            cin &gt;&gt; p &gt;&gt; q &gt;&gt; t;\n            add(p, q, t);\n        &#125;\n        int cnt; cin &gt;&gt; cnt;\n        while(cnt--)&#123;\n            int x; cin &gt;&gt; x;\n            add(0, x, 0);\n        &#125;\n        cout &lt;&lt; dijkstra() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-拯救大兵瑞恩🌖🌖\"><a href=\"#AcWing-拯救大兵瑞恩🌖🌖\" class=\"headerlink\" title=\"AcWing|拯救大兵瑞恩🌖🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzMy8=\">AcWing|拯救大兵瑞恩</span>🌖🌖</h3><ul>\n<li><strong>拆点&#x2F;分层图</strong></li>\n<li>仿照 DP 来考虑<ul>\n<li>$d(x, y, state)$ 所有从起点走到 $(x, y)$ 这个格子，且当前已经拥有的钥匙是 $state$ 的所有路线的集合</li>\n<li>$(x, y)$ 这里有一些钥匙，那么可以直接将所有钥匙拿起，<code>state | key</code>，<code>d[x, y, state | key] = min(d[x, y, state | key], d[x, y, state])</code></li>\n<li>向上下左右四个方向走<ul>\n<li>没有门和墙</li>\n<li>有门，且有匹配的钥匙，坐标是 $(a, b)$  <code>d[a, b, state] = min(d[a b, state], d[x, y, state] + 1)</code></li>\n</ul>\n</li>\n<li>但是会出现环形依赖，所以不能用 DP 求解</li>\n</ul>\n</li>\n<li>转化成最短路问题，拿钥匙的路边权为 $0$，其他的路边权为 $1$，求 $d[n, m, 0 \\sim 2^{p - 1}]$，故可以用双端队列 BFS</li>\n<li>为了方便，将两维坐标转化成一维，墙和门直接用给的坐标建边，然后用 $set$ 存已经建的边</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 11, M = 360, P = 1 &lt;&lt; 10;\nint n, m, k, p;\nint h[N * N], e[M], w[M], ne[M], idx;\nint g[N][N], key[N * N];\nint dist[N * N][P];\nbool st[N * N][P];\nset&lt;PII&gt; edges;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid build()&#123;\n    int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            for(int u = 0; u &lt; 4; u++)&#123;\n                int x = i + dx[u], y = j + dy[u];\n                if(!x || x &gt; n || !y || y &gt; m) continue;\n                int a = g[i][j], b = g[x][y];\n                if(!edges.count(&#123;a, b&#125;)) add(a, b, 0);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n// 双端队列 BFS 处理最短路\nint bfs()&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1][0] = 0;\n    deque&lt;PII&gt; q;\n    q.push_back(&#123;1, 0&#125;);\n    while(q.size())&#123;\n        auto [ver, now] = q.front(); q.pop_front();\n        if(st[ver][now]) continue;\n        st[ver][now] = 1;\n        if(ver == n * m) return dist[ver][now];\n        if(key[ver])&#123;\n            int state = now | key[ver];\n            if(dist[ver][state] &gt; dist[ver][now])&#123;\n                dist[ver][state] = dist[ver][now];\n                q.push_back(&#123;ver, state&#125;);\n            &#125;\n        &#125;\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(w[i] &amp;&amp; !(now &gt;&gt; w[i] - 1 &amp; 1)) continue;\n            if(dist[j][now] &gt; dist[ver][now] + 1)&#123;\n                dist[j][now] = dist[ver][now] + 1;\n                q.push_back(&#123;j, now&#125;);\n            &#125;\n        &#125;\n    &#125;\n    return -1;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;\n    for(int i = 1, t = 1; i &lt;= n; i++)&#123;     // 一维化\n        for(int j = 1; j &lt;= m; j++)&#123;\n            g[i][j] = t++;\n        &#125;\n    &#125;\n    memset(h, -1, sizeof(h));\n    while(k--)&#123;     // 处理门和墙\n        int x1, y1, x2, y2, c;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;\n        int a = g[x1][y1], b = g[x2][y2];\n        edges.insert(&#123;a, b&#125;), edges.insert(&#123;b, a&#125;);\n        if(c) add(a, b, c), add(b, a, c);\n    &#125;\n    build();    // 建立普通通道\n    int s; cin &gt;&gt; s;\n    while(s--)&#123;     // 状态压缩表示钥匙状态，向左偏移1，从0开始\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        key[g[x][y]] |= 1 &lt;&lt; c - 1;\n    &#125;\n    cout &lt;&lt; bfs() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-最短路计数🌸\"><a href=\"#AcWing-最短路计数🌸\" class=\"headerlink\" title=\"AcWing|最短路计数🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEzNi8=\">AcWing|最短路计数</span>🌸</h3><ul>\n<li><strong>证明待看</strong></li>\n<li>求方案数<ul>\n<li>可以类比 DP 求方案数</li>\n<li>$dist[i]$ 表示到 $i$ 点的最短路，$cnt[i]$ 表示到 $i$ 点的最短路数量</li>\n</ul>\n</li>\n<li>如何让最短路问题转化成拓扑序–最短路树（拓扑图）<ul>\n<li>存下前驱点</li>\n<li>规定一个点只能被一个前驱更新</li>\n<li>每个点只入队一次</li>\n</ul>\n</li>\n<li>假如图中存在负权边，可以使用 spfa 求出最短路径，然后再把最短路径树建出来，最后在这棵树上统计最短路径数</li>\n<li>本题边权全为 $1$，使用 BFS 即可，对于某个点，如果能更新其距离，则更新，并将这个点的条数变成上一点对应的条数；如果说距离相等的话，距离不用更新，条数累加起来</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10, M = 4e5 + 10, MOD = 100003;\nint h[N], e[M], ne[M], idx;\nint dist[N], cnt[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid bfs()&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    queue&lt;int&gt; q;\n    dist[1] = 0;\n    cnt[1] = 1;\n    q.push(1);\n    while(q.size())&#123;\n        int u = q.front(); q.pop();\n        for(int i = h[u]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &gt; dist[u] + 1)&#123;\n                dist[j] = dist[u] + 1;\n                cnt[j] = cnt[u];\n                q.push(j);\n            &#125;else if(dist[j] == dist[u] + 1)&#123;\n                cnt[j] = (cnt[j] + cnt[u]) % MOD;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    while(m--)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b); add(b, a);\n    &#125;\n    bfs();\n    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; cnt[i] &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-观光🌸\"><a href=\"#AcWing-观光🌸\" class=\"headerlink\" title=\"AcWing|观光🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzg1Lw==\">AcWing|观光</span>🌸</h3><ul>\n<li><strong>证明待看</strong></li>\n<li>求最短路径的条数，和次短路径的条数，如果次短路径长度恰好比最短路径多一，则加上次短路径的条数</li>\n<li>$dist[i, 0&#x2F;1]$ 表示从 $1$ 到 $i$ 的最短路径&#x2F;次短路径，全部初始化为正无穷，初始时起点不存在次短路</li>\n<li>Dijkstra 枚举城市 $t$ 可通往的城市 $j$ 时，有四种情况<ul>\n<li>$dist[j][0] &gt; dist[t][type] + w[i]$ ：当前最短路变成次短路，更新最短路，将最短路和次短路加入优先队列</li>\n<li>$dist[j][0] &#x3D; dist[t][type] + w[i]$ ：找到一条新的最短路，更新最短路条数</li>\n<li>$dist[j][1] &gt; dist[t][type] + w[i]$ ：找到一条更短的次短路，覆盖掉当前次短路，加入优先队列</li>\n<li>$dist[j][1] &#x3D; dist[t][type] + w[i]$ ：找到一条新的次短路，更新次短路条数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010, M = 10010;\ntypedef tuple&lt;int, int, int&gt; TIII;\nint h[N], e[M], ne[M], w[M], idx;\nint dist[N][2], cnt[N][2];\nbool st[N][2];\nint n, m, S, F;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;\n&#125;\nint dijkstra()&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    memset(cnt, 0, sizeof(cnt));\n    memset(st, 0, sizeof(st));\n    priority_queue&lt;TIII, vector&lt;TIII&gt;, greater&lt;TIII&gt;&gt; pq;\n    dist[S][0] = 0;\n    cnt[S][0] = 1;\n    pq.push(&#123;0, 0, S&#125;);\n    while(pq.size())&#123;\n        auto [dis1, type, ver] = pq.top(); pq.pop();\n        if(st[ver][type]) continue;\n        st[ver][type] = true;\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j][0] &gt; dis1 + w[i])&#123;\n                dist[j][1] = dist[j][0], cnt[j][1] = cnt[j][0];\n                pq.push(&#123;dist[j][1], 1, j&#125;);\n                dist[j][0] = dis1 + w[i], cnt[j][0] = cnt[ver][type];\n                pq.push(&#123;dist[j][0], 0, j&#125;);\n            &#125;else if(dist[j][0] == dis1 + w[i])&#123;\n                cnt[j][0] = (cnt[j][0] + cnt[ver][type]);\n                pq.push(&#123;dist[j][0], 0, j&#125;);\n            &#125;else if(dist[j][1] &gt; dis1 + w[i])&#123;\n                dist[j][1] = dis1 + w[i], cnt[j][1] = cnt[ver][type];\n                pq.push(&#123;dist[j][1], 1, j&#125;);\n            &#125;else if(dist[j][1] == dis1 + w[i])&#123;\n                cnt[j][1] = (cnt[j][1] + cnt[ver][type]);\n                pq.push(&#123;dist[j][1], 1, j&#125;);\n            &#125;\n        &#125;\n    &#125;\n    int ans = cnt[F][0];\n    if(dist[F][1] == dist[F][0] + 1) ans += cnt[F][1];\n    return ans;\n&#125;\nvoid solve()&#123;\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b, c; \n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    &#125;\n    cin &gt;&gt; S &gt;&gt; F;\n    cout &lt;&lt; dijkstra() &lt;&lt; &#39;\\n&#39;;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"Floyd-算法\"><a href=\"#Floyd-算法\" class=\"headerlink\" title=\"Floyd 算法\"></a>Floyd 算法</h2><ul>\n<li>应用<ul>\n<li>最短路</li>\n<li>传递闭包</li>\n<li>找最小环（一般是正权）</li>\n<li>恰好经过 $k$ 条边的最短路（倍增）</li>\n</ul>\n</li>\n<li>原理<ul>\n<li>基于 DP</li>\n<li>状态表示 $d[k, i, j]$<ul>\n<li>集合：所有从 $i$ 出发，最终走到 $j$，且中间只经过节点编号不超过 $k$ 的所有路径</li>\n<li>属性：路径长度的最小值</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>分为两类，所有不包含节点 $k$ 的路径和所有包含节点 $k$ 的路径</li>\n<li>因为 $i \\to k$ 与 $k \\to j$ 无关，所以只需要前两者都为最小值，即为最短路</li>\n<li><code>d[k][i][j] = min (d[k][i][j], d[k - 1][i][k] + d[k - 1][k][j])</code></li>\n<li>所有的 $d[i, k], d[k][i][k] &#x3D; d[k - 1][i][k]$，所以可以少一维</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-牛的旅行\"><a href=\"#AcWing-牛的旅行\" class=\"headerlink\" title=\"AcWing|牛的旅行\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyNy8=\">AcWing|牛的旅行</span></h3><ul>\n<li>分析<ul>\n<li>新的连通块的直径一定 $\\ge$ 所有连通块直径的最大值</li>\n<li>经过新边的最长路径</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>用 $Floyd$ 求出任意两点之间的最短距离</li>\n<li>求 $maxd[i]$，表示和 $i$ 连通的且距离 $i$ 最远的点的距离</li>\n<li>情况 1：所有 $maxd[i]$ 的最大值</li>\n<li>情况 2：枚举在哪两个点之间连边，$(i, j)$，满足 $d[i, j] &#x3D; INF$，$maxd[i] + dist[i, j] + maxd[j]$</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 160;\nconst double INF = 1e20;\nPII p[N];\ndouble dist[N][N], maxd[N];\nstring g[N];\ndouble get_dist(PII a, PII b)&#123;\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n; cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n    \n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            if(i != j)&#123;\n                if(g[i][j] == &#39;1&#39;) dist[i][j] = get_dist(p[i], p[j]);\n                else dist[i][j] = INF;\n            &#125;\n        &#125;\n    &#125;\n    for(int k = 0; k &lt; n; k++)&#123;\n        for(int i = 0; i &lt; n; i++)&#123;\n            for(int j = 0; j &lt; n; j++)&#123;\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            &#125;\n        &#125;\n    &#125;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            if(dist[i][j] &lt; INF) maxd[i] = max(maxd[i], dist[i][j]);\n        &#125;\n    &#125;\n    double res = 0;\n    for(int i = 0; i &lt; n; i++) res = max(res, maxd[i]);\n    double ans = INF;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            if(dist[i][j] &gt;= INF) ans = min(ans, get_dist(p[i], p[j]) + maxd[i] + maxd[j]);\n        &#125;\n    &#125;\n    cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; max(res, ans) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-排序🌸\"><a href=\"#AcWing-排序🌸\" class=\"headerlink\" title=\"AcWing|排序🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ1Lw==\">AcWing|排序</span>🌸</h3><ul>\n<li>传递闭包<ul>\n<li>间接能到达的点都连一条直接的边</li>\n</ul>\n</li>\n<li>初始化 $d[i, j] &#x3D; g[i, j]$, $1$ 表示有边，$0$ 表示没有边</li>\n<li>Floyd 求传递闭包<ul>\n<li>$A &lt; B$ 即 $d[A, B] &#x3D; 1$</li>\n<li>矛盾，即 $d (i, i) &#x3D; 1$</li>\n<li>唯一确定，即 $i \\ne j, d (i, j), d (j, i)$ 必有一个是 $1$<ul>\n<li>排序，将所有点按照能到达的点数从小到大排序，然后依次输出编号</li>\n</ul>\n</li>\n<li>顺序不唯一</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 30;\nbool g[N][N], d[N][N];\nbool st[N];\nint n, m;\nvoid floyd()&#123;\n    memcpy(d, g, sizeof(g));\n    for(int k = 0; k &lt; n; k++)&#123;\n        for(int i = 0; i &lt; n; i++)&#123;\n            for(int j = 0; j &lt; n; j++)&#123;\n                d[i][j] |= d[i][k] &amp;&amp; d[k][j];\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint check()&#123;\n    for(int i = 0; i &lt; n; i++)&#123;\n        if(d[i][i]) return 2;\n    &#125;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; i; j++)&#123;\n            if(!d[i][j] &amp;&amp; !d[j][i]) return 0;\n        &#125;\n    &#125;\n    return 1;\n&#125;\nchar get_min()&#123;\n    for(int i = 0; i &lt; n; i++)&#123;\n        if(!st[i])&#123;\n            bool flag = 1;\n            for(int j = 0; j &lt; n; j++)&#123;\n                if(d[j][i] &amp;&amp; !st[j])&#123;\n                    flag = 0;\n                    break;\n                &#125;\n            &#125;\n            if(flag)&#123;\n                st[i] = 1;\n                return &#39;A&#39; + i;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    while(cin &gt;&gt; n &gt;&gt; m, n || m)&#123;\n        memset(g, 0, sizeof(g));\n        int type = 0, t;\n        for(int i = 1; i &lt;= m; i++)&#123;\n            string s; cin &gt;&gt; s;\n            int a = s[0] - &#39;A&#39;, b = s[2] - &#39;A&#39;;\n            if(!type)&#123;\n                g[a][b] = 1;\n                floyd();\n                type = check();\n                if(type) t = i;\n            &#125;\n        &#125;\n        if(!type) cout &lt;&lt; &quot;Sorted sequence cannot be determined.\\n&quot;;\n        else if(type == 2) cout &lt;&lt; &quot;Inconsistency found after &quot; &lt;&lt; t &lt;&lt; &quot; relations.\\n&quot;;\n        else &#123;\n            memset(st, 0, sizeof(st));\n            cout &lt;&lt; &quot;Sorted sequence determined after &quot; &lt;&lt; t &lt;&lt; &quot; relations: &quot;;\n            for(int i = 0; i &lt; n; i++)&#123;\n                cout &lt;&lt; get_min();\n            &#125;\n            cout &lt;&lt; &quot;.\\n&quot;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>本题可以优化每次加入的新边，但是需要注意<strong>传递</strong></li>\n</ul>\n<pre><code class=\"cpp\">memset(d, 0, sizeof(d));\nint type = 0, t;\nfor(int i = 1; i &lt;= m; i++)&#123;\n    string s; cin &gt;&gt; s;\n    int a = s[0] - &#39;A&#39;, b = s[2] - &#39;A&#39;;\n    if(!type)&#123;\n        d[a][b] = 1;\n        //floyd();\n        for(int x = 0; x &lt; n; x++)&#123;\n            if(d[b][x]) d[a][x] = 1;\n            if(d[x][a]) d[x][b] = 1;\n            for(int y = 0; y &lt; n; y++)&#123;\n                if(d[x][a] &amp;&amp; d[b][y])&#123;\n                    d[x][y] = 1;\n                &#125;\n            &#125;\n        &#125;\n        type = check();\n        if(type) t = i;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-观光之旅🌸\"><a href=\"#AcWing-观光之旅🌸\" class=\"headerlink\" title=\"AcWing|观光之旅🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ2Lw==\">AcWing|观光之旅</span>🌸</h3><ul>\n<li>Floyd 求最小环，设环的形式是 $i \\longleftrightarrow k \\longleftrightarrow j$，Floyd 是典型的插点算法，每次插入点 $k$，因此，在点 $k$ 插入前可以计算这个环，我们只需要枚举所有以 $k$ 为环中的最大节点的环即可</li>\n<li>用集合思考，按环上的最大编号来分类</li>\n<li>$pos[i, j]$ 即 $i \\longleftrightarrow j$ 的最短路中经过的点是 $k$ （即由这个状态转移过来），且这个 $k$ 是此路径中编号最大的点</li>\n<li>性质<ul>\n<li>在 $i \\longleftrightarrow j$ 的最短路中，一定没有环</li>\n<li>这三个点之间的两条最短路必然没有交集</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 110;\nint d[N][N], g[N][N];\nint path[N], pos[N][N], cnt;\nvoid get_path(int i, int j)&#123;\n    if(pos[i][j] == 0) return ;\n    int k = pos[i][j];\n    get_path(i, k);\n    path[cnt++] = k;\n    get_path(k, j);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(g, 0x3f, sizeof(g));\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int u, v, l;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; l;\n        g[u][v] = g[v][u] = min(g[u][v], l);\n    &#125;\n    memcpy(d, g, sizeof(d));\n    int ans = 0x3f3f3f3f;\n    for(int k = 1; k &lt;= n; k++)&#123;\n        for(int i = 1; i &lt; k; i++)&#123;\n            for(int j = i + 1; j &lt; k; j++)&#123;\n                if((LL)d[i][j] + g[i][k] + g[k][j] &lt; ans)&#123;\n                    ans = d[i][j] + g[i][k] + g[k][j];\n                    cnt = 0;\n                    path[cnt++] = k;\n                    path[cnt++] = i;\n                    get_path(i, j);\n                    path[cnt++] = j;\n                &#125;\n            &#125;\n        &#125;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            for(int j = 1; j &lt;= n; j++)&#123;\n                if(d[i][j] &gt; d[i][k] + d[k][j])&#123;\n                    d[i][j] = d[i][k] + d[k][j];\n                    pos[i][j] = k;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if(ans == 0x3f3f3f3f) cout &lt;&lt; &quot;No solution.\\n&quot;;\n    else&#123;\n        for(int i = 0; i &lt; cnt; i++) cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;\n        cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-牛站🌖\"><a href=\"#AcWing-牛站🌖\" class=\"headerlink\" title=\"AcWing|牛站🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ3Lw==\">AcWing|牛站</span>🌖</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzM2NjAzLw==\">AcWing 345. 牛站(通俗图解版) - AcWing</span></li>\n<li>Floyd 的倍增应用<ul>\n<li>原本的状态表示 $d[k, i, j]$ 表示从 $i$ 到 $j$ 只经过 $1 \\sim k$ 的话，最短路径是多少</li>\n<li>本题的状态表示 $d[k, i, j]$ 表示从 $i$ 到 $j$，恰好经过 $k$ 条边的最短路径</li>\n<li>$d[a + b, i, j] &#x3D; min(d[a, i, k] + d[b, k, j])$ 其中 $k &#x3D; 1 \\sim n$，前后两段最短路无关</li>\n<li>之后发现每一段的顺序都不影响最终答案，具有结合律，因此可以使用快速幂&#x2F;倍增的思想</li>\n</ul>\n</li>\n<li>本题需要离散化</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint N, T, S, E, n;\nmap&lt;int, int&gt; ids;\nint g[1010][1010], ans[1010][1010];\nvoid floyd(int a[][1010], int b[][1010], int c[][1010])&#123;\n    static int tmp[1010][1010]; // b 和 c 相乘的结果\n    memset(tmp, 0x3f, sizeof(tmp));\n    for(int k = 1; k &lt;= n; k++)&#123;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            for(int j = 1; j &lt;= n; j++)&#123;\n                tmp[i][j] = min(tmp[i][j], b[i][k] + c[k][j]);\n            &#125;\n        &#125;\n    &#125;\n    memcpy(a, tmp, sizeof(tmp));\n&#125;\nvoid qmi()&#123;\n    memset(ans, 0x3f, sizeof(ans));\n    for(int i = 1; i &lt;= n; i++) ans[i][i] = 0;\n    while(N)&#123;\n        if(N &amp; 1) floyd(ans, ans, g);\n        floyd(g, g, g);\n        N &gt;&gt;= 1;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; N &gt;&gt; T &gt;&gt; S &gt;&gt; E;\n    memset(g, 0x3f, sizeof(g));\n\n    ids[S] = ++n, ids[E] = ++n;\n    S = ids[S], E = ids[E];\n    \n    for(int i = 1; i &lt;= T; i++)&#123;\n        int c, a, b;\n        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;\n        if(!ids.count(a)) ids[a] = ++n;\n        if(!ids.count(b)) ids[b] = ++n;\n        a = ids[a], b = ids[b];\n        g[a][b] = g[b][a] = min(g[a][b], c);\n    &#125;\n    qmi();\n    cout &lt;&lt; ans[S][E] &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h2><ul>\n<li>Prim <ul>\n<li>朴素版 $O(n^2)$\t–邻接矩阵</li>\n<li>堆优化 <del>被 Kruskal 完爆</del></li>\n<li>证明：当前与外界直接相连的权值最小的一条边，这条边一定可以出现在最优解中<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaXdpa2kub3JnL2dyYXBoL21zdC8jXzY=\">OI Wiki|数学归纳法</span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Kruskal<ul>\n<li>$O(mlogn)$，直接存边，三元组</li>\n<li>并查集维护</li>\n<li>证明<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaXdpa2kub3JnL2dyYXBoL21zdC8jXzQ=\">OI Wiki|数学归纳法</span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>反证法<ul>\n<li>假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会出现一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-最短网络\"><a href=\"#AcWing-最短网络\" class=\"headerlink\" title=\"AcWing|最短网络\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0Mi8=\">AcWing|最短网络</span></h3><ul>\n<li>模板题</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\nint w[N][N], dist[N];\nbool st[N];\nint n;\nint prim()&#123;\n    int ans = 0;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    for(int i = 0; i &lt; n; i++)&#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j;\n        &#125;\n        st[t] = 1;\n        ans += dist[t];\n        for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], w[t][j]);\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            cin &gt;&gt; w[i][j];\n        &#125;\n    &#125;\n    cout &lt;&lt; prim() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-局域网\"><a href=\"#AcWing-局域网\" class=\"headerlink\" title=\"AcWing|局域网\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0My8=\">AcWing|局域网</span></h3><ul>\n<li>相当于在这个图的每个连通块内，求一棵最小生成树</li>\n<li>Prim 一次只能处理一个连通块，所以使用 Kruskal</li>\n<li>将所有边权从小到大排序</li>\n<li>依次枚举每条边 $a, b, w$，如果 $a, b$ 不连通，那么就将当前边加到最小生成树中</li>\n<li>就算没有完成全部的生成树，中间过程已完成的部分也是正确的；从某一段开始做 Kruskal ，也是正确的</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef tuple&lt;int, int, int&gt; TIII;\nconst int N = 110, M = 210;\nTIII e[M];\nint p[N];\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, k; cin &gt;&gt; n &gt;&gt; k;\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n    for(int i = 1; i &lt;= k; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        e[i] = &#123;c, a, b&#125;;\n    &#125;\n    sort(e + 1, e + 1 + k);\n    int ans = 0;\n    for(int i = 1; i &lt;= k; i++)&#123;\n        auto [c, a, b] = e[i];\n        int x = find(a), y = find(b);\n        if(x != y) p[x] = y;\n        else ans += c;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-繁忙的都市\"><a href=\"#AcWing-繁忙的都市\" class=\"headerlink\" title=\"AcWing|繁忙的都市\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0NC8=\">AcWing|繁忙的都市</span></h3><ul>\n<li>Prim 和 Kruskal 都需要是无向边</li>\n<li>本题中的最小生成树求的是边权最大值最小，即 <strong>瓶颈生成树</strong></li>\n<li>题解<ul>\n<li>将所有边从小到大排序</li>\n<li>从小到大依次枚举每条边，$a, b, w$<ul>\n<li>如果 $a$ 和 $b$ 已经连通，直接跳过</li>\n<li>如果 $a$ 和 $b$ 不连通，就将当前边选出来</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef tuple&lt;int, int, int&gt; TIII;\nconst int N = 310, M = 10010;\nTIII g[M];\nint p[N];\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int u, v, c;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;\n        g[i] = &#123;c, u, v&#125;;\n    &#125;\n    sort(g + 1, g + 1 + m);\n    int ans, cnt = 0;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        auto [c, u, v] = g[i];\n        int x = find(u), y = find(v);\n        if(x != y)&#123;\n            p[x] = y;\n            cnt++;\n            ans = c;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; &#39; &#39; &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-联络员\"><a href=\"#AcWing-联络员\" class=\"headerlink\" title=\"AcWing|联络员\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0NS8=\">AcWing|联络员</span></h3><ul>\n<li>必须要连的边先连在一起，当成一个连通块，求各个连通块的最小生成树</li>\n<li>本题不需要缩点</li>\n<li>题解<ul>\n<li>将所有必选边加到并查集中</li>\n<li>将所有非必选边从小到大排序</li>\n<li>从小到大依次枚举每一条非必选边<ul>\n<li>如果 $a$ 和 $b$ 已经连通，直接跳过</li>\n<li>如果 $a$ 和 $b$ 不连通，就将当前边选出来</li>\n</ul>\n</li>\n<li>并查集的祖宗节点即可看成小连通块的编号，可以看作缩点</li>\n<li>在有一定边的基础上做 Kruskal 一样可以求出最小生成树</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef tuple&lt;int, int, int&gt; TIII;\nconst int N = 2010, M = 10010;\nTIII g[M];\nint p[N];\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    int ans = 0, cnt = 0;\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int type, u, v, w;\n        cin &gt;&gt; type &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        if(type == 1)&#123;\n            p[find(u)] = find(v);\n            ans += w;\n        &#125;else&#123;\n            g[++cnt] = &#123;w, u, v&#125;;\n        &#125;\n    &#125;\n    sort(g + 1, g + 1 + cnt);\n    for(int i = 1; i &lt;= cnt; i++)&#123;\n        auto [w, u, v] = g[i];\n        int x = find(u), y = find(v);\n        if(x != y)&#123;\n            p[x] = y;\n            ans += w;\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-连接格点🌸\"><a href=\"#AcWing-连接格点🌸\" class=\"headerlink\" title=\"AcWing|连接格点🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0Ni8=\">AcWing|连接格点</span>🌸</h3><ul>\n<li>每多一条边，花费肯定更多，一共 $n \\times m$ 个点，我们最少需要连 $nm - 1$ 条边，转化成最小生成树问题</li>\n<li>其他同上一题</li>\n<li>假如时限紧或者边很多的情况下，由于边权只有 $1$ 和 $2$，可以先建竖向的边再建横向的边，可以减少排序消耗的时间</li>\n<li>将二维转化成一维</li>\n<li>不用特判边是否已经存在，并查集会解决</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef tuple&lt;int, int, int&gt; TIII;\nconst int N = 1010, M = 1e7 + 10;\nint idx[N][N], p[M];\nTIII e[M];\nint n, m, cnt = 0;\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nvoid get_edges()&#123;\n    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;, dw[4] = &#123;1, 2, 1, 2&#125;;\n    for(int z = 0; z &lt; 2; z++)&#123;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            for(int j = 1; j &lt;= m; j++)&#123;\n                for(int k = 0; k &lt; 4; k++)&#123;\n                    if(k % 2 == z)&#123;\n                        int nx = i + dx[k], ny = j + dy[k], w = dw[k];\n                        if(nx &amp;&amp; nx &lt;= n &amp;&amp; ny &amp;&amp; ny &lt;= m)&#123;\n                            int x = idx[i][j], y = idx[nx][ny];\n                            if(x &lt; y) e[++cnt] = &#123;w, x, y&#125;;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n * m; i++) p[i] = i;\n    for(int i = 1, t = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++, t++)&#123;\n            idx[i][j] = t;\n        &#125;\n    &#125;\n    int x1, y1, x2, y2;\n    while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)&#123;\n        int x = idx[x1][y1], y = idx[x2][y2];\n        p[find(x)] = find(y);\n    &#125;\n    get_edges();\n    int ans = 0;\n    for(int i = 1; i &lt;= cnt; i++)&#123;\n        auto [w, x, y] = e[i];\n        x = find(x), y = find(y);\n        if(x != y)&#123;\n            p[x] = y;\n            ans += w;\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"最小生成树的扩展应用\"><a href=\"#最小生成树的扩展应用\" class=\"headerlink\" title=\"最小生成树的扩展应用\"></a>最小生成树的扩展应用</h2><ul>\n<li>最小生成树的理论基础<ul>\n<li>任意一棵最小生成树一定可以包含无向图中权值最小的边</li>\n<li>给定一张无向图 $G &#x3D; (V, E), n &#x3D; |V|, m &#x3D; |E|$，从 $E$ 中选出 $k &lt; n - 1$ 条边构成 $G$ 的加一个生成森林。若再从剩余的 $m - k$ 条边中选 $n - 1 - k$ 条边添加到生成森林中，使其成为 $G$ 的生成树，并且选出的边的权值之和最小。则该生成树一定<strong>可以</strong>包含 $m - k$ 条边中连接生成森林的两个不连通节点的权值最小的边</li>\n</ul>\n</li>\n<li>次小生成树<ul>\n<li>定义：给一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树，权值严格大于最小生成树</li>\n<li>方法<ol>\n<li>先求最小生成树，再枚举删去最小生成树中的边求解，时间复杂度 $O(mlogm + nm)$，只能求非严格次小生成树</li>\n<li>先求最小生成树，依次枚举非树边，然后将该边加入树中，同时从树中去掉一条边，使得最终的图仍是一棵树，则一定可以求出次小生成树，去掉的边是新边两端点间原路径上边权最大的边</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>设 $T$ 为图 $G$ 的一棵生成树，对于非树边 $a$ 和树边 $b$，插入边 $a$，并删除边 $b$ 的操作记为 $(+a, -b)$。如果 $T + a - b$ 之后，仍然是一棵生成树，称 $(+a, -b)$ 是 $T$ 的一个可行交换</li>\n<li>称由 $T$ 进行一次可行变换所得到的新的生成树的集合称为 $T$ 的邻集</li>\n<li>定理：次小生成树一定在最小生成树的邻集中</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS92aWRlby81Mzcv\">相关证明-3.3.2 最小生成树的扩展应用 - AcWing</span></li>\n</ul>\n<h3 id=\"AcWing-新的开始\"><a href=\"#AcWing-新的开始\" class=\"headerlink\" title=\"AcWing|新的开始\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0OC8=\">AcWing|新的开始</span></h3><ul>\n<li>构建虚拟源点，<del>超级发电站</del>，其到每个发电站的边权都是 $v_i$，每个矿井都需要和超级发电站连通，因此可以转化成最小生成树问题</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 310;\nint w[N][N], dist[N];\nint n;\nbool st[N];\nint prim()&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[0] = 0;\n    int ans = 0;\n    for(int i = 0; i &lt; n + 1; i++)&#123;\n        int t = -1;\n        for(int j = 0; j &lt;= n; j++)&#123;\n            if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;\n        &#125;\n        st[t] = 1;\n        ans += dist[t];\n        for(int j = 0; j &lt;= n; j++) dist[j] = min(dist[j], w[t][j]);\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; w[0][i];\n        w[i][0] = w[0][i];\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            cin &gt;&gt; w[i][j];\n        &#125;\n    &#125;\n    cout &lt;&lt; prim() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-北极通讯网络\"><a href=\"#AcWing-北极通讯网络\" class=\"headerlink\" title=\"AcWing|北极通讯网络\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE0Ny8=\">AcWing|北极通讯网络</span></h3><ul>\n<li>相当于找一个最小的 $d$ 值，使得将所有权值大于 $d$ 的边删去之后，整个图形的连通块的个数不超过 $k$，每一个连通块需要一个卫星设备</li>\n<li>Kruskal 刚好可以求出 $k$ 个连通块时的结果，不需要用二分来求</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef tuple&lt;double, int, int&gt; TDII;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 510, M = N * N / 2;\nPII q[N];\nTDII edges[M];\nint p[N];\nint n, k, m;\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\ndouble get_dist(PII a, PII b)&#123;\n    int dx = a.first - b.first;\n    int dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2);\n    cin &gt;&gt; n &gt;&gt; k;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        p[i] = i;\n        cin &gt;&gt; q[i].first &gt;&gt; q[i].second;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt; i; j++)&#123;\n            edges[++m] = &#123;get_dist(q[i], q[j]), i, j&#125;;\n        &#125;\n    &#125;\n    sort(edges + 1, edges + 1 + m);\n    int cnt = n;\n    double ans;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        if(cnt &lt;= k) break;\n        auto [w, a, b] = edges[i];\n        a = find(a), b = find(b);\n        if(a != b)&#123;\n            p[a] = b;\n            cnt--;\n            ans = w;\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-走廊泼水节\"><a href=\"#AcWing-走廊泼水节\" class=\"headerlink\" title=\"AcWing|走廊泼水节\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzQ4Lw==\">AcWing|走廊泼水节</span></h3><ul>\n<li>完全图，即任意两个点都可以直达</li>\n<li>按边权从小到大排序，每次合并新加入那条边的两个集合，构造一棵最小生成树，因为不能破坏最小生成树，所以构成完全图的其他边需要大于等于当前连接两个连通块的边权，所以都可以取 $w_i + 1$</li>\n<li>假设 $S_x$ 连通块有 $p$ 个元素，$S_y$ 连通块有 $q$ 个元素，那么新加边的权值是 $(w + 1) \\times (p \\times q - 1)$</li>\n<li>维护 $size$ 的并查集</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef tuple&lt;double, int, int&gt; TDII;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 6010;\nTDII e[N];\nint p[N], cnt[N];\nint find(int x)&#123;\n    if(x != p[x]) p[x] = find(p[x]);\n    return p[x];\n&#125;\nvoid solve()&#123;\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n - 1; i++)&#123;\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        e[i] = &#123;z, x, y&#125;;\n    &#125;\n    sort(e + 1, e + 1 + n - 1);\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        p[i] = i;\n        cnt[i] = 1;\n    &#125;\n    for(int i = 1; i &lt;= n - 1; i++)&#123;\n        auto [w, a, b] = e[i];\n        a = find(a), b = find(b);\n        if(a != b)&#123;\n            p[a] = b;\n            ans += (cnt[b] * cnt[a] - 1) * (w + 1);\n            cnt[b] += cnt[a];\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h3 id=\"AcWing-秘密的牛奶运输🌖\"><a href=\"#AcWing-秘密的牛奶运输🌖\" class=\"headerlink\" title=\"AcWing|秘密的牛奶运输🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE1MC8=\">AcWing|秘密的牛奶运输</span>🌖</h3><ul>\n<li>次小生成树，这里使用朴素做法<ul>\n<li><strong>定理：</strong> 对于一张无向图，如果存在最小生成树和（严格）次小生成树，那么对于任何一棵最小生成树，都存在一棵（严格）次小生成树，使得这两棵树只有一条边不同。</li>\n</ul>\n</li>\n<li>先用 Kruskal 处理出最小生成树，同时建边并标记哪些点不是树上的点</li>\n<li>使用 $dfs$ 预处理出 $d$ 和 $dist2[a][b]$ 分别表示树上 $a$ 到 $b$ 的最大值和次大值（防止与树外边权相同从而找出非严格次小生成树）<ul>\n<li>第二步 $dfs$ 处理的时候应该考虑负权边，因此最大值和次大值的初值都应该为 <code>-1e9</code></li>\n</ul>\n</li>\n<li>枚举每一个 $sum+w-dist[i][j]$ 求最小值</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1010, M = 10010;\nstruct Edge&#123;\n    int a, b, w;\n    bool is_tree;\n    bool operator &lt; (const Edge &amp;e) const&#123;\n        return w &lt; e.w;\n    &#125;\n&#125;edge[M];\nint n, m;\nint p[N], dist1[N][N], dist2[N][N]; // 最小值，次小值\nint h[N], e[M * 2], ne[M * 2], w[M * 2], idx;\nint find(int x)&#123;\n    if(x != p[x]) p[x] = find(p[x]);\n    return p[x];\n&#125;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u, int fa, int maxn, int maxv, int dist1[], int dist2[])&#123;\n    dist1[u] = maxn, dist2[u] = maxv;\n    for(int i = h[u]; i != -1; i = ne[i])&#123;\n        int j = e[i];\n        if(j != fa)&#123;\n            if(w[i] &gt; maxn) dfs(j, u, w[i], maxn, dist1, dist2);\n            else if(w[i] &lt; maxn &amp;&amp; w[i] &gt; maxv) dfs(j, u, maxn, w[i], dist1, dist2);\n            else dfs(j, u, maxn, maxv, dist1, dist2);\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        cin &gt;&gt; edge[i].a &gt;&gt; edge[i].b &gt;&gt; edge[i].w;\n    &#125;\n    sort(edge + 1, edge + 1 + m);\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n    LL sum = 0;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        auto&amp; [a, b, w, f] = edge[i];\n        int pa = find(a), pb = find(b);\n        if(pa != pb)&#123;\n            p[pa] = pb;\n            sum += w;\n            f = 1;\n            add(a, b, w), add(b, a, w);\n        &#125;\n    &#125;\n    // dfs处理树上任意两点的最大值和次大值\n    for(int i = 1; i &lt;= n; i++)&#123;\n        dfs(i, -1, -1e9, -1e9, dist1[i], dist2[i]);\n    &#125;\n    LL ans = 1e18;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        auto &amp;[a, b, w, f] = edge[i];\n        if(!f)&#123;\n            if(w &gt; dist1[a][b]) ans = min(ans, sum + w - dist1[a][b]);\n            else if(w &gt; dist2[a][b]) ans = min(ans, sum + w - dist2[a][b]);\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"负环\"><a href=\"#负环\" class=\"headerlink\" title=\"负环\"></a>负环</h2><ul>\n<li>01 分数规划通常和负环结合一起</li>\n<li>求负环得常用方法，基于 SPFA<ul>\n<li>统计每个点入队的次数，如果某个点入队 $n$ 次，则说明存在负环</li>\n<li>统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于 $n$，则也说明存在环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-虫洞\"><a href=\"#AcWing-虫洞\" class=\"headerlink\" title=\"AcWing|虫洞\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTA2Lw==\">AcWing|虫洞</span></h3><ul>\n<li>spfa 求负环，板子题</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 510, M = 5210;\nint n, m1, m2;\nint h[N], e[M], w[M], ne[M], idx;\nint dist[N], cnt[N];\nbool st[N];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool spfa()&#123;\n    //memset(dist, 0, sizeof(dist));\n    //可以不用初始化\n    memset(cnt, 0, sizeof(cnt));\n    queue&lt;int&gt; q;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        q.push(i);\n        st[i] = true;\n    &#125;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &gt; dist[t] + w[i])&#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if(cnt[j] &gt;= n) return 1;\n                if(!st[j])&#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid solve()&#123;\n    memset(h, -1, sizeof(h));\n    idx = 0;\n    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;\n    for(int i = 1; i &lt;= m1; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c); add(b, a, c);\n    &#125;\n    for(int i = 1; i &lt;= m2; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, -c);\n    &#125;\n    if(spfa()) cout &lt;&lt; &quot;YES\\n&quot;;\n    else cout &lt;&lt; &quot;NO\\n&quot;;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h3 id=\"AcWing-观光奶牛\"><a href=\"#AcWing-观光奶牛\" class=\"headerlink\" title=\"AcWing|观光奶牛\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzYzLw==\">AcWing|观光奶牛</span></h3><ul>\n<li>在图论中形如 $\\frac{\\sum f_i}{\\sum g_i}$ 的问题，称之为 01 分数规划，通用做法，二分</li>\n<li>$\\frac{\\sum f_i}{\\sum g_i}$，就可以转化为 $\\sum f_i &gt; Mid \\times \\sum g_i$，即 $\\sum f_i - Mid \\times \\sum g_i &gt; 0$，求和可以提在括号外，等价于图中<strong>是否有正环</strong></li>\n<li>有向图上的点权可以放在出边上也可以放在入边上</li>\n<li>spfa 算法本身具有一个性质，就是在求解最短路的时候，是可以把点权和边权看做一个整体边权一起更新的，因此我们常常在一些 spfa 的图论问题中，把点权存入边权中进行计算。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010, M = 5010;\nint wf[N], cnt[N];\nint h[N], e[M], wt[M], ne[M], idx;\ndouble dist[N];\nbool st[N];\nint n, m;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool check(double x)&#123;\n    memset(cnt, 0, sizeof(cnt));\n    memset(dist, 0, sizeof(dist));\n    queue&lt;int&gt; q;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        q.push(i);\n        st[i] = true;\n    &#125;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &lt; dist[t] + wf[t] - x * wt[i])&#123;\n                dist[j] = dist[t] + wf[t] - x * wt[i];\n                cnt[j] = cnt[t] + 1;\n                if(cnt[j] &gt;= n) return 1;\n                if(!st[j])&#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; wf[i];\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    &#125;\n    double l = 0, r = 1e6;\n    while(r - l &gt; 1e-4)&#123;\n        double mid = (l + r) / 2;\n        if(check(mid)) l = mid;\n        else r = mid;\n    &#125;\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; l &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-单词环\"><a href=\"#AcWing-单词环\" class=\"headerlink\" title=\"AcWing|单词环\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE2Ni8=\">AcWing|单词环</span></h3><ul>\n<li>可以把一个单词看成一个点，但是如此分析，数据会非常大，边会非常多，因此反过来看，把单词看作边</li>\n<li>例如 $ababc$ 就相当于 $ab \\to bc$ 边权为 $5$，如此最多只有 $10^5$ 条边，只有 $26 \\times 26$ 个点</li>\n<li>其余分析同上题，01 分数规划，可转化成求图中正环</li>\n<li>但是直接这样做会 TLE，该题有个小 trick，当入队的点的总次数超过一定值时，大概率是一定有负环的，<del>所以可以加入该优化</del></li>\n<li>二分精度太高也会 TLE</li>\n<li>将 spfa 中的队列换成栈，可以更快地找到环</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 700, M = 100010;\nint n;\nint h[N], e[M], w[M], ne[M], idx;\ndouble dist[N];\nbool st[N];\nint cnt[N];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool check(double mid)&#123;\n    memset(cnt, 0, sizeof(cnt));\n    queue&lt;int&gt; q;\n    for(int i = 0; i &lt; N; i++)&#123;\n        q.push(i);\n        st[i] = true;\n    &#125;\n    int count = 0;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &lt; dist[t] + w[i] - mid)&#123;\n                dist[j] = dist[t] + w[i] - mid;\n                cnt[j] = cnt[t] + 1;\n                if(++count &gt; 10000) return 1;\n                if(cnt[j] &gt;= N) return 1;\n                if(!st[j])&#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint main()&#123;\n    string str;\n    while(cin &gt;&gt; n, n)&#123;\n        memset(h, -1, sizeof(h));\n        idx = 0;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            cin &gt;&gt; str;\n            int len = str.size();\n            if(len &gt;= 2)&#123;\n                int l = (str[0] - &#39;a&#39;) * 26 + str[1] - &#39;a&#39;;\n                int r = (str[len - 2] - &#39;a&#39;) * 26 + str[len - 1] - &#39;a&#39;;\n                add(l, r, len);\n            &#125;\n        &#125;\n        if(!check(0)) cout &lt;&lt; &quot;No solution\\n&quot;;\n        else&#123;\n            double l = 0, r = 1000;\n            while(r - l &gt; 1e-4)&#123;\n                double mid = (l + r) / 2;\n                if(check(mid)) l = mid;\n                else r = mid;\n            &#125;\n            cout &lt;&lt; l &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"差分约束\"><a href=\"#差分约束\" class=\"headerlink\" title=\"差分约束\"></a>差分约束</h2><ul>\n<li>偏数学</li>\n<li>求一个不等式组的可行解<ul>\n<li>源点需要满足的条件：从源点出发，一定可以走到所有的边</li>\n<li>步骤<ol>\n<li>先将每个不等式 $x_i \\le x_j + c_k$，转化成一条从 $x_j$ 走到 $x_i$，长度为 $c_k$ 的一条边</li>\n<li>找一个虚拟源点，使得该源点一定可以遍历到所有边</li>\n<li>从源点求一遍单源最短路</li>\n</ol>\n</li>\n<li>无解等价于图中存在负环</li>\n</ul>\n</li>\n<li>如何求最大值或者最小值，这里的最值指的是每个变量的最值<ul>\n<li>结论：如果求的是最小值，则应该求最长路；如果求的是最大值，则应该求最短路；</li>\n<li>问题：如何转化 $x_i \\le c$ 其中 $c$ 是一个常数，这一类的不等式</li>\n<li>方法：建立一个虚拟源点 $0$，然后建立 $0 \\to i$，长度为 $c$ 的边即可</li>\n<li>最大值满足最小上确界原理</li>\n<li>以求 $x_i$ 的最大值为例：求所有从 $x_i$ 出发，构成的不等式链 $x_i ; \\le ; x_j + c_1 ; \\ge ; x_k + c_2 + c_1 ; \\ge ; \\cdots ; \\ge ; c_1 + c_2 + \\cdots$ 所计算出的上界，最终 $x_i$ 的最大值等于所有上界的最小值</li>\n</ul>\n</li>\n<li>每一个差分约束的问题都可以转化成单源最短路问题</li>\n<li><strong>总结</strong><ul>\n<li>以求最长路为例<ul>\n<li>边权无限制 spfa $O(nm)$</li>\n<li>边权非负，可以用强连通分量来解，每个强连通分量内部边权为 $0$，否则无解 $O (n + m)$</li>\n<li>边权 $&gt; 0$ 拓扑排序 $O (n + m)$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-糖果\"><a href=\"#AcWing-糖果\" class=\"headerlink\" title=\"AcWing|糖果\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3MS8=\">AcWing|糖果</span></h3><ul>\n<li>几种关系，转化成最长路需要大于等于<ol>\n<li>$A &#x3D; B$ 等价于 $A \\ge B, B \\ge A$</li>\n<li>$A &lt; B$ 等价于 $B \\ge A + 1$</li>\n<li>$A \\ge B$ </li>\n<li>$A &gt; B$ 等价于 $A \\ge B + 1$</li>\n<li>$A \\le B$ 等价于  $B \\ge A$</li>\n</ol>\n</li>\n<li>建立虚拟源点 $x_0 &#x3D; 0$，最后所有的 $x_i$ 都可以转化成 $x_i \\ge x_0 + 1$</li>\n<li>spfa 中用栈，找环效率更高</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010, M = 300010;\nint h[N], e[M], ne[M], w[M], idx;\nLL dist[N];\nint cnt[N];\nbool st[N];\nint n, m;\nvoid add(int a, int b, int c) &#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool spfa()&#123;\n    stack&lt;int&gt; s;\n    memset(dist, -0x3f, sizeof(dist));\n    dist[0] = 0;\n    s.push(0);\n    st[0] = true;\n    while(s.size())&#123;\n        int t = s.top(); s.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &lt; dist[t] + w[i])&#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if(cnt[j] &gt;= n + 1) return false;\n                if(!st[j])&#123;\n                    st[j] = true;\n                    s.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m;\n    while(m--)&#123;\n        int x, a, b;\n        cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;\n        if(x == 1) add(b, a, 0), add(a, b, 0);\n        else if(x == 2) add(a, b, 1);\n        else if(x == 3) add(b, a, 0);\n        else if(x == 4) add(b, a, 1);\n        else add(a, b, 0);\n    &#125;\n    for(int i = 1; i &lt;= n; i++) add(0, i, 1);\n    if(!spfa()) cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else&#123;\n        LL ans = 0;\n        for(int i = 1; i &lt;= n; i++) ans += dist[i];\n        cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-区间\"><a href=\"#AcWing-区间\" class=\"headerlink\" title=\"AcWing|区间\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY0Lw==\">AcWing|区间</span></h3><ul>\n<li>因为需要使用前缀和，要把 $0$ 空出来，所以需要将整体 $+1$</li>\n<li>$S_0 &#x3D; 0$，$S_i$ 表示 $1 \\sim i$ 中被选出的数的个数，需要求 $S_{50001}$ 的最小值</li>\n<li>条件<ol>\n<li>$S_i \\ge S_{i - 1}$, $1 \\ge i \\ge 50001$</li>\n<li>$S_i - S_{i - 1} \\le 1$ 可以转换成 $S_{i - 1} \\ge S_i - 1$</li>\n<li>$[a, b]$ 中选 $c$ 个，$S_b - S_{a - 1} \\ge c$</li>\n</ol>\n</li>\n<li>保证一定有解，所以不需要判断是否有环</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 50010, M = 150010;\nint h[N], e[M], ne[M], w[M], idx;\nint dist[N];\nbool st[N];\nvoid add(int a, int b, int c) &#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid spfa()&#123;\n    queue&lt;int&gt; q;\n    memset(dist, -0x3f, sizeof(dist));\n    dist[0] = 0;\n    q.push(0);\n    st[0] = true;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &lt; dist[t] + w[i])&#123;\n                dist[j] = dist[t] + w[i];\n                if(!st[j])&#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n;\n    cin &gt;&gt; n;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt; N; i++)&#123;\n        add(i - 1, i, 0);\n        add(i, i - 1, -1);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        a++, b++;\n        add(a - 1, b, c);\n    &#125;\n    spfa();\n    cout &lt;&lt; dist[50001] &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-排队布局\"><a href=\"#AcWing-排队布局\" class=\"headerlink\" title=\"AcWing|排队布局\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Mi8=\">AcWing|排队布局</span></h3><ul>\n<li>条件，$x_i$ 表示第 $i$ 头牛的位置<ol>\n<li>$x_i \\le x_{i + 1}$, $1 \\le i &lt; n$，每头奶牛按编号排序</li>\n<li>$x_b \\le x_a + L$</li>\n<li>$x_a \\le x_b - D$</li>\n</ol>\n</li>\n<li>建立虚拟源点 $0$，假定所有牛都在 $\\le 0$ 处，因此可以从 $0$ 向任意点连边</li>\n<li>对于第二问，可以直接让 $x_1 &#x3D; 0$，判断该条件下 $x_n$ 能否去无限大的值</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010, M = 21010;\n\nint h[N], e[M], w[M], ne[M], idx;\nint dist[N], cnt[N];\nbool st[N];\nint n, m1, m2;\n\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool spfa(int sz)&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    memset(cnt, 0, sizeof(cnt));\n    queue&lt;int&gt; q;\n    for(int i = 1; i &lt;= sz; i++)&#123;\n        dist[i] = 0;\n        q.push(i);\n        st[i] = true;\n    &#125;\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        st[t] = false;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(dist[j] &gt; dist[t] + w[i])&#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if(cnt[j] &gt;= n) return false;\n                if(!st[j])&#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt; n; i++) add(i + 1, i, 0);\n    for(int i = 1; i &lt;= m1; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        if(a &gt; b) swap(a, b);\n        add(a, b, c);\n    &#125;\n    for(int i = 1; i &lt;= m2; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        if(a &gt; b) swap(a, b);\n        add(b, a, -c);\n    &#125;\n    if(!spfa(n)) cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else&#123;\n        spfa(1);\n        if(dist[n] == 0x3f3f3f3f) cout &lt;&lt; -2 &lt;&lt; &#39;\\n&#39;;\n        else cout &lt;&lt; dist[n] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-雇佣收银员\"><a href=\"#AcWing-雇佣收银员\" class=\"headerlink\" title=\"AcWing|雇佣收银员\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk1Lw==\">AcWing|雇佣收银员</span></h3><hr>\n<h2 id=\"最近公共祖先\"><a href=\"#最近公共祖先\" class=\"headerlink\" title=\"最近公共祖先\"></a>最近公共祖先</h2><ul>\n<li>在一个有根树当中，求两个点最近的一个祖先，点自身也算</li>\n<li>方法<ul>\n<li>向上标记法，$O(n)$</li>\n<li>倍增法（在线做法），$fa[i, j]$ 表示从 $i$ 开始，向上走 $2^j$ 步能走到的节点。 $0 \\le j \\le logn$，$depth[i]$ 表示深度<ul>\n<li>先将两个点跳到同一层，二进制拼凑</li>\n<li>让两个点同时往上跳，一直跳到他们最近公共祖先的下一层</li>\n<li>预处理 $O(nlogn)$, 查询 $O(logn)$</li>\n<li>哨兵：如果从 $i$ 开始跳 $2^j$ 步会跳过根节点，那么 $fa[i, j] &#x3D; 0$，$depth[0] &#x3D; 0$</li>\n</ul>\n</li>\n<li>Tarjan，离线求 LCA，$O(n + m)$<ul>\n<li>在深度优先遍历时，将所有点分成三大类：<ol>\n<li>已经遍历过，且回溯过的点</li>\n<li>正在搜索的分支</li>\n<li>还未搜索到的点</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>RMQ</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-祖孙询问\"><a href=\"#AcWing-祖孙询问\" class=\"headerlink\" title=\"AcWing|祖孙询问\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3NC8=\">AcWing|祖孙询问</span></h3><ul>\n<li>倍增 LCA</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 400010, M = N * 2;\nint h[N], e[M], ne[M], idx;\nint depth[N], fa[N][16];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid bfs(int root)&#123;\n    memset(depth, 0x3f, sizeof(depth));\n    queue&lt;int&gt; q;\n    depth[root] = 1, depth[0] = 0;\n    q.push(root);\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(depth[j] &gt; depth[t] + 1)&#123;\n                depth[j] = depth[t] + 1;\n                fa[j][0] = t;\n                q.push(j);\n                for(int k = 1; k &lt;= 15; k++)&#123;\n                    fa[j][k] = fa[fa[j][k - 1]][k - 1];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint lca(int a, int b)&#123;\n    if(depth[a] &lt; depth[b]) swap(a, b);\n    for(int i = 15; i &gt;= 0; i--)&#123;\n        if(depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i];\n    &#125;\n    if(a == b) return a;\n    for(int i = 15; i &gt;= 0; i--)&#123;\n        if(fa[a][i] != fa[b][i])&#123;\n            a = fa[a][i];\n            b = fa[b][i];\n        &#125;\n    &#125;\n    return fa[a][0];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n;\n    int root = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n        if(b == -1) root = a;\n        else add(a, b), add(b, a);\n    &#125;\n    bfs(root);\n    cin &gt;&gt; m;\n    while(m--)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        int p = lca(a, b);\n        if(p == a) cout &lt;&lt; &quot;1\\n&quot;;\n        else if(p == b) cout &lt;&lt; &quot;2\\n&quot;;\n        else cout &lt;&lt; &quot;0\\n&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-距离\"><a href=\"#AcWing-距离\" class=\"headerlink\" title=\"AcWing|距离\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3My8=\">AcWing|距离</span></h3><ul>\n<li>targan 离线求 LCA</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 20010, M = N * 2;\nint n, m;\nint h[N], e[M], w[M], ne[M], idx;\nint dist[N], p[N], ans[N], st[N];\nvector&lt;PII&gt; query[N];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nvoid dfs(int u, int fa)&#123;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == fa) continue;\n        dist[j] = dist[u] + w[i];\n        dfs(j, u);\n    &#125;\n&#125;\nvoid tarjan(int u)&#123;\n    st[u] = 1;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!st[j])&#123;\n            tarjan(j);\n            p[j] = u;\n        &#125;\n    &#125;\n    for(auto [v, id] : query[u])&#123;\n        if(st[v] == 2)&#123;\n            int anc = find(v);\n            ans[id] = dist[v] + dist[u] - 2 * dist[anc];\n        &#125;\n    &#125;\n    st[u] = 2;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n - 1; i += 1)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n        add(b, a, c);\n    &#125;\n    for(int i = 0; i &lt; m; i += 1)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        if(a != b)&#123;\n            query[a].push_back(&#123;b, i&#125;);\n            query[b].push_back(&#123;a, i&#125;);\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n    dfs(1, -1);\n    tarjan(1);\n    for(int i = 0; i &lt; m; i++) cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-次小生成树🌖\"><a href=\"#AcWing-次小生成树🌖\" class=\"headerlink\" title=\"AcWing|次小生成树🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzU4Lw==\">AcWing|次小生成树</span>🌖</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzI0NjA5Lw==\">(kruskal+lca+证明)</span></li>\n<li>倍增 LCA $O(logn)$ 求新加入非树边边的两点 $a, b$ 间的最大边和次大边</li>\n<li>预处理每个点 $i$ 跳 $2^j$ 后的父节点 $fa[i][j]$<ul>\n<li>在 $x$ 和 $y$ 向 $lca[x][y]$ 跳的过程中维护各自路径中的最大值 $d1[x \\to lca], d1[y \\to lca]$ 和次大值 $d2[x \\to lca], d2[y \\to lca]$</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010, M = 300010, INF = 0x3f3f3f3f;\nint n, m;\nstruct Edge&#123;\n    int a, b, w;\n    bool f;\n    bool operator &lt; (const Edge &amp;t) const&#123;\n        return w &lt; t.w;\n    &#125;\n&#125;edges[M];\nint p[N];\nint h[N], e[M], ne[M], w[M], idx;\nint depth[N], fa[N][17], d1[N][17], d2[N][17];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint find(int x)&#123;\n    if(x != p[x]) p[x] = find(p[x]);\n    return p[x];\n&#125;\nLL kruskal()&#123;\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n    sort(edges, edges + m);\n    LL ans = 0;\n    for(int i = 0; i &lt; m; i++)&#123;\n        int a = find(edges[i].a), b = find(edges[i].b), w = edges[i].w;\n        if(a != b)&#123;\n            p[a] = b;\n            ans += w;\n            edges[i].f = 1;\n        &#125;\n    &#125;\n    return ans;\n&#125;\nvoid build()&#123;\n    for(int i = 0; i &lt; m; i++)&#123;\n        if(edges[i].f)&#123;\n            auto [a, b, w, _] = edges[i];\n            add(a, b, w), add(b, a, w);\n        &#125;\n    &#125;\n&#125;\nvoid bfs()&#123;\n    memset(depth, 0x3f, sizeof(depth));\n    depth[0] = 0, depth[1] = 1;\n    queue&lt;int&gt; q;\n    q.push(1);\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(depth[j] &gt; depth[t] + 1)&#123;\n                depth[j] = depth[t] + 1;\n                q.push(j);\n                fa[j][0] = t;\n                d1[j][0] = w[i], d2[j][0] = -INF;\n                for(int k = 1; k &lt;= 16; k++)&#123;\n                    int anc = fa[j][k - 1];\n                    fa[j][k] = fa[anc][k - 1];\n                    int d[4] = &#123;d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]&#125;;\n                    d1[j][k] = d2[j][k] = -INF;\n                    for(int u = 0; u &lt; 4; u++)&#123;\n                        int dis = d[u];\n                        if(dis &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = dis;\n                        else if(dis != d1[j][k] &amp;&amp; dis &gt; d2[j][k]) d2[j][k] = dis;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint lca(int a, int b, int w)&#123;\n    static int dist[N * 2];\n    int cnt = 0;\n    if(depth[a] &lt; depth[b]) swap(a, b);\n    for(int k = 16; k &gt;= 0; k--)&#123;\n        if(depth[fa[a][k]] &gt;= depth[b])&#123;\n            dist[cnt++] = d1[a][k];\n            dist[cnt++] = d2[a][k];\n            a = fa[a][k];\n        &#125;\n    &#125;\n    if(a != b)&#123;\n        for(int k = 16; k &gt;= 0; k--)&#123;\n            if(fa[a][k] != fa[b][k])&#123;\n                dist[cnt++] = d1[a][k];\n                dist[cnt++] = d2[a][k];\n                dist[cnt++] = d1[b][k];\n                dist[cnt++] = d2[b][k];\n                a = fa[a][k], b = fa[b][k];\n            &#125;\n        &#125;\n        dist[cnt++] = d1[a][0];\n        dist[cnt++] = d1[b][0];\n    &#125;\n    int dist1 = -INF, dist2 = -INF;\n    for(int i = 0; i &lt; cnt; i++)&#123;\n        int d = dist[i];\n        if(d &gt; dist1) dist2 = dist1, dist1 = d;\n        else if(d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;\n    &#125;\n    if(w &gt; dist1) return w - dist1;\n    if(w &gt; dist2) return w - dist2;\n    return INF;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; m; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        edges[i] = &#123;a, b, c&#125;;\n    &#125;\n    LL sum = kruskal();\n    build();\n    bfs();\n    LL ans = 1e18;\n    for(int i = 0; i &lt; m; i++)&#123;\n        if(!edges[i].f)&#123;\n            auto [a, b, c, _] = edges[i];\n            ans = min(ans, sum + lca(a, b, c));\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"有向图的强连通分量\"><a href=\"#有向图的强连通分量\" class=\"headerlink\" title=\"有向图的强连通分量\"></a>有向图的强连通分量</h2><ul>\n<li>对于一个有向图，连通分量：对于分量中任意两点 $u，v$，必然可以从 $u$ 走到 $v$，且从 $v$ 走到 $u$</li>\n<li>强连通分量：极大连通分量</li>\n<li>有向图通过缩点成为一个有向无环图（DAG），（拓扑图）<ul>\n<li>缩点：将所有连通分量缩成一个点</li>\n</ul>\n</li>\n<li>通常将一个图，对其求强连通分量，缩点成一个拓扑图方便求解</li>\n<li>强连通分量的求法<ul>\n<li>DFS，将边分为四类<ul>\n<li>树枝边，前向边，后向边，横叉边 （连向已被 DFS 的其他树枝的边）</li>\n</ul>\n</li>\n<li>判断是否在强连通分量中<ul>\n<li>存在后向边指向祖先节点</li>\n<li>先走到横叉边再走到祖先节点</li>\n</ul>\n</li>\n<li>Tarjan 算法求强连通分量（SCC）<ul>\n<li>引入时间戳，对每个点定义两个时间戳：$dfn[u]$ 表示遍历到 $u$ 的时间戳，$low[u]$ 表示从 $u$ 开始走，所能遍历到的最小时间戳是什么</li>\n<li>$u$ 是其所在的强连通分量的最高点，等价于 $dfn[u] &#x3D; low[u]$</li>\n<li>缩点，遍历所有点，再遍历所有邻点，如果 $i$ 和 $j$ 不在同一个连通分量中就加一条新边 $id_i \\to id_j$</li>\n<li>连通分量编号递减的顺序一定是拓扑序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模板</li>\n</ul>\n<pre><code class=\"cpp\">void tarjan(int u)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, in_stk[u] = true;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n        &#125;else if(in_stk[j])&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    \n    if(dfn[u] == low[u])&#123;\n        int y;\n        ++scc_cnt;\n        do&#123;\n            y = stk[top--];\n            in_stk[y] = false;\n            id[y] = scc_cnt;\n        &#125;while(y != u);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-受欢迎的牛\"><a href=\"#AcWing-受欢迎的牛\" class=\"headerlink\" title=\"AcWing|受欢迎的牛\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Ni8=\">AcWing|受欢迎的牛</span></h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzIwNjc4Lw==\">详细题解</span></li>\n<li>在拓扑图中只要存在两个及以上出度为 $0$ 的点，则无解，若只存在一个出度为 $0$ 的点，则所有点都可以到达它，故该题可求强连通分量，找到那个出度为 $0$ 的点，其连通分量中点的个数即为答案</li>\n</ul>\n<pre><code class=\"cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010, M = 50010;\nint n, m;\nint h[N], e[M], ne[M], idx;\nint dfn[N], low[N], timestamp;\nint stk[N], top;\nbool in_stk[N];\nint id[N], scc_cnt, sz[N];\nint dout[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, in_stk[u] = true;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n        &#125;else if(in_stk[j])&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    if(dfn[u] == low[u])&#123;\n        ++scc_cnt;\n        int y;\n        do&#123;\n            y = stk[top--];\n            in_stk[y] = false;\n            id[y] = scc_cnt;\n            sz[scc_cnt]++;\n        &#125;while(y != u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    while(m--)&#123;\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n        add(a, b);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!dfn[i]) tarjan(i);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = h[i]; ~j; j = ne[j])&#123;\n            int k = e[j];\n            int a = id[i], b = id[k];\n            if(a != b) dout[a]++;\n        &#125;\n    &#125;\n    int zeros = 0, sum = 0;\n    for(int i = 1; i &lt;= scc_cnt; i++)&#123;\n        if(!dout[i])&#123;\n            zeros++;\n            sum += sz[i];\n            if(zeros &gt; 1)&#123;\n                sum = 0;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-学校网络\"><a href=\"#AcWing-学校网络\" class=\"headerlink\" title=\"AcWing|学校网络\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY5Lw==\">AcWing|学校网络</span></h3><ul>\n<li>第一问，缩点后求入度为 $0$ 的起点的个数</li>\n<li>第二问，入度为 $0$ 和出度为 $0$ 的点的个数的最大值，因为强连通分量内部任意一点都可以到达，如果整个图是一个强连通分量，则不需要连边<ul>\n<li>证明<ul>\n<li>起点和终点可以对称看，故只证明一边，不妨设 $|P| \\le |Q|$</li>\n<li>如果 $|P| &#x3D; 1$，在有限步之内，每一个终点都可以被走到，因此只需要从每一个终点连一条到起点的边</li>\n<li>如果 $|P| &gt; 1$，则一定至少有 $P_1 \\to Q_1, P_2 \\to Q_2$，考虑反证法，如果找不到这样的两个点，所有的起点都只能走到一个终点，而其他的终点必然能够找到一个起点，故矛盾。同时，只要连一条边，就可以让原先起点和终点两个集合中的点数都减一</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110, M = 50010;\nint h[N], e[M], ne[M], idx;\nint dfn[N], low[N], timestamp;\nint stk[N], top;\nbool in_stk[N];\nint id[N], scc_cnt;\nint din[N], dout[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u;\n    in_stk[u] = true;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n        &#125;else if(in_stk[j])&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    if(dfn[u] == low[u])&#123;\n        int y;\n        ++scc_cnt;\n        do&#123;\n            y = stk[top--];\n            in_stk[y] = false;\n            id[y] = scc_cnt;\n        &#125;while(y != u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    int n; cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        while(cin &gt;&gt; x, x)&#123;\n            add(i, x);\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!dfn[i]) tarjan(i);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = h[i]; ~j; j = ne[j])&#123;\n            int k = e[j];\n            int a = id[i], b = id[k];\n            if(a != b)&#123;\n                dout[a]++;\n                din[b]++;\n            &#125;\n        &#125;\n    &#125;\n    int cnt1 = 0, cnt2 = 0;\n    for(int i = 1; i &lt;= scc_cnt; i++)&#123;\n        if(!dout[i]) cnt2++;\n        if(!din[i]) cnt1++;\n    &#125;\n    cout &lt;&lt; cnt1 &lt;&lt; &#39;\\n&#39;;\n    if(scc_cnt == 1) cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n    else cout &lt;&lt; max(cnt1, cnt2) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-最大半连通子图\"><a href=\"#AcWing-最大半连通子图\" class=\"headerlink\" title=\"AcWing|最大半连通子图\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Ny8=\">AcWing|最大半连通子图</span></h3><ul>\n<li>强连通分量一定是半连通</li>\n<li>tarjan，缩点，建图（给边排重），之后按照拓扑序递推（节点编号倒着即为拓扑序）</li>\n<li>求 <strong>最大半连通子图</strong> 等价于求 <strong>最长无分叉链</strong> ，链上权重是连通分量里的节点数</li>\n<li>求 <strong>最长链方案数</strong> 等价于 <strong>拓扑图求最长路</strong> （权重是结点数），与背包问题求方案数相类似</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010, M = 2000010;\nint n, m, mod;\nint h[N], hs[N], e[M], ne[M], idx;\nint dfn[N], low[N], timestamp;\nint stk[N], top;\nbool in_stk[N];\nint id[N], scc_cnt, sz[N];\nint f[N], g[N];\nvoid add(int h[], int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, in_stk[u] = true;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n        &#125;else if(in_stk[j])&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    if(dfn[u] == low[u])&#123;\n        ++scc_cnt;\n        int y;\n        do&#123;\n            y = stk[top--];\n            in_stk[y] = false;\n            id[y] = scc_cnt;\n            sz[scc_cnt]++;\n        &#125;while(y != u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;\n    memset(h, -1, sizeof(h));\n    memset(hs, -1, sizeof(hs));\n    while(m--)&#123;\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n        add(h, a, b);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!dfn[i]) tarjan(i);\n    &#125;\n    unordered_set&lt;LL&gt; st; // (u, v) -&gt; u * 1000000 + v;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = h[i]; ~j; j = ne[j])&#123;\n            int k = e[j];\n            int a = id[i], b = id[k];\n            LL tmp = a * 1000000ll + b;\n            if(a != b &amp;&amp; !st.count(tmp))&#123;\n                st.insert(tmp);\n                add(hs, a, b);\n            &#125;\n        &#125;\n    &#125;\n    for(int i = scc_cnt; i; i--)&#123;\n        if(!f[i])&#123;\n            f[i] = sz[i];\n            g[i] = 1;\n        &#125;\n        for(int j = hs[i]; ~j; j = ne[j])&#123;\n            int k = e[j];\n            if(f[k] &lt; f[i] + sz[k])&#123;\n                f[k] = f[i] + sz[k];\n                g[k] = g[i];\n            &#125;else if(f[k] == f[i] + sz[k])&#123;\n                g[k] = (g[k] + g[i]) % mod;\n            &#125;\n        &#125;\n    &#125;\n    int maxf = 0, sum = 0;\n    for(int i = 1; i &lt;= scc_cnt; i++)&#123;\n        if(maxf &lt; f[i])&#123;\n            maxf = f[i];\n            sum = g[i];\n        &#125;else if(maxf == f[i])&#123;\n            sum = (sum + g[i]) % mod;\n        &#125;\n    &#125;\n    cout &lt;&lt; maxf &lt;&lt; &#39;\\n&#39; &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-银河\"><a href=\"#AcWing-银河\" class=\"headerlink\" title=\"AcWing|银河\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzcwLw==\">AcWing|银河</span></h3><ul>\n<li>与差分约束-糖果类似，这里使用强连通分量解法，求最小值转化成求最长路</li>\n<li>强连通分量时间复杂度稳定线性</li>\n<li>所以边权大于等于 $0$ ，判断是否存在正环，故可以使用强连通分量解，对于强连通分量中任意两点，只要边权大于 $0$ 则必定存在正环</li>\n<li>tarjan，缩点建图，拓扑序递推求最长路</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 100010, M = 600010;\nint n, m;\nint h[N], hs[N], e[M], ne[M], w[M], idx;\nint dfn[N], low[N], timestamp;\nbool in_stk[N];\nint stk[N], top;\nint id[N], scc_cnt, sz[N];\nint dist[N];\nvoid add(int h[], int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, in_stk[u] = true;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n        &#125;else if(in_stk[j])&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    if(dfn[u] == low[u])&#123;\n        ++scc_cnt;\n        int y;\n        do&#123;\n            y = stk[top--];\n            in_stk[y] = false;\n            id[y] = scc_cnt;\n            sz[scc_cnt]++;\n        &#125;while(y != u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    memset(hs, -1, sizeof(hs));\n    for(int i = 1; i &lt;= n; i++)&#123;\n        add(h, 0, i, 1);\n    &#125;\n    while(m--)&#123;\n        int t, a, b;\n        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;\n        if(t == 1) add(h, a, b, 0), add(h, b, a, 0);\n        else if(t == 2) add(h, a, b, 1);\n        else if(t == 3) add(h, b, a, 0);\n        else if(t == 4) add(h, b, a, 1);\n        else add(h, a, b, 0);\n    &#125;\n    tarjan(0);\n    bool ok = 1;\n    for(int i = 0; i &lt;= n; i++)&#123;\n        for(int j = h[i]; ~j; j = ne[j])&#123;\n            int k = e[j];\n            int a = id[i], b = id[k];\n            if(a == b)&#123;\n                if(w[j] &gt; 0)&#123;\n                    ok = 0;\n                    break;\n                &#125;\n            &#125;else&#123;\n                add(hs, a, b, w[j]);\n            &#125;\n        &#125;\n        if(!ok) break; \n    &#125;\n    if(!ok) cout &lt;&lt; &quot;-1\\n&quot;;\n    else&#123;\n        for(int i = scc_cnt; i; i--)&#123;\n            for(int j = hs[i]; ~j; j = ne[j])&#123;\n                int k = e[j];\n                dist[k] = max(dist[k], dist[i] + w[j]);\n            &#125;\n        &#125;\n        LL ans = 0;\n        for(int i = 1; i &lt;= scc_cnt; i++)&#123;\n            ans += 1ll * dist[i] * sz[i];\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"无向图的双连通分量\"><a href=\"#无向图的双连通分量\" class=\"headerlink\" title=\"无向图的双连通分量\"></a>无向图的双连通分量</h2><ul>\n<li>别称：重连通分量 （Tarjan 发明）</li>\n<li>双连通分量<ol>\n<li>边双连通分量 e-DCC<ul>\n<li>不含有桥的连通区域，不管删掉哪条边，这个图都还是连通的</li>\n<li>在一个边的双连通分量里，任意两点间都包含两个不相交的路径，即没有公共边</li>\n<li>极大的不包括桥的连通块</li>\n</ul>\n</li>\n<li>点双连通分量 v-DCC<ul>\n<li>割点：一个图中删掉一个点后变成不连通图，这个点被称为割点</li>\n<li>极大的不包括割点的连通块</li>\n<li>每个割点至少属于两个点双连通分量</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>Tarjan 算法<ul>\n<li>边双连通分量<ul>\n<li>引入时间戳，对每个点定义两个时间戳：$dfn[u]$ 表示遍历到 $u$ 的时间戳，$low[u]$ 表示从 $u$ 开始走，所能遍历到的最小时间戳是什么</li>\n<li>无横叉边</li>\n<li>如何找到桥<ul>\n<li>桥 $(x&#x2F;leftrightarrow y)$ $&#x2F;leftrightarrow$ $dfn[x] &lt; low[y]$</li>\n</ul>\n</li>\n<li>如何找到所有边的双连通分量<ul>\n<li>将所有桥删掉</li>\n<li>stack $dfn[x] &#x3D; low[x]$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>点双连通分量<ul>\n<li>引入时间戳，对每个点定义两个时间戳：$dfn[u]$ 表示遍历到 $u$ 的时间戳，$low[u]$ 表示从 $u$ 开始走，所能遍历到的最小时间戳是什么引入时间戳</li>\n<li>如何找到割点<ul>\n<li>$dfn[x] \\le low[y]$<ol>\n<li>$x$ 不是根节点，那么 $x$ 是割点</li>\n<li>$x$ 是根节点，至少有两个子节点 $y_i$，$dfn[x] \\le low[y_i]$</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>如何求点双连通分量<pre><code class=\"cpp\">stk[]\nif(dfn[x] &lt;= low[y])&#123;\n    cnt++;\n    if(x != root || cnt &gt; 1) x为割点\n    stk.pop(j) while(j != y) 将栈中元素弹出至 y 为止\n    且 x 也属于该双连通分量\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-冗余路径\"><a href=\"#AcWing-冗余路径\" class=\"headerlink\" title=\"AcWing|冗余路径\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk3Lw==\">AcWing|冗余路径</span></h3><ul>\n<li>给定一个无向连通图，问最少加几条边，可以将其变成一个边双连通分量</li>\n<li>对双连通分量做完缩点后只剩桥和点，可以发现对左右两个叶子节点连通后，根节点连向左右叶子节点的边就可以删去了</li>\n<li>(cnt + 1) &#x2F; 2 向下取整</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 5010, M = 20010;\nint h[N], e[M], ne[M], idx;\nint dfn[N], low[N], timestamp;\nint stk[N], top;\nint id[N], dcc_cnt;\nbool is_bridge[M];\nint d[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u, int from)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j, i);\n            low[u] = min(low[u], low[j]);\n            if(dfn[u] &lt; low[j])&#123;\n                is_bridge[i] = is_bridge[i ^ 1] = 1;\n            &#125;\n        &#125;else if(i != (from ^ 1))&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    if(dfn[u] == low[u])&#123;\n        int y;\n        ++dcc_cnt;\n        do&#123;\n            y = stk[top--];\n            id[y] = dcc_cnt;\n        &#125;while(y != u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    while(m--)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b);\n        add(b, a);\n    &#125;\n    tarjan(1, -1);\n    for(int i = 0; i &lt; idx; i++)&#123;\n        if(is_bridge[i])&#123;\n            d[id[e[i]]]++;\n        &#125;\n    &#125;\n    int cnt = 0;\n    for(int i = 1; i &lt;= dcc_cnt; i++)&#123;\n        if(d[i] == 1) cnt++;\n    &#125;\n    cout &lt;&lt; (cnt + 1) / 2 &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h3 id=\"AcWing-电力\"><a href=\"#AcWing-电力\" class=\"headerlink\" title=\"AcWing|电力\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE4NS8=\">AcWing|电力</span></h3><ul>\n<li>统计连通块个数</li>\n<li>枚举从哪个块中删除某个点能分成多少块</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010, M = 30010;\nint dfn[N], low[N], timestamp;\nint h[N], e[M], ne[M], idx;\nint ans;\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u, int root)&#123;\n    dfn[u] = low[u] = ++timestamp;\n    int cnt = 0;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j, root);\n            low[u] = min(low[u], low[j]);\n            if(dfn[u] &lt;= low[j])&#123;\n                cnt++;\n            &#125;\n        &#125;else&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n    if(u != root)&#123;\n        cnt++;\n    &#125;\n    ans = max(ans, cnt);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    while(cin &gt;&gt; n &gt;&gt; m)&#123;\n        if(!n &amp;&amp; !m) break;\n        memset(h, -1, sizeof(h));\n        memset(dfn, 0, sizeof(dfn));\n        idx = timestamp = 0;\n        while(m--)&#123;\n            int a, b;\n            cin &gt;&gt; a &gt;&gt; b;\n            add(a, b);\n            add(b, a);\n        &#125;\n        ans = 0;\n        int cnt = 0;\n        for(int root = 0; root &lt; n; root++)&#123;\n            if(!dfn[root])&#123;\n                tarjan(root, root);\n                cnt++;\n            &#125;\n        &#125;\n        cout &lt;&lt; ans + cnt - 1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-矿场搭建-🌖🌖\"><a href=\"#AcWing-矿场搭建-🌖🌖\" class=\"headerlink\" title=\"AcWing|矿场搭建 🌖🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk4Lw==\">AcWing|矿场搭建</span> 🌖🌖</h3><ul>\n<li>给定一个无向图，问最少在几个点上设置出口，可以使得任意一点坍塌，其余所有点都可以与某个出口连通</li>\n<li>出口数量 $\\ge 2$</li>\n<li>分别看每个连通块<ul>\n<li>无割点，$C_{cnt}^2$ 种出口方案</li>\n<li>有割点，缩点，先将每个割点单独作为一个点，从每个 v-DCC 向其所包含的每个割点连个边<ul>\n<li>v-DCC 度数为 1，需要在该分量内部（非割点）放一个出口</li>\n<li>v-DCC 度数 $&gt; 1$ 无需设置出口</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int N = 510, M = 1010;\nint h[N], e[M], ne[M], idx;\nint dfn[N], low[N], timestamp;\nint stk[N], top;\nint dcc_cnt;\nvector&lt;int&gt; dcc[N];\nbool cut[N];\nint root;\n\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid tarjan(int u)&#123;\n    low[u] = dfn[u] = ++timestamp;\n    stk[++top] = u;\n    // 1. u 是孤立点\n    if(u == root &amp;&amp; h[u] == -1)&#123;\n        dcc_cnt++;\n        dcc[dcc_cnt].push_back(u);\n        return ;\n    &#125;\n    // 2. u 不是孤立点\n    int cnt = 0;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(!dfn[j])&#123;\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n            // 看 j 是不是能连到比 u 还高的地方\n            if(dfn[u] &lt;= low[j])&#123;   // j 是 u 的新分支\n                cnt++;\n                if(u != root || cnt &gt; 1)&#123;\n                    cut[u] = true;\n                &#125;\n                ++dcc_cnt;\n                int y;\n                do&#123;\n                    y = stk[top--];\n                    dcc[dcc_cnt].push_back(y);\n                &#125;while(y != j); // 弹出到 j 为止\n                // 🔺 开新分支 == u 一定和新分支 j 组成一个 dcc 也和旧连通块组成 dcc\n                // 那么当前最高点 u 还要被用在更高的包含 u 的旧连通块\n                // 所以如果这个时候出栈了 回溯到比 u 高的点的时候 u 就加不进旧连通块里\n                dcc[dcc_cnt].push_back(u);\n            &#125;\n        &#125;else&#123;\n            low[u] = min(low[u], dfn[j]);\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int T = 1, n, m;\n    while(cin &gt;&gt; m, m)&#123;\n        for(int i = 1; i &lt;= dcc_cnt; i++)&#123;\n            dcc[i].clear();\n        &#125;\n        idx = timestamp = n = top = dcc_cnt = 0;\n        memset(h, -1, sizeof(h));\n        memset(dfn, 0, sizeof(dfn));\n        memset(low, 0, sizeof(low));\n        memset(cut, 0, sizeof(cut));\n        while(m--)&#123;\n            int a, b;\n            cin &gt;&gt; a &gt;&gt; b;\n            n = max(&#123;n, a, b&#125;);\n            add(a, b);\n            add(b, a);\n        &#125;\n        for(root = 1; root &lt;= n; root++)&#123;\n            if(!dfn[root])&#123;\n                tarjan(root);\n            &#125;\n        &#125;\n        int ans = 0;\n        ULL num = 1;\n        for(int i = 1; i &lt;= dcc_cnt; i++)&#123;\n            int cnt = 0;\n            for(int j = 0; j &lt; dcc[i].size(); j++)&#123;\n                if(cut[dcc[i][j]])&#123;\n                    cnt++;\n                &#125;\n            &#125;\n            if(cnt == 0)&#123;\n                if(dcc[i].size() &gt; 1) ans += 2, num *= dcc[i].size() * (dcc[i].size() - 1) / 2;\n                else ans++;\n            &#125;else if(cnt == 1)&#123;\n                ans++;\n                num *= dcc[i].size() - 1;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;Case &quot; &lt;&lt; T++ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h2><ul>\n<li><p>二分图，不存在奇数环，染色法不存在矛盾</p>\n</li>\n<li><p>匈牙利算法，匹配、最大匹配、匹配点、增广路径</p>\n<ul>\n<li>增广路径：非匹配点走，通过非匹配边，匹配边，非匹配边 … 再走到另一块的非匹配点</li>\n<li>最大匹配等价于不存在增广路径</li>\n</ul>\n</li>\n<li><p>最小点覆盖、最大独立集、最小路径点覆盖、最小路径重复点覆盖</p>\n<ul>\n<li>最大匹配数 &#x3D; 最小点覆盖 &#x3D; 总点数 - 最大独立集 &#x3D; 总点数 - 最小路径覆盖</li>\n<li>在二分图中，最小点覆盖 &#x3D; 最大匹配数，<em>证明待看</em></li>\n<li>最大独立集，选出最多的点，使得选出的点之间没有边。在二分图中，求一个最大独立集，等价于去掉最少的点，将所有边都破坏掉，也就是找到最小点覆盖，即找最大匹配</li>\n</ul>\n</li>\n<li><p>最优匹配，KM</p>\n</li>\n<li><p>多重匹配，（最大流</p>\n</li>\n</ul>\n<h3 id=\"AcWing-关押罪犯\"><a href=\"#AcWing-关押罪犯\" class=\"headerlink\" title=\"AcWing|关押罪犯\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU5Lw==\">AcWing|关押罪犯</span></h3><ul>\n<li>二分 + 染色法判断二分图（无向图）</li>\n<li>将罪犯当作点，罪犯之间的仇恨关系当做点与点之间的无向边，边的权重是罪犯之间的仇恨值。那么原问题变成：将所有点分成两组，使得各组内边的权重的最大值尽可能小</li>\n<li>$color$ 数组中，$0$ 表示未染色，$1$ 表示染白色，$2$ 表示染黑色</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 20010, M = 200010;\nint h[N], e[M], ne[M], w[M], idx;\nint color[N];\nint n, m;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nbool dfs(int u, int c, int mid)&#123;\n    color[u] = c;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        if(w[i] &lt;= mid) continue;\n        int j = e[i];\n        if(color[j] == c) return false;\n        if(!color[j] &amp;&amp; !dfs(j, 3 - c, mid)) return false;\n    &#125;\n    return true;\n&#125;\nbool check(int limit)&#123;\n    memset(color, 0, sizeof(color));\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!color[i])&#123;\n            if(!dfs(i, 1, limit)) return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    cin &gt;&gt; n &gt;&gt; m;\n    while(m--)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c), add(b, a, c);\n    &#125;\n    int l = 0, r = 1e9;\n    while(l &lt; r)&#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if(check(mid)) r = mid;\n        else l = mid + 1;\n    &#125;\n    cout &lt;&lt; l &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-棋盘覆盖\"><a href=\"#AcWing-棋盘覆盖\" class=\"headerlink\" title=\"AcWing|棋盘覆盖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzc0Lw==\">AcWing|棋盘覆盖</span></h3><ul>\n<li>把一个骨牌看作一条边，所占的两个格子看作点，因此可以将问题转化成一个棋盘可以最多取多少条边，且所有选出的边无公共点</li>\n<li>用最大匹配来做，经典黑白二分图</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\ntypedef pair&lt;int, int&gt; PII;\nbool g[N][N], st[N][N];\nPII match[N][N];\nint dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\nint n, t;\nbool find(int x, int y)&#123;\n    for(int i = 0; i &lt; 4; i++)&#123;\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; n) continue;\n        if(st[nx][ny] || g[nx][ny]) continue;\n        st[nx][ny] = true;\n        PII t = match[nx][ny];\n        if(t.first == -1 || find(t.first, t.second))&#123;\n            match[nx][ny] = &#123;x, y&#125;;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; t;\n    while(t--)&#123;\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n        g[a][b] = true;\n    &#125;\n    memset(match, -1, sizeof(match));\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            if((i + j) % 2 &amp;&amp; !g[i][j])&#123;\n                memset(st, 0, sizeof(st));\n                if(find(i, j)) ans++;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-机器任务\"><a href=\"#AcWing-机器任务\" class=\"headerlink\" title=\"AcWing|机器任务\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzc4Lw==\">AcWing|机器任务</span></h3><ul>\n<li>$a[i] &#x3D; 0 || b[i] &#x3D; 0$ 时可以跳过</li>\n<li>一个任务 $i$ 可以在两种状态下完成，因此可以将一个任务看成一条边，两种状态看成两个端点，要完成一个任务就要从这两个点中选一个点，对于所有任务来说，就是从 $N + M - 2$ （不包含初始状态）中选出最少的点，覆盖所有的边（任务），问题就变成求最小点覆盖问题</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\nint match[N];\nbool st[N], g[N][N];\nint n, m, k;\nbool find(int x)&#123;\n    for(int i = 1; i &lt; m; i++)&#123;\n        if(g[x][i] &amp;&amp; !st[i])&#123;\n            st[i] = true;\n            if(match[i] == -1 || find(match[i]))&#123;\n                match[i] = x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    while(cin &gt;&gt; n, n)&#123;\n        cin &gt;&gt; m &gt;&gt; k;\n        memset(g, 0, sizeof(g));\n        while(k--)&#123;\n            int op, a, b;\n            cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;\n            g[a][b] = true;\n        &#125;\n        memset(match, -1, sizeof(match));\n        int ans = 0;\n        for(int i = 1; i &lt; n; i++)&#123;\n            memset(st, 0, sizeof(st));\n            if(find(i)) ans++;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-骑士放置\"><a href=\"#AcWing-骑士放置\" class=\"headerlink\" title=\"AcWing|骑士放置\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTg1Lw==\">AcWing|骑士放置</span></h3><ul>\n<li>每个不禁止放的点是一个图节点，每两个可以通过日字形走到的点连一条边，问题为选出最多的点，使得选出来的点之间不能通过日字形走到，可以转化成选出最多的点，使得选出来的点之间没有边</li>\n<li>即为最大独立集问题，可以转化成求最大匹配，且满足二分图，因此可以使用匈牙利算法<ul>\n<li>从白点通过日字形只能走到黑点，因此这是个二分图</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 110;\nbool g[N][N], st[N][N];\nPII match[N][N];\nint n, m, t;\nint dx[8] = &#123;-2, -1, 1, 2, -2, -1, 1, 2&#125;, dy[8] = &#123;-1, -2, -2, -1, 1, 2, 2, 1&#125;;\nbool find(int x, int y)&#123;\n    for(int i = 0; i &lt; 8; i++)&#123;\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; m) continue;\n        if(g[nx][ny] || st[nx][ny]) continue;\n        st[nx][ny] = true;\n        PII t = match[nx][ny];\n        if(t.first == -1 || find(t.first, t.second))&#123;\n            match[nx][ny] = &#123;x, y&#125;;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;\n    for(int i = 1; i &lt;= t; i++)&#123;\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n        g[a][b] = true;\n    &#125;\n    memset(match, -1, sizeof(match));\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            if((i + j) % 2 || g[i][j]) continue;\n            memset(st, 0, sizeof(st));\n            if(find(i, j)) ans++;\n        &#125;\n    &#125;\n    cout &lt;&lt; n * m - ans - t &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-捉迷藏\"><a href=\"#AcWing-捉迷藏\" class=\"headerlink\" title=\"AcWing|捉迷藏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzgxLw==\">AcWing|捉迷藏</span></h3><hr>\n<h2 id=\"欧拉回路和欧拉路径\"><a href=\"#欧拉回路和欧拉路径\" class=\"headerlink\" title=\"欧拉回路和欧拉路径\"></a>欧拉回路和欧拉路径</h2><ul>\n<li>欧拉路径问题，每条边走一次<ul>\n<li>经典问题：哥尼斯堡七桥问题</li>\n<li>起点的度数和终点的度数都是奇数，途径点的度数都是偶数</li>\n</ul>\n</li>\n<li>对于无向图，所有边都是连通的<ul>\n<li>存在欧拉路径的充分必要条件：度数为奇数的点只能有 0 或 2 个</li>\n<li>存在欧拉回路的充分必要条件：度数为奇数的点只能有 0 个</li>\n</ul>\n</li>\n<li>对于有向图，所有边都是连通的<ul>\n<li>存在欧拉路径的充分必要条件：要么所有点的出度均等于入度，要么除了两个点之外，其余所有点的出度等于入度，剩余的两个点：一个满足出度比入度多 1（起点），另一个满足入度比出度多 1（终点）</li>\n<li>存在欧拉回路的充分必要条件：所有点的出度均等于入度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AcWing-铲雪车\"><a href=\"#AcWing-铲雪车\" class=\"headerlink\" title=\"AcWing|铲雪车\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyNS8=\">AcWing|铲雪车</span></h3><ul>\n<li>每条路要铲两个方向，就当作是有向图做，必然存在欧拉回路</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()&#123;\n    double x1, y1, x2, y2;\n    cin &gt;&gt; x1 &gt;&gt; y1;\n    double sum = 0;\n    while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)&#123;\n        double dx = x2 - x1, dy = y2 - y1;\n        sum += sqrt(dx * dx + dy * dy) * 2;\n    &#125;\n    int minutes = round(sum / 1000 / 20 * 60);\n    int hours = minutes / 60;\n    minutes %= 60;\n    cout &lt;&lt; hours &lt;&lt; &quot;:&quot; &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; minutes &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-欧拉回路\"><a href=\"#AcWing-欧拉回路\" class=\"headerlink\" title=\"AcWing|欧拉回路\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE4Ni8=\">AcWing|欧拉回路</span></h3><ul>\n<li>无向图<ul>\n<li>所有点的度数必须是偶数</li>\n<li>所有边连通</li>\n</ul>\n</li>\n<li>有向图<ul>\n<li>所有点的入度等于出度</li>\n<li>所有边连通</li>\n</ul>\n</li>\n<li><img data-src=\"https://cdn.acwing.com/media/article/image/2021/06/16/42785_76564c8cce-QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE20210616101308.png\" alt=\"img\"></li>\n<li><img data-src=\"https://cdn.acwing.com/media/article/image/2021/06/16/42785_57cbd99cce-QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE20210616102633.png\" alt=\"img\"></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010, M = 400010;\nint h[N], e[M], ne[M], idx;\nbool used[M];\nint ans[M], cnt;\nint din[N], dout[N];\nint type;\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u)&#123;\n    // 使用引用, 可以直接在i=ne[i]中, 将边删掉\n    for(int &amp;i = h[u]; ~i; )&#123;\n        if(used[i])&#123;\n            i = ne[i];\n            continue;\n        &#125;\n        used[i] = 1;\n        if(type == 1) used[i ^ 1] = 1;\n\n        int t;\n        if(type == 1)&#123;\n            t = i / 2 + 1;      // 边的编号\n            if(i &amp; 1) t = -t;   // 反向边\n        &#125;else&#123;\n            t = i + 1;\n        &#125;\n        int j = e[i];\n        i = ne[i];              // 边用过之后直接删了\n        dfs(j);\n        ans[++cnt] = t;         // 从下往上将点输入到路径中,因为从上往下的过程中,可能边路有些环并没有被顾虑到\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; type &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 0; i &lt; m; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b);\n        if(type == 1)&#123;\n            add(b, a);\n        &#125;\n        din[b]++, dout[a]++;\n    &#125;\n    if(type == 1)&#123;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            if(din[i] + dout[i] &amp; 1)&#123;\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\\n&#39;;\n                return 0;\n            &#125;\n        &#125;\n    &#125;else&#123;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            if(din[i] != dout[i])&#123;\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\\n&#39;;\n                return 0;\n            &#125;\n        &#125;\n    &#125;\n    // 遍历时可能有孤立点--找一个包含边的起点\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(h[i] != -1)&#123;\n            dfs(i);\n            break;\n        &#125;\n    &#125;\n\n    if(cnt &lt; m)&#123;\n        cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\\n&#39;;\n    &#125;else&#123;\n        cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\\n&#39;;\n        for(int i = cnt; i &gt;= 1; i--)&#123;\n            cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;\n        &#125;\n        cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-骑马修栅栏\"><a href=\"#AcWing-骑马修栅栏\" class=\"headerlink\" title=\"AcWing|骑马修栅栏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyNi8=\">AcWing|骑马修栅栏</span></h3><ul>\n<li>要求字典序最小<ul>\n<li>只需要从小往大枚举即可</li>\n<li>先遍历 1 号点（编号从 1 到 n），则 1 号点一定最后被加入欧拉路径。因此只要按照从小到大的点的序号搜，就可以得到字典序最小的欧拉路径（最后逆序输出，最小的点会最后加入 ans)</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 510;\nint n = 500, m;\nint g[N][N];\nint ans[1110], cnt;\nint d[N];\nvoid dfs(int u)&#123;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(g[u][i])&#123;\n            g[u][i]--, g[i][u]--;\n            dfs(i);\n        &#125;\n    &#125;\n    ans[++cnt] = u;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; m;\n    while(m--)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        g[a][b]++, g[b][a]++;\n        d[a]++, d[b]++;\n    &#125;\n    int st = 1;\n    while(!d[st]) st++;\n    for(int i = 1; i &lt;= 500; i++)&#123;\n        if(d[i] % 2)&#123;\n            st = i;\n            break;\n        &#125;\n    &#125;\n    dfs(st);\n    for(int i = cnt; i &gt;= 1; i--)&#123;\n        cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-单词游戏\"><a href=\"#AcWing-单词游戏\" class=\"headerlink\" title=\"AcWing|单词游戏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE4Ny8=\">AcWing|单词游戏</span></h3><ul>\n<li>每个单词可以当作一条有向边，第一个字母连到最后一个字母</li>\n<li>因此本题转换成有向图是否存在欧拉路径</li>\n<li>判断是否连通采用并查集维护<ul>\n<li>度数满足的情况下，如果又是都在同一个集合中，则一定存在欧拉路径</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 30;\nint p[N], din[N], dout[N];\nbool st[N];\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    string s;\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        int n;\n        cin &gt;&gt; n;\n        memset(din, 0, sizeof(din));\n        memset(dout, 0, sizeof(dout));\n        memset(st, 0, sizeof(st));\n        for(int i = 0; i &lt; 26; i++)&#123;\n            p[i] = i;\n        &#125;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            cin &gt;&gt; s;\n            int a = s[0] - &#39;a&#39;, b = s[s.size() - 1] - &#39;a&#39;;\n            st[a] = st[b] = 1;\n            dout[a]++, din[b]++;\n            p[find(a)] = find(b);\n        &#125;\n\n        int start = 0, end = 0;\n        bool ok = 1;\n        for(int i = 0; i &lt; 26; i++)&#123;\n            if(din[i] != dout[i])&#123;\n                if(din[i] == dout[i] + 1) end++;\n                else if(dout[i] == din[i] + 1) start++;\n                else&#123;\n                    ok = 0;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(ok &amp;&amp; !(!start &amp;&amp; !end || start == 1 &amp;&amp; end == 1))&#123;\n            ok = 0;\n        &#125;\n        // 判断连通\n        int rep = -1;\n        for(int i = 0; i &lt; 26; i++)&#123;\n            if(st[i])&#123;\n                if(rep == -1) rep = find(i);\n                else if(rep != find(i))&#123;\n                    ok = 0;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(ok) cout &lt;&lt; &quot;Ordering is possible.\\n&quot;;\n        else cout &lt;&lt; &quot;The door cannot be opened.\\n&quot;;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><ul>\n<li>对有向图来说, 如果有环必然不存在拓扑排序，拓扑图等价于有向无环图（DAG）</li>\n<li>先将所有入度为 0 的点入队</li>\n<li>宽搜框架，将每次更新完入度为 0 的点入队</li>\n<li>要求字典序最小的时候，可以将队列换成小根堆</li>\n</ul>\n<h3 id=\"AcWing-家谱树\"><a href=\"#AcWing-家谱树\" class=\"headerlink\" title=\"AcWing|家谱树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE5Mw==\">AcWing|家谱树</span></h3><ul>\n<li>队列中的顺序即为拓扑序</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110, M = N * N / 2;\nint h[N], e[M], ne[M], idx;\nint din[N], n;\nint q[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid toposort()&#123;\n    int hh = 0, tt = -1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!din[i])&#123;\n            q[++tt] = i;\n        &#125;\n    &#125;\n    while(hh &lt;= tt)&#123;\n        int t = q[hh++];\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            din[j]--;\n            if(!din[j])&#123;\n                q[++tt] = j;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        while(cin &gt;&gt; x, x)&#123;\n            add(i, x);\n            din[x]++;\n        &#125;\n    &#125;\n    toposort();\n    for(int i = 0; i &lt; n; i++)&#123;\n        cout &lt;&lt; q[i] &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-奖金\"><a href=\"#AcWing-奖金\" class=\"headerlink\" title=\"AcWing|奖金\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE5NC8=\">AcWing|奖金</span></h3><ul>\n<li>差分约束简化版</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 20010;\nint h[N], e[N], ne[N], idx;\nint deg[N];\nint dist[N];\nint n, m, cnt;\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid toposort()&#123;\n    queue&lt;int&gt; q;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!deg[i])&#123;\n            q.push(i);\n            dist[i] = 100;\n        &#125;\n    &#125;\n    while(!q.empty())&#123;\n        int t = q.front();\n        q.pop();\n        cnt++;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            deg[j]--;\n            if(!deg[j])&#123;\n                q.push(j);\n                dist[j] = dist[t] + 1;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(b, a);\n        deg[a]++;\n    &#125;\n    toposort();\n    if(cnt &lt; n) cout &lt;&lt; &quot;Poor Xed\\n&quot;;\n    else&#123;\n        int res = 0;\n        for(int i = 1; i &lt;= cnt; i++)&#123;\n            res += dist[i];\n        &#125;\n        cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-可达性统计\"><a href=\"#AcWing-可达性统计\" class=\"headerlink\" title=\"AcWing|可达性统计\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY2Lw==\">AcWing|可达性统计</span></h3><ul>\n<li>有向无环图，因此可以 dp</li>\n<li>先拓扑排序，再倒着推</li>\n<li>集合用二进制表示</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 30010, M = 30010;\nint h[N], e[M], ne[M], idx;\nint deg[N];\nint q[N];\nint n, m;\nbitset&lt;N&gt; f[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid toposort()&#123;\n    int hh = 0, tt = -1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!deg[i])&#123;\n            q[++tt] = i;\n        &#125;\n    &#125;\n    while(hh &lt;= tt)&#123;\n        int t = q[hh++];\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            deg[j]--;\n            if(!deg[j])&#123;\n                q[++tt] = j;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b);\n        deg[b]++;\n    &#125;\n    toposort();\n    for(int i = n - 1; i &gt;= 0; i--)&#123;\n        int j = q[i];\n        f[j][j] = 1;\n        for(int k = h[j]; ~k; k = ne[k])&#123;\n            int l = e[k];\n            f[j] |= f[l];\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cout &lt;&lt; f[i].count() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-车站分级\"><a href=\"#AcWing-车站分级\" class=\"headerlink\" title=\"AcWing|车站分级\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDU4\">AcWing|车站分级</span></h3><ul>\n<li>建立虚拟节点，将边数减少，再拓扑排序解决，同上《奖杯》</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 2010, M = 1000010;\nint n, m;\nint h[N], e[M], ne[M], w[M], idx;\nint deg[N], vis[N];\nint q[N];\nint dist[N];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n    deg[b]++;\n&#125;\nvoid toposort()&#123;\n    int hh = 0, tt = -1;\n    for(int i = 1; i &lt;= n + m; i++)&#123;\n        if(!deg[i])&#123;\n            q[++tt] = i;\n        &#125;\n        // if(tt == N) tt = 0;\n    &#125;\n    while(hh &lt;= tt)&#123;\n        int t = q[hh++];\n        // if(hh == N) hh = 0;\n        for(int i = h[t]; ~i; i = ne[i])&#123;\n            int j = e[i];\n            if(--deg[j] == 0)&#123;\n                q[++tt] = j;\n                // if(tt == N) tt = 0;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int s;\n        cin &gt;&gt; s;\n        memset(vis, 0, sizeof(vis));\n        int stop, start = n, end = 1;\n        while(s--)&#123;\n            cin &gt;&gt; stop;\n            vis[stop] = 1;\n            start = min(start, stop);\n            end = max(end, stop);\n        &#125;\n        int ver = n + i;\n        for(int j = start; j &lt;= end; j++)&#123;\n            if(!vis[j])&#123;\n                add(j, ver, 0);\n            &#125;else&#123;\n                add(ver, j, 1);\n            &#125;\n        &#125;\n    &#125;\n\n    toposort();\n    for(int i = 1; i &lt;= n; i++)&#123;\n        dist[i] = 1;\n    &#125;\n    for(int i = 0; i &lt; n + m; i++)&#123;\n        int j = q[i];\n        for(int k = h[j]; ~k; k = ne[k])&#123;\n            int l = e[k];\n            dist[l] = max(dist[l], dist[j] + w[k]);\n        &#125;\n    &#125;\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        ans = max(ans, dist[i]);\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板",
                "题集"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html",
            "url": "https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E9%A2%98%E9%9B%86.html",
            "title": "搜索题集",
            "date_published": "2022-03-08T10:00:20.000Z",
            "content_html": "<blockquote>\n<p>包括 BFS 中的 Flood Fill、最短路模型、多源 BFS、最小步数模型、双端队列广搜、双向广搜、A-Star 以及 DFS 中的连通性模型、DFS 之搜索顺序、DFS 之剪枝与优化、迭代加深、双向 DFS、IDA* 等</p>\n</blockquote>\n<h2 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h2><ol>\n<li>求最小，最短</li>\n<li>基于迭代、不会爆栈</li>\n</ol>\n<h3 id=\"Flood-Fill\"><a href=\"#Flood-Fill\" class=\"headerlink\" title=\"Flood Fill\"></a>Flood Fill</h3><ul>\n<li>可以在线性时间复杂度内，找到某个点所在的连通块</li>\n</ul>\n<h4 id=\"AcWing-池塘计数\"><a href=\"#AcWing-池塘计数\" class=\"headerlink\" title=\"AcWing|池塘计数\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA5OS8=\">AcWing|池塘计数</span></h4><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 1010;\nstring g[N];\nbool vis[N][N];\nint n, m, ans;\nvoid bfs(int x, int y)&#123;\n    queue&lt;PII&gt; q;\n    q.push(PII(x, y));\n    vis[x][y] = 1;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        int x = t.first, y = t.second;\n        for(int i = x - 1; i &lt;= x + 1; i++)&#123;\n            for(int j = y - 1; j &lt;= y + 1; j++)&#123;\n                if(i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m || vis[i][j] || g[i][j] == &#39;.&#39;) continue;\n                vis[i][j] = 1;\n                q.push(PII(i, j));\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            if(g[i][j] == &#39;W&#39; &amp;&amp; !vis[i][j])&#123;\n                ans++;\n                bfs(i, j);\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-城堡问题\"><a href=\"#AcWing-城堡问题\" class=\"headerlink\" title=\"AcWing|城堡问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwMC8=\">AcWing|城堡问题</span></h4><ul>\n<li>使用状态压缩可以简单地处理每个状态</li>\n<li>原题更复杂</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 60;\nbool st[N][N];\nint g[N][N];\nint n, m;\nint bfs(int x, int y)&#123;\n    int dx[4] = &#123;0, -1, 0, 1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;\n    queue&lt;PII&gt; q;\n    q.push(&#123;x, y&#125;);\n    st[x][y] = 1;\n    int ans = 0;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        ans++;\n        int x = t.first, y = t.second;\n        for(int i = 0; i &lt; 4; i++)&#123;\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; m || st[nx][ny]) continue;\n            if(g[x][y] &gt;&gt; i &amp; 1) continue;\n            q.push(&#123;nx, ny&#125;);\n            st[nx][ny] = 1;\n        &#125;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            cin &gt;&gt; g[i][j];\n        &#125;\n    &#125;\n    int cnt = 0, area = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            if(!st[i][j])&#123;\n                area = max(area, bfs(i, j));\n                cnt++;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39; &lt;&lt; area &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-山峰和山谷\"><a href=\"#AcWing-山峰和山谷\" class=\"headerlink\" title=\"AcWing|山峰和山谷\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwOC8=\">AcWing|山峰和山谷</span></h4><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 1010, M = N * N;\nint n;\nint h[N][N];\nbool st[N][N];\nvoid bfs(int x, int y, bool&amp; has_higher, bool&amp; has_lower)&#123;\n    queue&lt;PII&gt; q;\n    q.push(&#123;x, y&#125;);\n    st[x][y] = 1;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        for(int i = t.first - 1; i &lt;= t.first + 1; i++)&#123;\n            for(int j = t.second - 1; j &lt;= t.second + 1; j++)&#123;\n                if(i == t.first &amp;&amp; j == t.second) continue;\n                if(i &lt;= 0 || i &gt; n || j &lt;= 0 || j &gt; n) continue;\n                if(h[i][j] != h[t.first][t.second])&#123;\n                    if(h[i][j] &gt; h[t.first][t.second]) has_higher = 1;\n                    else has_lower = 1;\n                &#125;else if(!st[i][j])&#123;\n                    q.push(&#123;i, j&#125;);\n                    st[i][j] = 1;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            cin &gt;&gt; h[i][j];\n        &#125;\n    &#125;\n    int peak = 0, valley = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= n; j++)&#123;\n            if(!st[i][j])&#123;\n                bool has_higher = 0, has_lower = 0;\n                bfs(i, j, has_higher, has_lower);\n                if(!has_higher) peak++;\n                if(!has_lower) valley++;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; peak &lt;&lt; &#39; &#39; &lt;&lt; valley &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"最短路模型\"><a href=\"#最短路模型\" class=\"headerlink\" title=\"最短路模型\"></a>最短路模型</h3><ul>\n<li>小证明<ul>\n<li>队列中的所有元素具有<ul>\n<li>两段性 $x, x + 1$ （最多有两段）</li>\n<li>单调性，队列前面的元素一定小于等于后加入的元素</li>\n</ul>\n</li>\n<li>使用数学归纳法证明<ul>\n<li>类比堆优化版 Dijkstra</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AcWing-迷宫问题\"><a href=\"#AcWing-迷宫问题\" class=\"headerlink\" title=\"AcWing|迷宫问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3OC8=\">AcWing|迷宫问题</span></h4><ul>\n<li>从终点开始 BFS，遍历前驱节点时即可不需要倒序输出</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 1010;\nint n;\nint g[N][N];\nPII pre[N][N];\nvoid bfs(int x, int y)&#123;\n    int dx[4] = &#123;0, -1, 0, 1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;\n    queue&lt;PII&gt; q;\n    q.push(&#123;x, y&#125;);\n    memset(pre, -1, sizeof(pre));\n    pre[x][y] = &#123;0, 0&#125;;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        for(int i = 0; i &lt; 4; i++)&#123;\n            int nx = t.first + dx[i], ny = t.second + dy[i];\n            if(g[nx][ny]) continue;\n            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || pre[nx][ny].first != -1) continue;\n            q.push(&#123;nx, ny&#125;);\n            pre[nx][ny] = &#123;t.first, t.second&#125;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            cin &gt;&gt; g[i][j];\n        &#125;\n    &#125;\n    bfs(n - 1, n - 1);\n    PII end = &#123;0, 0&#125;;\n    while(1)&#123;\n        cout &lt;&lt; end.first &lt;&lt; &quot; &quot; &lt;&lt; end.second &lt;&lt; &#39;\\n&#39;;\n        if(end.first == n - 1 &amp;&amp; end.second == n - 1) break;\n        end = pre[end.first][end.second];\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-武士风度的牛\"><a href=\"#AcWing-武士风度的牛\" class=\"headerlink\" title=\"AcWing|武士风度的牛\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTkwLw==\">AcWing|武士风度的牛</span></h4><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 160;\nstring g[N];\nint n, m;\nbool st[N][N];\nint dis[N][N];\nint dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;, dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;\nint bfs(int x, int y)&#123;\n    queue&lt;PII&gt; q;\n    q.push(&#123;x, y&#125;);\n    st[x][y] = 1;\n    memset(dis, -1, sizeof(dis));\n    dis[x][y] = 0;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        int a = t.first, b = t.second;\n        for(int i = 0; i &lt; 8; i++)&#123;\n            int nx = a + dx[i], ny = b + dy[i];\n            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || st[nx][ny] || g[nx][ny] == &#39;*&#39;) continue;\n            if(dis[nx][ny] != -1) continue;\n            if(g[nx][ny] == &#39;H&#39;) return dis[a][b] + 1;\n            q.push(&#123;nx, ny&#125;);\n            dis[nx][ny] = dis[a][b] + 1;\n            st[nx][ny] = 1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; m &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n    int ans;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            if(g[i][j] == &#39;K&#39;)&#123;\n                ans = bfs(i, j);\n                break;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-抓住那头牛\"><a href=\"#AcWing-抓住那头牛\" class=\"headerlink\" title=\"AcWing|抓住那头牛\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwMi8=\">AcWing|抓住那头牛</span></h4><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, k;\nint dis[N];\nint bfs()&#123;\n    memset(dis, -1, sizeof(dis));\n    queue&lt;int&gt; q;\n    dis[n] = 0;\n    q.push(n);\n    while(q.size())&#123;\n        int t = q.front(); q.pop();\n        if(t == k) return dis[t];\n        if(t + 1 &lt; N &amp;&amp; dis[t + 1] == -1)&#123;\n            dis[t + 1] = dis[t] + 1;\n            q.push(t + 1);\n        &#125;\n        if(t - 1 &gt;= 0 &amp;&amp; dis[t - 1] == -1)&#123;\n            dis[t - 1] = dis[t] + 1;\n            q.push(t - 1);\n        &#125;\n        if(t * 2 &lt; N &amp;&amp; dis[t * 2] == -1)&#123;\n            dis[t * 2] = dis[t] + 1;\n            q.push(t * 2);\n        &#125;\n    &#125;\n    return -1;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; k;\n    cout &lt;&lt; bfs() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"多源-BFS\"><a href=\"#多源-BFS\" class=\"headerlink\" title=\"多源 BFS\"></a>多源 BFS</h3><h4 id=\"AcWing-矩阵距离\"><a href=\"#AcWing-矩阵距离\" class=\"headerlink\" title=\"AcWing|矩阵距离\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTc1Lw==\">AcWing|矩阵距离</span></h4><ul>\n<li>本题有多个起点，可以转换成从源点到每个点的最短距离，源点到每个起点的边权都为 $0$</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010;\ntypedef pair&lt;int, int&gt; PII;\nstring g[N];\nint n, m;\nint dis[N][N];\nint dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\nvoid bfs()&#123;\n    memset(dis, -1, sizeof(dis));\n    queue&lt;PII&gt; q;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            if(g[i][j] == &#39;1&#39;)&#123;\n                dis[i][j] = 0;\n                q.push(PII(i, j));\n            &#125;\n        &#125;\n    &#125;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        int x = t.first, y = t.second;\n        for(int i = 0; i &lt; 4; i++)&#123;\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue;\n            if(g[nx][ny] == &#39;0&#39; &amp;&amp; dis[nx][ny] == -1)&#123;\n                dis[nx][ny] = dis[x][y] + 1;\n                q.push(PII(nx, ny));\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n    bfs();\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            cout &lt;&lt; dis[i][j] &lt;&lt; &#39; &#39;;\n        &#125;\n        cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"最小步数模型\"><a href=\"#最小步数模型\" class=\"headerlink\" title=\"最小步数模型\"></a>最小步数模型</h3><ul>\n<li>典型例题 「八数码」</li>\n<li>通常使用哈希存储状态&#x2F;康托展开</li>\n</ul>\n<h4 id=\"AcWing-魔板\"><a href=\"#AcWing-魔板\" class=\"headerlink\" title=\"AcWing|魔板\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEwOS8=\">AcWing|魔板</span></h4><ul>\n<li>BFS 时按照 「ABC」的顺序依次遍历，即可满足字典序最小的条件</li>\n<li>三种操作模拟一遍即可</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nchar g[2][4];\nunordered_map&lt;string, pair&lt;char, string&gt;&gt; pre;\nunordered_map&lt;string, int&gt; dis;\nvoid set_string(string st)&#123;\n    for(int i = 0; i &lt; 4; i++) g[0][i] = st[i];\n    for(int i = 7, j = 0; j &lt; 4; i--, j++) g[1][j] = st[i];\n&#125;\nstring get()&#123;\n    string res;\n    for(int i = 0; i &lt; 4; i++) res += g[0][i];\n    for(int i = 3; i &gt;= 0; i--) res += g[1][i];\n    return res;\n&#125;\nstring move0(string st)&#123;\n    set_string(st);\n    for(int i = 0; i &lt; 4; i++) swap(g[0][i], g[1][i]);\n    return get();\n&#125;\nstring move1(string st)&#123;\n    set_string(st);\n    for(int i = 3; i &gt;= 1; i--)&#123; \n        swap(g[0][i], g[0][i - 1]);\n        swap(g[1][i], g[1][i - 1]);\n    &#125;\n    return get();\n&#125;\nstring move2(string st)&#123;\n    set_string(st);\n    char tmp = g[0][1];\n    g[0][1] = g[1][1];\n    g[1][1] = g[1][2];\n    g[1][2] = g[0][2];\n    g[0][2] = tmp;\n    return get();\n&#125;\nint bfs(string st, string ed)&#123;\n    if(st == ed) return 0;\n    queue&lt;string&gt; q;\n    q.push(st);\n    dis[st] = 0;\n    while(q.size())&#123;\n        auto t = q.front(); q.pop();\n        string m[3];\n        m[0] = move0(t);\n        m[1] = move1(t);\n        m[2] = move2(t);\n        for(int i = 0; i &lt; 3; i++)&#123;\n            if(!dis.count(m[i]))&#123;\n                dis[m[i]] = dis[t] + 1;\n                pre[m[i]] = make_pair(&#39;A&#39; + i, t);\n                q.push(m[i]);\n                if(m[i] == ed) return dis[m[i]];\n            &#125;\n        &#125;\n    &#125;\n    return -1;\n&#125;\nint main()&#123;\n    int x;\n    string st, ed;\n    for(int i = 0; i &lt; 8; i++)&#123;\n        cin &gt;&gt; x;\n        ed += char(x + &#39;0&#39;);\n    &#125;\n    for(int i = 1; i &lt;= 8; i++) st += char(i + &#39;0&#39;);\n    int step = bfs(st, ed);\n    cout &lt;&lt; step &lt;&lt; &#39;\\n&#39;;\n    string ans;\n    while(ed != st)&#123;\n        ans += pre[ed].first;\n        ed = pre[ed].second;\n    &#125;\n    reverse(ans.begin(), ans.end());\n    if(step &gt; 0) cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"双端队列广搜\"><a href=\"#双端队列广搜\" class=\"headerlink\" title=\"双端队列广搜\"></a>双端队列广搜</h3><h4 id=\"AcWing-电路维修\"><a href=\"#AcWing-电路维修\" class=\"headerlink\" title=\"AcWing|电路维修\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTc3Lw==\">AcWing|电路维修</span></h4><ul>\n<li>可以看作是有两种边权的路，需要旋转的边权为 $1$，不需要的边权为 $0$</li>\n<li>假如起点与终点奇偶条件（横纵坐标之和）不一样则无解</li>\n<li>假如扩展的边权为 $1$ 则插入到队尾，否则插入到队头</li>\n<li>第一个偏移量是以格点为中心向四周移动</li>\n<li>第二个偏移量是以格点为中心向四周移动时经过的方格</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 510, M = N * N;\nint n, m;\nstring g[N];\nint dis[N][N];\nbool st[N][N];\nint bfs()&#123;\n    memset(dis, 0x3f, sizeof(dis));\n    memset(st, 0, sizeof(st));\n    dis[0][0] = 0;\n    deque&lt;PII&gt; q;\n    q.push_back(PII(0, 0));\n\n    char cs[] = &quot;\\\\/\\\\/&quot;;\n    int dx[4] = &#123;-1, -1, 1, 1&#125;, dy[4] = &#123;-1, 1, 1, -1&#125;;\n    int ix[4] = &#123;-1, -1, 0, 0&#125;, iy[4] = &#123;-1, 0, 0, -1&#125;;\n\n    while(q.size())&#123;\n        auto t = q.front(); q.pop_front();\n        int x = t.first, y = t.second;\n        if(st[x][y]) continue;\n        st[x][y] = true;\n        for(int i = 0; i &lt; 4; i++)&#123;\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx &lt; 0 || nx &gt; n || ny &lt; 0 || ny &gt; m) continue;\n            int cx = x + ix[i], cy = y + iy[i];\n            int d = dis[x][y] + (g[cx][cy] != cs[i]);\n            if(d &lt; dis[nx][ny])&#123;\n                dis[nx][ny] = d;\n                if(g[cx][cy] != cs[i]) q.push_back(&#123;nx, ny&#125;);\n                else q.push_front(&#123;nx, ny&#125;);\n            &#125;\n        &#125;\n    &#125;\n    return dis[n][m];\n&#125;\nvoid solve()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n    int t = bfs();\n    if(t == 0x3f3f3f3f) cout &lt;&lt; &quot;NO SOLUTION\\n&quot;;\n    else cout &lt;&lt; t &lt;&lt; &#39;\\n&#39;;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h3 id=\"双向广搜\"><a href=\"#双向广搜\" class=\"headerlink\" title=\"双向广搜\"></a>双向广搜</h3><ul>\n<li>朴素版扩展</li>\n<li>每次选择当前元素较少的队列扩展</li>\n</ul>\n<h4 id=\"AcWing-字符变换🌸\"><a href=\"#AcWing-字符变换🌸\" class=\"headerlink\" title=\"AcWing|字符变换🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTkyLw==\">AcWing|字符变换</span>🌸</h4><ul>\n<li>可以把每一种字符串看作是一个点，所有的变化方案可以形成一张图，求最短路</li>\n<li>每次扩展需要 <strong>扩展一层</strong></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 6;\nint n; \nstring A, B;\nstring a[N], b[N];\nint extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp; da, unordered_map&lt;string, int&gt;&amp; db, string a[], string b[])&#123;\n    int d = da[q.front()];\n    while(q.size() &amp;&amp; da[q.front()] == d)&#123;\t// 扩展一层\n        auto t = q.front(); q.pop();\n        for(int i = 0; i &lt; n; i++)&#123;\n            for(int j = 0; j &lt; t.size(); j++)&#123;\n                if(t.substr(j, a[i].size()) == a[i])&#123;\n                    string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size());\n                    if(db.count(r)) return da[t] + db[r] + 1;\n                    if(!da.count(r))&#123;\n                        da[r] = da[t] + 1;\n                        q.push(r);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return 11;\n&#125;\nint bfs()&#123;\n    if(A == B) return 0;\n    queue&lt;string&gt; qa, qb;\n    unordered_map&lt;string, int&gt; da, db;\n    qa.push(A); da[A] = 0;\n    qb.push(B); db[B] = 0;\n    int step = 0;\n    while(qa.size() &amp;&amp; qb.size())&#123;\n        int t;\n        if(qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b);\n        else t = extend(qb, db, da, b, a);\n        if(t &lt;= 10) return t;\n        if(++step == 10) return -1;\n    &#125;\n    return -1;\n&#125;\nint main()&#123;\n    cin &gt;&gt; A &gt;&gt; B;\n    while(cin &gt;&gt; a[n] &gt;&gt; b[n]) n++;\n    int ans = bfs();\n    if(ans == -1) cout &lt;&lt; &quot;NO ANSWER!\\n&quot;;\n    else cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"A-Star\"><a href=\"#A-Star\" class=\"headerlink\" title=\"A-Star\"></a>A-Star</h3><ul>\n<li>启发函数<ul>\n<li>只需要搜索非常少的状态即可到达终点</li>\n</ul>\n</li>\n<li>把 BFS 中的队列换成优先队列</li>\n<li>队列中存「从起点到当前点的真实距离和从当前点到终点的估计距离」，按和的权重排序</li>\n<li>当终点第一次出队的时候 <code>break</code></li>\n<li><del>Dijkstra 可以看作是从当前点到终点的估计距离为 $0$ 的 A-Star 算法</del></li>\n<li>如果无解就不要用 A-Star 算法</li>\n<li>只能保证到终点的距离是最优</li>\n</ul>\n<pre><code>A* 应用场景:\n起点→终点的最短距离\n状态空间 &gt;&gt; 1e10 \n启发函数减小搜索空间\n\nA*算法:\nwhile(q.size())\n    t ← 优先队列的队头  小根堆\n        当终点第一次出队时 break;\n        从起点到当前点的真实距离 d_real\n        从当前点到终点的估计距离 d_estimate\n        选择一个估计距离最小的点 min(d_estimate)\n    for j in ne[t]:\n        将邻边入队\n\nA*算法条件:\n估计距离&lt;=真实距离\nd[state] + f[state] = 起点到state的真实距离 + state到终点的估计距离=估计距离\n                                                                       ^\nd[state] + g[state] = 起点到state的真实距离 + state到终点的真实距离=真实距离\n\n一定是有解才有 d[i]   &gt;= d[最优] = d[u]+f[u]\n        f[u] &gt;= 0\n\n证明终点第一次出队列即最优解\n\n    1 假设终点第一次出队列时不是最优 \n      则说明当前队列中存在点u\n         有 d[估计]&lt; d[真实]\n      d[u] + f[u] &lt;= d[u] + g[u] = d[队头终点]\n      即队列中存在比d[终点]小的值,\n    2 但我们维护的是一个小根堆,没有比d[队头终点]小的d[u],矛盾\n\n    证毕\n\nA* 不用判重\n以边权都为1为例\n  A o→o→o\n    ↑   ↓\n  S o→o→o→o→o→o→o T\n      B\ndist[A] = dist[S]+1 + f[A] = 7\ndist[B] = dist[S]+1 + f[B] = 5\n则会优先从B这条路走到T\nB走到T后再从A这条路走到T\n\n作者：仅存老实人\n链接：https://www.acwing.com/solution/content/21233/\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n<h4 id=\"AcWing-八数码🌸\"><a href=\"#AcWing-八数码🌸\" class=\"headerlink\" title=\"AcWing|八数码🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgxLw==\">AcWing|八数码</span>🌸</h4><ul>\n<li>有解的充分必要条件是读出来排列好的数字序列中，逆序对的数量是偶数</li>\n<li>估价函数：当前状态中每个数与它的目标位置的曼哈顿距离之和</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzM1NTI4Lw==\">较好的题解</span></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint f(string st)&#123;\n    int res = 0;\n    for(int i = 0; i &lt; st.size(); i++)&#123;\n        if(st[i] != &#39;x&#39;)&#123;\n            int t = st[i] - &#39;1&#39;;\n            res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3);\n        &#125;\n    &#125;\n    return res;\n&#125;\nstring bfs(string start)&#123;\n    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\n    char op[4] = &#123;&#39;u&#39;, &#39;r&#39;, &#39;d&#39;, &#39;l&#39;&#125;;\n    string ed = &quot;12345678x&quot;;\n    unordered_map&lt;string, int&gt; dis;\n    unordered_map&lt;string, pair&lt;string, char&gt;&gt; pre;\n    priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; q;\n\n    dis[start] = 0;\n    q.push(&#123;f(start), start&#125;);\n    while(q.size())&#123;\n        auto t = q.top(); q.pop();\n        if(t.second == ed) break;\n        int x, y;\n        for(int i = 0; i &lt; 9; i++)&#123;\n            if(t.second[i] == &#39;x&#39;)&#123;\n                x = i / 3, y = i % 3;\n                break;\n            &#125;\n        &#125;\n        string source = t.second;\n        for(int i = 0; i &lt; 4; i++)&#123;\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx &gt;= 0 &amp;&amp; nx &lt; 3 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 3)&#123;\n                swap(t.second[3 * nx + ny], t.second[3 * x + y]);\n                if(!dis.count(t.second) || dis[t.second] &gt; dis[source] + 1)&#123;\n                    dis[t.second] = dis[source] + 1;\n                    pre[t.second] = &#123;source, op[i]&#125;;\n                    q.push(&#123;dis[t.second] + f(t.second), t.second&#125;);\n                &#125;\n                swap(t.second[3 * nx + ny], t.second[3 * x + y]);\n            &#125;\n        &#125;\n    &#125;\n    string ans;\n    while(ed != start)&#123;\n        ans += pre[ed].second;\n        ed = pre[ed].first;\n    &#125;\n    reverse(ans.begin(), ans.end());\n    return ans;\n&#125;\nint main()&#123;\n    string g, c, seq;\n    for(int i = 0; i &lt;= 8; i++)&#123;\n        cin &gt;&gt; c;\n        g += c;\n        if(c != &quot;x&quot;) seq += c;\n    &#125;\n    int t = 0;\n    for(int i = 0; i &lt; seq.size(); i++)&#123;\n        for(int j = i + 1; j &lt;= seq.size(); j++)&#123;\n            if(seq[i] &gt; seq[j]) t++;\n        &#125;\n    &#125;\n    if(t % 2) cout &lt;&lt; &quot;unsolvable\\n&quot;;\n    else cout &lt;&lt; bfs(g) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-第-K-短路🌖\"><a href=\"#AcWing-第-K-短路🌖\" class=\"headerlink\" title=\"AcWing|第 K 短路🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgwLw==\">AcWing|第 K 短路</span>🌖</h4><ul>\n<li><del>正解是可持久化可并堆</del></li>\n<li>把当前点能扩展到的点全部加进去</li>\n<li>弹出第 $k$ 次，即第 $k$ 小</li>\n<li>建反向边 Dijkstra 求各点到终点的距离作为估计值 $f[u]$</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\ntypedef tuple&lt;int, int, int&gt; TIII;\nconst int N = 1010, M = 2e5 + 10;   // 需要反向建边\nint n, m, S, T, K;\nint h[N], rh[N], e[M], w[M], ne[M], idx;\nint dist[N];\nbool st[N];\nvoid add(int h[], int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\n// 反向 Dijkstra 求估价，dist 存的是该点到终点的最小距离\nvoid dijkstra()&#123;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;\n    pq.push(&#123;0, T&#125;);    // 距离，点编号\n    memset(dist, 0x3f, sizeof(dist));\n    dist[T] = 0;\n    while(pq.size())&#123;\n        auto t = pq.top(); pq.pop();\n        int ver = t.second;\n        if(st[ver]) continue;\n        st[ver] = true;\n        // 反向图上遍历\n        for(int i = rh[ver]; ~i; i = ne[i])&#123;\n            int to = e[i];\n            if(dist[to] &gt; dist[ver] + w[i])&#123;\n                dist[to] = dist[ver] + w[i];\n                pq.push(&#123;dist[to], to&#125;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint astar()&#123;\n    priority_queue&lt;TIII, vector&lt;TIII&gt;, greater&lt;TIII&gt;&gt; pq;\n    pq.push(&#123;0 + dist[S], 0, S&#125;);\n    int cnt = 0;\n    if(dist[S] == 0x3f3f3f3f) return -1;\n    while(pq.size())&#123;\n        auto t = pq.top(); pq.pop();\n        int ver = get&lt;2&gt;(t), distance = get&lt;1&gt;(t);\n        if(ver == T) cnt++;\n        if(cnt == K) return distance;\n        // 正向扩展所有的边\n        // 用起点到该点的真实距离 + 该点到终点的估价距离作为标准\n        for(int i = h[ver]; ~i; i = ne[i])&#123;\n            int to = e[i];\n            pq.push(&#123;distance + w[i] + dist[to], distance + w[i], to&#125;);\n        &#125;\n    &#125;\n    return -1;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    memset(rh, -1, sizeof(rh));\n    for(int i = 0; i &lt; m; i++)&#123;\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(h, a, b, c);\n        add(rh, b, a, c);\n    &#125;\n    cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;\n    if(S == T) K++;\n    dijkstra();\n    cout &lt;&lt; astar() &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h2 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h2><h3 id=\"DFS-之连通性模型\"><a href=\"#DFS-之连通性模型\" class=\"headerlink\" title=\"DFS 之连通性模型\"></a>DFS 之连通性模型</h3><h4 id=\"AcWing-迷宫\"><a href=\"#AcWing-迷宫\" class=\"headerlink\" title=\"AcWing|迷宫\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExNC8=\">AcWing|迷宫</span></h4><ul>\n<li>第一次搜索到终点时只能求出来是否连通，不能解决最短路问题</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\nbool st[N][N];\nstring g[N];\nint n, xa, ya, xb, yb;\nint dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;\nbool dfs(int x, int y)&#123;\n    if(g[x][y] == &#39;#&#39;) return false;\n    if(x == xb &amp;&amp; y == yb) return true;\n    for(int i = 0; i &lt; 4; i++)&#123;\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n) continue;\n        if(st[nx][ny]) continue;\n        if(g[nx][ny] == &#39;#&#39;) continue;\n        st[nx][ny] = true;\n        if(dfs(nx, ny)) return true;\n    &#125;\n    return false;\n&#125;\nvoid solve()&#123;\n    memset(st, 0, sizeof(st));\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n    cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n    if(dfs(xa, ya)) cout &lt;&lt; &quot;YES\\n&quot;;\n    else cout &lt;&lt; &quot;NO\\n&quot;;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h4 id=\"AcWing-红与黑\"><a href=\"#AcWing-红与黑\" class=\"headerlink\" title=\"AcWing|红与黑\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExNS8=\">AcWing|红与黑</span></h4><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 25;\nint n, m;\nbool st[N][N];\nstring g[N];\nint dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;\nint dfs(int x, int y)&#123;\n    int cnt = 1;\n    st[x][y] = true;\n    for(int i = 0; i &lt; 4; i++)&#123;\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue;\n        if(st[nx][ny]) continue;\n        if(g[nx][ny] == &#39;#&#39;) continue;\n        st[nx][ny] = true;\n        cnt += dfs(nx, ny);\n    &#125;\n    return cnt;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    while(cin &gt;&gt; m &gt;&gt; n)&#123;\n        if(m == 0 &amp;&amp; n == 0) break;\n        memset(st, 0, sizeof(st));\n        int stx, sty;\n        for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];\n        for(int i = 0; i &lt; n; i++)&#123;\n            for(int j = 0; j &lt; m; j++)&#123;\n                if(g[i][j] == &#39;@&#39;)&#123;\n                    stx = i; sty = j;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; dfs(stx, sty) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"DFS-之搜索顺序\"><a href=\"#DFS-之搜索顺序\" class=\"headerlink\" title=\"DFS 之搜索顺序\"></a>DFS 之搜索顺序</h3><ul>\n<li>把棋盘整体当作一个状态进行变化是外部搜索</li>\n<li>在棋盘内部进行变化是内部搜索</li>\n</ul>\n<h4 id=\"AcWing-马走日\"><a href=\"#AcWing-马走日\" class=\"headerlink\" title=\"AcWing|马走日\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExOC8=\">AcWing|马走日</span></h4><ul>\n<li>每个状态对应一个节点，需要回溯</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 10;\nbool st[N][N];\nint ans, n, m;\nint dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;, dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;\nvoid dfs(int x, int y, int cnt)&#123;\n    if(cnt == n * m)&#123;\n        ans++;\n        return;\n    &#125;\n    st[x][y] = true;\n    for(int i = 0; i &lt; 8; i++)&#123;\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || st[nx][ny]) continue;\n        dfs(nx, ny, cnt + 1);\n    &#125;\n    st[x][y] = false;\n&#125;\nvoid solve()&#123;\n    int a, b;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;\n    ans = 0;\n    dfs(a, b, 1);\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;    \nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h4 id=\"AcWing-单词接龙\"><a href=\"#AcWing-单词接龙\" class=\"headerlink\" title=\"AcWing|单词接龙\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTExOS8=\">AcWing|单词接龙</span></h4><ul>\n<li>先预处理能接在某个单词后的单词和重叠长度</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 21;\nint n, ans;\nstring word[N];\nint g[N][N];\nint vis[N];\nvoid dfs(string dragon, int last)&#123;\n    ans = max((int)dragon.size(), ans);\n    vis[last]++;\n    for(int i = 0; i &lt; n; i++)&#123;\n        if(vis[i] == 2) continue;\n        if(g[last][i])&#123;\n            dfs(dragon + word[i].substr(g[last][i]), i);\n        &#125;\n    &#125;\n    vis[last]--;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; word[i];\n    char st;\n    cin &gt;&gt; st;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            string a = word[i], b = word[j];\n            for(int k = 1; k &lt; min(a.size(), b.size()); k++)&#123;\n                if(a.substr(a.size() - k, k) == b.substr(0, k))&#123;\n                    g[i][j] = k;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for(int i = 0; i &lt; n; i++)&#123;\n        if(word[i][0] == st) dfs(word[i], i);\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-分成互质组\"><a href=\"#AcWing-分成互质组\" class=\"headerlink\" title=\"AcWing|分成互质组\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEyMC8=\">AcWing|分成互质组</span></h4><ul>\n<li>把某个数加到当前的最后一组中</li>\n<li>新开一个组放这个数</li>\n<li>要按照组合的方法搜索，不能按照排列的方法搜索</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 11;\nint n, ans;\nint num[N];\nint group[N][N];\nbool vis[N];\nint gcd(int a, int b)&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\nbool check(int u[], int uc, int n)&#123;\n    for(int i = 0; i &lt; uc; i++)&#123;\n        if(gcd(u[i], num[n]) != 1) return false;\n    &#125;\n    return true;\n&#125;\nvoid dfs(int u, int uc, int tot, int start)&#123;    // 当前组的编号，组内元素个数，总的元素个数，当前枚举的开始元素\n    if(u &gt;= ans) return;\n    if(tot == n) ans = u;\n    bool flag = true;\n    for(int i = start; i &lt;= n; i++)&#123;\n        if(!vis[i] &amp;&amp; check(group[u], uc, i))&#123;\n            vis[i] = true;\n            group[u][uc] = num[i];\n            dfs(u, uc + 1, tot + 1, i + 1);\n            vis[i] = false;\n            flag = false;\n        &#125;\n    &#125;\n    if(flag) dfs(u + 1, 0, tot, 1);     // 新开一组需要从第一个元素开始从头枚举\n&#125;\nint main()&#123;\n    cin &gt;&gt; n; ans = n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; num[i];\n    dfs(1, 0, 0, 1);\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"DFS-之剪枝与优化\"><a href=\"#DFS-之剪枝与优化\" class=\"headerlink\" title=\"DFS 之剪枝与优化\"></a>DFS 之剪枝与优化</h3><ol>\n<li>优化搜索顺序<ul>\n<li>大部分情况下，我们应该优先搜索分支较少的节点。</li>\n</ul>\n</li>\n<li>排除等效冗余</li>\n<li>可行性剪枝</li>\n<li>最优性剪枝</li>\n<li>记忆化搜索（DP）</li>\n</ol>\n<h4 id=\"AcWing-小猫爬山\"><a href=\"#AcWing-小猫爬山\" class=\"headerlink\" title=\"AcWing|小猫爬山\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY3Lw==\">AcWing|小猫爬山</span></h4><ul>\n<li>先把小猫从大到小排序，然后枚举是否需要放入新的车</li>\n<li>剪枝<ul>\n<li>优化搜索顺序，先考虑放重猫</li>\n<li>可行性剪枝，考虑重量</li>\n<li>最优性剪枝，大于当前最优答案即可剪枝</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 20;\nint w[N], sum[N];\nint n, k, ans;\nvoid dfs(int u, int cnt)&#123;\n    if(cnt &gt;= ans) return;\n    if(u == n)&#123;\n        ans = cnt;\n        return;\n    &#125;\n    for(int i = 0; i &lt; cnt; i++)&#123;\n        if(sum[i] + w[u] &lt;= k)&#123; // 可行性剪枝\n            sum[i] += w[u];\n            dfs(u + 1, cnt);\n            sum[i] -= w[u];\n        &#125;\n    &#125;\n    sum[cnt] = w[u];    // 新开一辆车\n    dfs(u + 1, cnt + 1);\n    sum[cnt] = 0;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; k;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; w[i];\n    sort(w, w + n, greater&lt;int&gt;());\n    ans = n;\n    dfs(0, 0);\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-数独🌖\"><a href=\"#AcWing-数独🌖\" class=\"headerlink\" title=\"AcWing|数独🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY4Lw==\">AcWing|数独</span>🌖</h4><ul>\n<li>先考虑顺序，再考虑剪枝</li>\n<li>随意选择空格子，可以先判断没有用过的数字是哪些</li>\n<li>剪枝<ul>\n<li>优化搜索顺序，首先选择可用数字最少的格子</li>\n<li>可行性剪枝，不能与当前行、列、九宫格有重复</li>\n</ul>\n</li>\n<li>位运算优化<ul>\n<li>用九位的二进制数表示该行&#x2F;列&#x2F;九宫格的状态</li>\n<li>lowbit 运算</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 9, M = 1 &lt;&lt; N;\nint one[M], mp[M]; // one 为不同状态中有几个 1，mp 为不同状态对应的十进制数\nint col[N], row[N], cell[3][3];\nstring str;\nint lowbit(int x)&#123;\n    return x &amp; (-x);\n&#125;\nint get(int x, int y)&#123;\n    return row[x] &amp; col[y] &amp; cell[x / 3][y / 3];\n&#125;\nvoid init()&#123;    // 初始化（将所有位置都初始化为可以填数的状态\n    for(int i = 0; i &lt; N; i++) row[i] = col[i] = (1 &lt;&lt; N) - 1;\n    for(int i = 0; i &lt; 3; i++)&#123;\n        for(int j = 0; j &lt; 3; j++)&#123;\n            cell[i][j] = (1 &lt;&lt; N) - 1;\n        &#125;\n    &#125;\n&#125;\nvoid draw(int x, int y, int t, bool is_set)&#123;    // 在该位置上是否填 t\n    if(is_set) str[x * N + y] = t + &#39;1&#39;;\n    else str[x * N + y] = &#39;.&#39;;\n    int v = 1 &lt;&lt; t;   // 找到该数对应二进制之后的位置的数\n    if(!is_set) v = -v;\n    // 在这个原数对应的位置上减去该数的二进制数\n    row[x] -= v;    \n    col[y] -= v;\n    cell[x / 3][y / 3] -= v;\n&#125;\nbool dfs(int cnt)&#123;\n    if(!cnt) return true;\n    int minv = 10;  // 记录当前最少枚举方案\n    int x, y;\n    for(int i = 0; i &lt; N; i++)&#123;\n        for(int j = 0; j &lt; N; j++)&#123;\n            if(str[i * N + j] == &#39;.&#39;)&#123;\n                int state = get(i, j);  // 找到该位置上能填的数的状态\n                if(one[state] &lt; minv)&#123;\n                    x = i, y = j;\n                    minv = one[state];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    int state = get(x, y);\n    for(int i = state; i; i-= lowbit(i))&#123;   // 枚举该位置上能填的数\n        int t = mp[lowbit(i)];\n        draw(x, y, t, true);\n        if(dfs(cnt - 1)) return true;\n        draw(x, y, t, false);\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    for(int i = 0; i &lt; N; i++) mp[1 &lt;&lt; i] = i;\n    for(int i = 0; i &lt; 1 &lt;&lt; N; i++)&#123;\n        for(int j = 0; j &lt; N; j++)&#123;\n            one[i] += (i &gt;&gt; j) &amp; 1;\n        &#125;\n    &#125;\n    while(cin &gt;&gt; str, str[0] != &#39;e&#39;)&#123;\n        init();\n        int cnt = 0;    // 记录有几个空格需要填数\n        for(int i = 0, k = 0; i &lt; N; i++)&#123;\n            for(int j = 0; j &lt; N; j++, k++)&#123;\n                if(str[k] != &#39;.&#39;)&#123;\n                    int t = str[k] - &#39;1&#39;;\n                    draw(i, j, t, true);\n                &#125;else cnt++;\n            &#125;\n        &#125;\n        dfs(cnt);\n        cout &lt;&lt; str &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-木棍\"><a href=\"#AcWing-木棍\" class=\"headerlink\" title=\"AcWing|木棍\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY5Lw==\">AcWing|木棍</span></h4><ul>\n<li>枚举拼接的木棒的长度</li>\n<li>剪枝<ul>\n<li>只枚举 sum 能整除的长度</li>\n<li>优化搜索顺序，先枚举较长的木棍</li>\n<li>排除等效冗余<ul>\n<li>按照组合数方式枚举</li>\n<li>如果当前木棍加到当前木棒失败则直接略过，后面所有等长的也都略过</li>\n<li>如果某木棒放第一根木棍 $u$ 导致当前这根木棒凑不成 $length$, 整个方案一定失败</li>\n<li>如果木棒的最后一根木棍 $u$ 放在这里导致后续方案失败, 则整个方案一定失败</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 70;\nint w[N], sum, length, n;\nbool st[N];\nbool dfs(int u, int part, int start)&#123;\n    if(u * length == sum) return true;\n    if(part == length) return dfs(u + 1, 0, 0);\n    for(int i = start; i &lt;= n; i++)&#123;\n        if(st[i] || w[i] + part &gt; length) continue;\n        st[i] = true;\n        if(dfs(u, part + w[i], i + 1)) return true;\n        st[i] = false;\n        if(!part) return false; // 第一根失败\n        if(w[i] + part == length) return false; // 最后一根失败\n        int j = i;\n        while(j &lt;= n &amp;&amp; w[j] == w[i]) j++;\n        i = j - 1;\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    while(cin &gt;&gt; n, n)&#123;\n        memset(st, false, sizeof(st));\n        sum = 0, length = 1;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            cin &gt;&gt; w[i];\n            sum += w[i];\n        &#125;\n        sort(w + 1, w + n + 1, greater());\n        while(1)&#123;   // 枚举 length\n            if(sum % length == 0 &amp;&amp; dfs(0, 0, 0))&#123;\n                cout &lt;&lt; length &lt;&lt; endl;\n                break;\n            &#125;\n            length++;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"AcWing-生日蛋糕\"><a href=\"#AcWing-生日蛋糕\" class=\"headerlink\" title=\"AcWing|生日蛋糕\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTcwLw==\">AcWing|生日蛋糕</span></h4><ul>\n<li>优化搜索顺序，自底向上搜，从大到小枚举半径和高度，半径优先于高度（ $R^2,h$ ）</li>\n<li>可行性剪枝（可以有更严格的上界）<ul>\n<li>$U \\le R_U \\le min \\left { \\sqrt{N - V}，R_{U + 1} - 1 \\right }$</li>\n<li>$U \\le H_U \\le min \\left { \\frac{N - V}{R^2} ，H_{U + 1} - 1 \\right }$</li>\n</ul>\n</li>\n<li>最优性剪枝<ul>\n<li>$S_{1 \\sim U} &#x3D; \\sum_{k &#x3D; 1}^{U} 2 \\times R_k H_k  &#x3D; \\frac{2}{R_{U + 1}} \\sum_{k &#x3D; 1}^{U} R_k H_k  R_{U + 1} \\ge \\frac{2}{R_{U + 1}} \\sum_{k &#x3D; 1}^{U} R_{k}^2 H_k &#x3D; \\frac{2 (N - V)}{R_{U + 1}}$</li>\n<li>因此 $S + \\frac{2(N - V)}{R_{U + 1}} \\ge S_{ans}$ 时即可剪枝</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e4 + 10;\nint H[N], R[N]; // 记录每层的高和半径，每次搜索需要用到上一层的高度和半径\nint minS[N], minV[N];\nint n, m, ans = 1e9;\nvoid dfs(int u, int v, int s)&#123;\n    if(v + minV[u] &gt; N) return;\n    if(s + minS[u] &gt;= ans) return;\n    if(s + 2 * (n - v) / R[u + 1] &gt;= ans) return;\n    if(!u)&#123;\n        if(v == n) ans = s;\n        return;\n    &#125;\n    for(int r = min(R[u + 1] - 1, (int)sqrt(n - v)); r &gt;= u; r--)&#123;\n        for(int h = min(H[u + 1] - 1, (n - v) / r / r); h &gt;= u; h--)&#123;\n            H[u] = h, R[u] = r;\n            int t = 0;\n            if(u == m) t = r * r;   // 最底下一层需要加上整个上表面面积\n            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;    // 预处理前面几层最小值\n        minS[i] = minS[i - 1] + 2 * i * i;\n        minV[i] = minV[i - 1] + i * i * i;\n    &#125;\n    R[m + 1] = H[m + 1] = 1e9;\n    dfs(m, 0, 0);\n    if(ans == 1e9) ans = 0;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"迭代加深\"><a href=\"#迭代加深\" class=\"headerlink\" title=\"迭代加深\"></a>迭代加深</h3><ul>\n<li><del>面向深度剪枝</del></li>\n<li>节省空间、时间</li>\n</ul>\n<h4 id=\"AcWing-加成序列\"><a href=\"#AcWing-加成序列\" class=\"headerlink\" title=\"AcWing|加成序列\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTcyLw==\">AcWing|加成序列</span></h4><ul>\n<li>优化搜索顺序，从大到小枚举下一个数</li>\n<li>排除等效冗余，某个数被枚举过了就不用再枚举了</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\nint path[N];\nint n;\nbool dfs(int u, int depth)&#123;\n    if(u &gt; depth) return false;\n    if(path[u - 1] == n) return true;\n    bool st[N] = &#123;0&#125;;\n    for(int i = u - 1; i &gt;= 0; i--)&#123;\n        for(int j = i; j &gt;= 0; j--)&#123;\n            int t = path[i] + path[j];\n            if(st[t] || t &lt; path[u - 1] || t &gt; n) continue;\n            st[t] = true;\n            path[u] = t;\n            if(dfs(u + 1, depth)) return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    path[0] = 1;\n    while(cin &gt;&gt; n, n)&#123;\n        int depth = 1;\n        while(!dfs(1, depth)) depth++;\n        for(int i = 0; i &lt; depth; i++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"双向-DFS\"><a href=\"#双向-DFS\" class=\"headerlink\" title=\"双向 DFS\"></a>双向 DFS</h3><ul>\n<li>与双向 BFS 原理相同</li>\n</ul>\n<h4 id=\"AcWing-送礼物\"><a href=\"#AcWing-送礼物\" class=\"headerlink\" title=\"AcWing|送礼物\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTczLw==\">AcWing|送礼物</span></h4><ul>\n<li>用空间换时间<ul>\n<li>先枚举前一半物品能凑出来的重量</li>\n<li>DFS 后一半物品，搜索能否有一种方案加上前面凑出来的重量使得答案最大</li>\n<li>排序 + 二分优化时间复杂度</li>\n</ul>\n</li>\n<li>将所有物品按重量从大到小排序</li>\n<li>先将前 $K$ 件物品的选择方式，然后在表中二分出不超过 $W$ 的最大值</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 50;\nint w[N], weight[1 &lt;&lt; 25];\nLL n, cnt = 1, W, k, ans;\nvoid dfs1(int u, int sum)&#123;\n    if(u == k)&#123;\n        weight[cnt++] = sum;\n        return;\n    &#125;\n    dfs1(u + 1, sum);\n    if((LL)sum + w[u] &lt;= W) dfs1(u + 1, sum + w[u]);\n&#125;\nvoid dfs2(int u, int sum)&#123;\n    if(u == n)&#123;     // 二分找满足条件的最大值\n        int l = 0, r = cnt - 1;\n        while(l &lt; r)&#123;\n            int mid = (l + r + 1) &gt;&gt; 1;\n            if((LL)weight[mid] + sum &lt;= W) l = mid;\n            else r = mid - 1;\n        &#125;\n        ans = max(ans, (LL)weight[l] + sum);\n        return;\n    &#125;\n    dfs2(u + 1, sum);\n    if((LL)sum + w[u] &lt;= W) dfs2(u + 1, sum + w[u]);\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; W &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; w[i];\n    if(n &gt;= 2) k = n / 2 + 2;\n    sort(w, w + n, greater());\n    dfs1(0, 0);\n    sort(weight, weight + cnt);\n    cnt = unique(weight, weight + cnt) - weight;    // 去重\n    dfs2(k, 0);\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"IDA\"><a href=\"#IDA\" class=\"headerlink\" title=\"IDA*\"></a>IDA*</h3><ul>\n<li>类似 A*</li>\n<li>证明较 A* 简单</li>\n<li>通常配合迭代加深</li>\n<li>预估当前这个点需要多少步才能到达<ul>\n<li>估价函数 $\\le$ 真实值</li>\n</ul>\n</li>\n<li><em>优点</em><ol>\n<li>空间开销小：每个深度下实际上是一个深度优先搜索，不过深度有限制，使用 DFS 可以减小空间消耗；</li>\n<li>利于深度剪枝。</li>\n</ol>\n</li>\n<li><em>缺点</em><ol>\n<li>重复搜索：即使前后两次搜索相差微小，回溯过程中每次深度变大都要再次从头搜索。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"AcWing-排书\"><a href=\"#AcWing-排书\" class=\"headerlink\" title=\"AcWing|排书\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgyLw==\">AcWing|排书</span></h4><ul>\n<li>可以采用双向 BFS，也可以使用 IDA*</li>\n<li>之后设计估价函数，考虑排序后每个数的后继，$i$ 的后继应该是 $i + 1$，同时，每次操作我们最多更改 $3$ 个元素的后继关系</li>\n<li>每次递归前，我们可以计算出当前有多少个后继关系是不正确的，记当前序列一共有 $tot$ 个后继不正确，则修复这些后继需要的最少步数为 $\\left \\lceil \\frac{tot}{3}  \\right \\rceil$ </li>\n<li>如果当前深度加上估价函数的值大于迭代加深的最大深度时，则直接回溯。</li>\n<li>我们每次只需要枚举将长度为 $i$ 的书放到某个位置即可</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 20;\nint n;\nint q[N], w[6][N];  // 书的编号，恢复现场\nint f()&#123;    // 估价函数\n    int tot = 0;\n    for(int i = 1; i + 1 &lt;= n; i++)&#123;\n        if(q[i + 1] != q[i] + 1) tot++;\n    &#125;\n    return (tot + 2) / 3;\n&#125;\nbool dfs(int u, int depth)&#123;\n    if(u + f() &gt; depth) return false;\n    if(f() == 0) return true;\n    for(int len = 1; len &lt;= n; len++)&#123;\n        for(int l = 1; l + len - 1 &lt;= n; l++)&#123;\n            int r = l + len - 1;\n            for(int k = r + 1; k &lt;= n; k++)&#123;\n                memcpy(w[u], q, sizeof(q));\n                int x, y;\n                for(x = r + 1, y = l; x &lt;= k; x++, y++) q[y] = w[u][x];\n                for(x = l; x &lt;= r; x++, y++) q[y] = w[u][x];\n                if(dfs(u + 1, depth)) return true;\n                memcpy(q, w[u], sizeof(q));\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\nvoid solve()&#123;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; q[i];\n    int depth = 0;  // 可能初始就是排好的\n    while(depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth++;\n    if(depth &gt;= 5) cout &lt;&lt; &quot;5 or more\\n&quot;;\n    else cout &lt;&lt; depth &lt;&lt; &#39;\\n&#39;;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h4 id=\"AcWing-回转游戏🌖\"><a href=\"#AcWing-回转游戏🌖\" class=\"headerlink\" title=\"AcWing|回转游戏🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTgzLw==\">AcWing|回转游戏</span>🌖</h4><ul>\n<li>估价函数：<ul>\n<li>统计中间 $8$ 个方格中出现次数最多的数的个数，记为 $k$</li>\n<li>每次操作会从中间 $8$ 个方格中移出一个数，再移入一个数，所以最多会减少一个不同的数</li>\n<li>因此估价函数可以设为 $8 - k$</li>\n</ul>\n</li>\n<li>剪枝<ul>\n<li>记录上一次的操作，避免枚举上一次的逆操作</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">/*\n      0     1\n      2     3\n4  5  6  7  8  9  10\n      11    12\n13 14 15 16 17 18 19\n      20    21\n      22    23\n*/\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 24;\nint q[N];\nint op[8][7] = &#123;\n    &#123;0, 2, 6, 11, 15, 20, 22&#125;,\n    &#123;1, 3, 8, 12, 17, 21, 23&#125;,\n    &#123;10, 9, 8, 7, 6, 5, 4&#125;,\n    &#123;19, 18, 17, 16, 15, 14, 13&#125;,\n    &#123;23, 21, 17, 12, 8, 3, 1&#125;,\n    &#123;22, 20, 15, 11, 6, 2, 0&#125;,\n    &#123;13, 14, 15, 16, 17, 18, 19&#125;,\n    &#123;4, 5, 6, 7, 8, 9, 10&#125;,\n&#125;;\nint center[8] = &#123;6, 7, 8, 11, 12, 15, 16, 17&#125;;\nint opposite[8] = &#123;5, 4, 7, 6, 1, 0, 3, 2&#125;;\nint path[100];\nint f()&#123;\n    int sum[4] = &#123;0&#125;;\n    for(int i = 0; i &lt; 8; i++) sum[q[center[i]]]++;\n    int cnt = 0;\n    for(int i = 1; i &lt;= 3; i++) cnt = max(cnt, sum[i]);\n    return 8 - cnt;\n&#125;\nvoid operation(int x)&#123;\n    for(int i = 0; i &lt; 6; i++) swap(q[op[x][i]], q[op[x][i + 1]]);\n&#125;\nbool dfs(int u, int depth, int last)&#123;\n    if(f() + u &gt; depth) return false;\n    if(f() == 0) return true;\n    for(int i = 0; i &lt; 8; i++)&#123;\n        if(opposite[i] == last) continue;\n        operation(i);\n        path[u] = i;\n        if(dfs(u + 1, depth, i)) return true;\n        operation(opposite[i]);\n    &#125;\n    return false;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    while(cin &gt;&gt; q[0], q[0])&#123;\n        for(int i = 1; i &lt; N; i++) cin &gt;&gt; q[i];\n        int depth = 0;\n        while(!dfs(0, depth, -1)) depth++;\n        if(!depth) cout &lt;&lt; &quot;No moves needed&quot;;\n        for(int i = 0; i &lt; depth; i++) cout &lt;&lt; char(path[i] + &#39;A&#39;);\n        cout &lt;&lt; &#39;\\n&#39; &lt;&lt; q[6] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板",
                "题集"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html",
            "url": "https://asterzc19.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86.html",
            "title": "动态规划题集",
            "date_published": "2022-02-28T10:00:20.000Z",
            "content_html": "<blockquote>\n<p>包括背包问题，线性 DP，区间 DP，计数类 DP，数位统计 DP，状压 DP，树形 DP，记忆化搜索，背包模型，数字三角形模型，最长上升子序列模型，状态机模型，单调队列优化 DP，斜率优化 DP。</p>\n</blockquote>\n<hr>\n<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><h3 id=\"01-背包\"><a href=\"#01-背包\" class=\"headerlink\" title=\"01 背包\"></a>01 背包</h3><pre><code class=\"cpp\">// N 件物品，容量为 V，体积 v，价值 w\ncin &gt;&gt; N &gt;&gt; V;\nfor(int i = 1; i &lt;= N; i++)&#123;\n    cin &gt;&gt; v[i] &gt;&gt; w[i];\n&#125;\nfor(int i = 1; i &lt;= N; i++)&#123;\n    for(int j = V; j &gt;= v[i]; j--)&#123;\n        dp[j] = max(dp[j],dp[j - v[i]] + w[i]);\n    &#125;\n&#125;\ncout &lt;&lt; dp[V] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h3><ul>\n<li>求所有前缀的最大值</li>\n</ul>\n<pre><code class=\"cpp\">cin &gt;&gt; N &gt;&gt; V;\nfor(int i = 1; i &lt;= N; i++)&#123;\n    cin &gt;&gt; v[i] &gt;&gt; w[i];\n&#125;\nfor(int i = 1; i &lt;= N; i++)&#123;\n    for(int j = v[i]; j &lt;= V; j++)&#123;\n        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);\n    &#125;\n&#125;\ncout &lt;&lt; dp[V] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"多重背包问题-Ⅰ\"><a href=\"#多重背包问题-Ⅰ\" class=\"headerlink\" title=\"多重背包问题 Ⅰ\"></a>多重背包问题 Ⅰ</h3><pre><code class=\"cpp\">// N 种物品，容量为 V，一种物品有 s 件。\ncin &gt;&gt; N &gt;&gt; V;\nfor(int i = 1; i &lt;= N; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];\nfor(int i = 1; i &lt;= N; i++)&#123;\n    for(int j = 0; j &lt;= N; j++)&#123;\n        for(int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)&#123;\n            dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i] * k] + w[i] * k);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[N][V] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"多重背包问题-Ⅱ\"><a href=\"#多重背包问题-Ⅱ\" class=\"headerlink\" title=\"多重背包问题 Ⅱ\"></a>多重背包问题 Ⅱ</h3><ul>\n<li>考察多重背包的二进制优化方法</li>\n</ul>\n<pre><code class=\"cpp\">cin &gt;&gt; N &gt;&gt; V;\nint cnt = 0;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int a, b, s;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;\n    int k = 1;\n    while(k &lt;= s)&#123;\n        cnt++;\n        v[cnt] = a * k, w[cnt] = b * k;\n        s -= k;\n        k *= 2;\n    &#125;\n    if(s &gt; 0)&#123;\n        cnt++;\n        v[cnt] = a * s, w[cnt] = b * s;\n    &#125;\n&#125;\nn = cnt;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = V; j &gt;= v[i]; j--)&#123;\n        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);\n    &#125;\n&#125;\ncout &lt;&lt; dp[V] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"分组背包问题\"><a href=\"#分组背包问题\" class=\"headerlink\" title=\"分组背包问题\"></a>分组背包问题</h3><pre><code class=\"cpp\">cin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    cin &gt;&gt; s[i];\n    for(int j = 1; j &lt;= s[i]; j++)&#123;\n        cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];\n    &#125;\n&#125;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = m; j &gt;= 0; j--)&#123;\n        for(int k = 0; k &lt;= s[i]; k++)&#123;\n            if(v[i][k] &lt;= j)&#123;\n                dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[m] &lt;&lt; endl;\n</code></pre>\n<hr>\n<h2 id=\"线性-DP\"><a href=\"#线性-DP\" class=\"headerlink\" title=\"线性 DP\"></a>线性 DP</h2><h3 id=\"数字三角形\"><a href=\"#数字三角形\" class=\"headerlink\" title=\"数字三角形\"></a>数字三角形</h3><pre><code class=\"cpp\">int n;\ncin &gt;&gt; n;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = 1; j &lt;= i; j++)&#123;\n        cin &gt;&gt; a[i][j];\n    &#125;\n&#125;\nfor(int i = 0; i &lt;= n; i++)&#123;\n    for(int j = 0; j &lt;= i + 1; j++)&#123;\n        f[i][j] = -INF;\n    &#125;\n&#125;\nf[1][1] = a[1][1];\nfor(int i = 2; i &lt;= n; i++)&#123;\n    for(int j = 1; j &lt;= i; j++)&#123;\n        f[i][j] = max(f[i-1][j-1] + a[i][j], f[i-1][j] + a[i][j]);\n    &#125;\n&#125;\nint res = -INF;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    res = max(res, f[n][i]);\n&#125;\ncout &lt;&lt; res &lt;&lt; endl;\n</code></pre>\n<h3 id=\"最长上升子序列-Ⅰ\"><a href=\"#最长上升子序列-Ⅰ\" class=\"headerlink\" title=\"最长上升子序列 Ⅰ\"></a>最长上升子序列 Ⅰ</h3><pre><code class=\"cpp\">cin &gt;&gt; n;\nfor(int i = 1; i &lt;= n; i++)\n    cin &gt;&gt; a[i];\nfor(int i = 1; i &lt;= n; i++)&#123;\n    dp[i] = 1;\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(a[j] &lt; a[i])&#123;\n            dp[i] = max(dp[i], dp[j] + 1);\n        &#125;\n    &#125;\n&#125;\nint res = 0;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    res = max(res, dp[i]);\n&#125;\ncout &lt;&lt; res &lt;&lt; endl;\n</code></pre>\n<h3 id=\"最长上升子序列-Ⅱ\"><a href=\"#最长上升子序列-Ⅱ\" class=\"headerlink\" title=\"最长上升子序列 Ⅱ\"></a>最长上升子序列 Ⅱ</h3><pre><code class=\"cpp\">// q[len] 表示长度为 len 的序列最后一个数的值\nint n;\ncin &gt;&gt; n;\nfor (int i = 1; i &lt;= n; i++)\n    cin &gt;&gt; a[i];\n\nint len = 0;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int l = 0, r = len;\n    while(l &lt; r)&#123;\n        int mid = l + r + 1 &gt;&gt; 1;\n        if(q[mid] &lt; a[i]) l = mid;\n        else r = mid - 1;\n    &#125;\n    len = max(len, r + 1);\n    q[r + 1] = a[i];\n&#125;\ncout &lt;&lt; len &lt;&lt; endl;\n</code></pre>\n<h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><pre><code class=\"cpp\">scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\nscanf(&quot;%s %s&quot;, a + 1, b + 1);\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = 1; j &lt;= m; j++)&#123;\n        dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n        if(a[i] == b[j])&#123;\n            dp[i][j] = max(dp[i-1][j-1] + 1, dp[i][j]);\n        &#125;\n    &#125;\n&#125;\nprintf(&quot;%d\\n&quot;, dp[n][m]);\n</code></pre>\n<h3 id=\"最短编辑距离\"><a href=\"#最短编辑距离\" class=\"headerlink\" title=\"最短编辑距离\"></a>最短编辑距离</h3><h3 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h3><ul>\n<li>题意<ul>\n<li>给定 $n$ 个长度不超过 $10$ 的字符串以及 $m$ 次询问，每次询问给出一个字符串和一个操作次数上限。</li>\n<li>对于每次询问，请你求出给定的 $n$ 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</li>\n<li>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">int edit_distance(char a[], char b[])\n&#123;\n    int la = strlen(a+1), lb = strlen(b+1);\n    for(int i = 0; i &lt;= lb; i++) dp[0][i] = i;\n    for(int i = 0; i &lt;= la; i++) dp[i][0] = i;\n    for(int i = 1; i &lt;= la; i++)&#123;\n        for(int j = 1; j &lt;= lb; j++)&#123;\n            dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1);\n            dp[i][j] = min(dp[i][j], dp[i-1][j-1] + (a[i] != b[j]));\n        &#125;\n    &#125;\n    return dp[la][lb];\n&#125;    \nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\t// n 个字符串，m 次询问\n    for (int i = 1; i &lt;= n; i++)\n        scanf(&quot;%s&quot;, str[i] + 1);\n    while(m--)&#123;\n        char s[N];\n        int limit;\n        scanf(&quot;%s%d&quot;, s + 1, &amp;limit);\n        int res = 0;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            if(edit_distance(str[i], s) &lt;= limit)&#123;\n                res ++;\n            &#125;\n        &#125;\n        printf(&quot;%d\\n&quot;, res);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"区间-DP\"><a href=\"#区间-DP\" class=\"headerlink\" title=\"区间 DP\"></a>区间 DP</h2><h3 id=\"石子合并\"><a href=\"#石子合并\" class=\"headerlink\" title=\"石子合并\"></a>石子合并</h3><pre><code class=\"cpp\">cin &gt;&gt; n;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    cin &gt;&gt; s[i];\n&#125;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    s[i] += s[i - 1];\n&#125;\nfor(int len = 2; len &lt;= n; len++)&#123;\n    for(int i = 1; i + len - 1 &lt;= n; i++)&#123;\n        int l = i, r = i + len - 1;\n        dp[l][r] = 1e9;\n        for(int k = l; k &lt; r; k++)&#123;\n            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l-1]);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[1][n] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-环形石子合并\"><a href=\"#AcWing-环形石子合并\" class=\"headerlink\" title=\"AcWing|环形石子合并\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3MC8=\">AcWing|环形石子合并</span></h3><ul>\n<li>每轮合并的石子必须是 <strong>相邻</strong> 的两堆石子，用到的是经典的区间 DP 模型，枚举区间长度</li>\n<li>状态表示 $dp[l, r]$<ul>\n<li>集合：当前合并的石子堆的大小为 $len$，且石子堆的左端点是 $l$，右端点是 $r$ 的方案</li>\n<li>属性：Min&#x2F;Max</li>\n</ul>\n</li>\n<li>状态计算（以最小值为例）<ul>\n<li><code>dp[l][r] = min (dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1]</code></li>\n</ul>\n</li>\n<li>通过把链延长两倍，变成 $2n$ 堆石子，可以在 $O(n^3)$ 的时间复杂度之内解决这道题目</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 410;\nint dp1[N][N], dp2[N][N];\nint w[N], s[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n; cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; w[i];\n        w[i + n] = w[i];\n    &#125;\n    for(int i = 1; i &lt;= 2 * n; i++) s[i] = s[i - 1] + w[i];\n    memset(dp1, 0x3f, sizeof(dp1));\n    memset(dp2, -0x3f, sizeof(dp2));\n    for(int len = 1; len &lt;= n; len++)&#123;\n        for(int i = 1; i + len - 1 &lt;= n * 2; i++)&#123;\n            int j = i + len - 1;\n            if(i == j) dp1[i][j] = dp2[i][j] = 0;\n            else&#123;\n                for(int k = i; k &lt; j; k++)&#123;\n                    dp1[i][j] = min(dp1[i][j], dp1[i][k] + dp1[k + 1][j] + s[j] - s[i - 1]);\n                    dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k + 1][j] + s[j] - s[i - 1]);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    int ans1 = 0x3f3f3f3f, ans2 = -0x3f3f3f3f;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        ans1 = min(ans1, dp1[i][i + n - 1]);\n        ans2 = max(ans2, dp2[i][i + n - 1]);\n    &#125;\n    cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2 &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-能量项链\"><a href=\"#AcWing-能量项链\" class=\"headerlink\" title=\"AcWing|能量项链\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzIyLw==\">AcWing|能量项链</span></h3><ul>\n<li>状态表示 $dp[L, R]$<ul>\n<li>集合：所有将 $[L, R]$ 合并在成一个矩阵（珠子）的方式</li>\n<li>属性：Max</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li><code>dp[L][R] = max(dp[L][R], dp[L][K] + dp[K][R] + w[L] * w[K] * w[R])</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 210;\nint dp[N][N], w[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n; cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; w[i];\n        w[i + n] = w[i];\n    &#125;\n    for(int len = 3; len &lt;= n + 1; len++)&#123;\n        for(int i = 1; i + len - 1 &lt;= 2 * n; i++)&#123;\n            int j = i + len - 1;\n            for(int k = i + 1; k &lt; j; k++)&#123;\n                dp[i][j] = max(dp[i][j] , dp[i][k] + dp[k][j] + w[i] * w[k] * w[j]);\n            &#125;\n        &#125;\n    &#125;\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++) ans = max(ans, dp[i][i + n]);\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-凸多边形的划分\"><a href=\"#AcWing-凸多边形的划分\" class=\"headerlink\" title=\"AcWing|凸多边形的划分\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3MS8=\">AcWing|凸多边形的划分</span></h3><ul>\n<li>状态表示 $dp[L, R]$<ul>\n<li>集合：所有将 $(L, L + 1), (L + 1, L + 2), \\cdots , (R - 1, R), (R, L)$ 这个多边形划分成三角形的方案</li>\n<li>属性：Min</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li><code>dp[L][R] = max(dp[L][R], dp[L][K] + dp[K][R] + w[L] * w[K] * w[R])</code></li>\n</ul>\n</li>\n<li>数组实现高精度</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 55, M = 35, INF = 1e9;\nint n;\nint w[N];\nLL dp[N][N][M];\nvoid add(LL a[], LL b[])&#123;\n    static LL c[M];\n    memset(c, 0, sizeof(c));\n    for(int i = 0, t = 0; i &lt; M; i++)&#123;\n        t += a[i] + b[i];\n        c[i] = t % 10;\n        t /= 10;\n    &#125;\n    memcpy(a, c, sizeof(c));\n&#125;\nvoid mul(LL a[], LL b)&#123;\n    static LL c[M];\n    memset(c, 0, sizeof(c));\n    LL t = 0;\n    for(int i = 0; i &lt; M; i++)&#123;\n        t += a[i] * b;\n        c[i] = t % 10;\n        t /= 10;\n    &#125;\n    memcpy(a, c, sizeof(c));\n&#125;\nint cmp(LL a[], LL b[])&#123;\n    for(int i = M - 1; i &gt;= 0; i--)&#123;\n        if(a[i] &gt; b[i]) return 1;\n        if(a[i] &lt; b[i]) return -1;\n    &#125;\n    return 0;\n&#125;\nvoid print(LL a[])&#123;\n    int k = M - 1;\n    while(k &amp;&amp; !a[k]) k--;\n    while(k &gt;= 0) cout &lt;&lt; a[k--];\n    cout &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    LL tmp[M];\n    for(int len = 3; len &lt;= n; len++)&#123;\n        for(int l = 1; l + len - 1 &lt;= n; l++)&#123;\n            int r = l + len - 1;\n            dp[l][r][M - 1] = 1;\n            for(int k = l + 1; k &lt; r; k++)&#123;\n                memset(tmp, 0, sizeof(tmp));\n                tmp[0] = w[l];\n                mul(tmp, w[k]);\n                mul(tmp, w[r]);\n                add(tmp, dp[l][k]);\n                add(tmp, dp[k][r]);\n                if(cmp(dp[l][r], tmp) &gt; 0)&#123;\n                    memcpy(dp[l][r], tmp, sizeof(tmp));\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    print(dp[1][n]);\n&#125;\n</code></pre>\n<h3 id=\"AcWing-加分二叉树\"><a href=\"#AcWing-加分二叉树\" class=\"headerlink\" title=\"AcWing|加分二叉树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDgxLw==\">AcWing|加分二叉树</span></h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzEyODQxLw==\">介绍前，中，后序遍历</span></li>\n<li>状态表示 $dp[L, R]$<ul>\n<li>集合：所有中序遍历是 $[L, R]$ 这一段的二叉树的集合</li>\n<li>属性：Max</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>枚举不同根节点的方案</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 30;\nint n;\nint w[N];\nint dp[N][N], g[N][N];\nvoid dfs(int l, int r)&#123;\n    if(l &gt; r) return;\n    int t = g[l][r];\n    cout &lt;&lt; t &lt;&lt; &quot; &quot;;\n    dfs(l, t - 1);\n    dfs(t + 1, r);\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    for(int len = 1; len &lt;= n; len++)&#123;\n        for(int l = 1; l + len - 1 &lt;= n; l++)&#123;\n            int r = l + len - 1;\n            if(len == 1) dp[l][r] = w[l], g[l][r] = l;\n            else&#123;\n                for(int k = l; k &lt;= r; k++)&#123;\n                    int left = k == l ? 1 : dp[l][k - 1];\n                    int right = k == r ? 1 : dp[k + 1][r];\n                    int score = left * right + w[k];\n                    if(dp[l][r] &lt; score)&#123;\n                        dp[l][r] = score;\n                        g[l][r] = k;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[1][n] &lt;&lt; endl;\n    dfs(1, n);\n&#125;\n</code></pre>\n<h3 id=\"AcWing-棋盘分割\"><a href=\"#AcWing-棋盘分割\" class=\"headerlink\" title=\"AcWing|棋盘分割\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzIzLw==\">AcWing|棋盘分割</span></h3><ul>\n<li>状态表示 $dp[x1, y1, x2, y2, k]$<ul>\n<li>集合：子矩阵 $(x1, y1)(x2, y2)$ 切分成 $k$ 部分的所有方案</li>\n<li>属性：均方差的最小值</li>\n</ul>\n</li>\n<li>记忆化搜索</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 15, M = 9;\nconst double INF = 1e9;\nint n, m = 8;\nint s[M][M];\ndouble dp[M][M][M][M][N];\ndouble X;\nint getSum(int x1, int y1, int x2, int y2)&#123;\n    return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n&#125;\ndouble get(int x1, int y1, int x2, int y2)&#123;\n    double sum = getSum(x1, y1, x2, y2) - X;\n    return sum * sum / n;\n&#125;\ndouble calc(int x1, int y1, int x2, int y2, int k)&#123;\n    double &amp;v = dp[x1][y1][x2][y2][k];\n    if(v &gt;= 0) return v;\n    if(k == 1) return v = get(x1, y1, x2, y2);\n    v = INF;\n    for(int i = x1; i &lt; x2; i++)&#123;\n        v = min(v, get(x1, y1, i, y2) + calc(i + 1, y1, x2, y2, k - 1));\n        v = min(v, get(i + 1, y1, x2, y2) + calc(x1, y1, i, y2, k - 1));\n    &#125;\n    for(int i = y1; i &lt; y2; i++)&#123;\n        v = min(v, get(x1, y1, x2, i) + calc(x1, i + 1, x2, y2, k - 1));\n        v = min(v, get(x1, i + 1, x2, y2) + calc(x1, y1, x2, i, k - 1));\n    &#125;\n    return v;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            cin &gt;&gt; s[i][j];\n            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];\n        &#125;\n    &#125;\n    X = 1.0 * s[m][m] / n;\n    memset(dp, -1, sizeof(dp));\n    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; sqrt(calc(1, 1, 8, 8, n)) &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"计数类-DP\"><a href=\"#计数类-DP\" class=\"headerlink\" title=\"计数类 DP\"></a>计数类 DP</h2><h3 id=\"整数划分\"><a href=\"#整数划分\" class=\"headerlink\" title=\"整数划分\"></a>整数划分</h3><ul>\n<li>把 $1, 2, … , n$ 分别看做 $n$ 个物品的体积，这 $n$ 个物体均无使用次数限制，问恰好能装满总体积为 $n$ 的背包的总方案数。（完全背包问题变形）</li>\n<li>$dp[i][j]$ 表示前 $i$ 个整数恰好拼成 $j$ 的方案数。</li>\n<li>类似完全背包的推导 $dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]$ 可等价变形为 $dp[j] &#x3D; dp[j] + dp[j - i]$</li>\n</ul>\n<pre><code class=\"cpp\">cin &gt;&gt; n;\ndp[0] = 1;\t// 容量为 0 时，前 i 个物品全不选也是一种方案\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = i; j &lt;= n; j++)&#123;\n        dp[j] = (dp[j] + dp[j - i]) % mod;\n    &#125;\n&#125;\ncout &lt;&lt; dp[n] &lt;&lt; endl;\n</code></pre>\n<hr>\n<h2 id=\"记忆化搜索\"><a href=\"#记忆化搜索\" class=\"headerlink\" title=\"记忆化搜索\"></a>记忆化搜索</h2><h3 id=\"滑雪\"><a href=\"#滑雪\" class=\"headerlink\" title=\"滑雪\"></a>滑雪</h3><pre><code class=\"cpp\">int n, m;\nint g[N][N], f[N][N];\nint dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\nint dp(int x, int y)&#123;\n    int &amp;v = f[x][y];\n    if(v != -1) return v;\n    v = 1;\n    for(int i = 0; i &lt; 4; i++)&#123;\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; g[x][y] &gt; g[nx][ny])&#123;\n            v = max(v, dp(nx, ny) + 1);\n        &#125;\n    &#125;\n    return v;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            cin &gt;&gt; g[i][j];\n        &#125;\n    &#125;\n    memset(f, -1, sizeof(f));\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= m; j++)&#123;\n            ans = max(ans, dp(i, j));\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"状压-DP\"><a href=\"#状压-DP\" class=\"headerlink\" title=\"状压 DP\"></a>状压 DP</h2><ul>\n<li>棋盘式（基于连通性）</li>\n<li>集合式</li>\n</ul>\n<h3 id=\"蒙德里安的梦想🌸\"><a href=\"#蒙德里安的梦想🌸\" class=\"headerlink\" title=\"蒙德里安的梦想🌸\"></a>蒙德里安的梦想🌸</h3><ul>\n<li>状态表示 $f[i, j]$<ul>\n<li>集合：将前面全部排好，且 $i - 1$ 列伸出到第 $i$ 列所有方案的集合，$j$ 表示状态</li>\n</ul>\n</li>\n<li>先放横着的，竖着的随着横向的摆放而固定。之后判断是否合法，有两个条件<ul>\n<li>$(j; &amp; ;k) &#x3D; 0$</li>\n<li>所有连续空着的位置的长度必须是偶数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 12, M = 1 &lt;&lt; N;\nLL dp[N][M];\nbool st[M]; // st[j | k] = 1 表示能成功转移\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    while(cin &gt;&gt; n &gt;&gt; m, n || m)&#123;\n        // 预处理 st\n        for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123;\n            st[i] = 1;\n            int cnt = 0; // 记录一列中 0 的个数\n            for(int j = 0; j &lt; n; j++)&#123;\n                if(i &gt;&gt; j &amp; 1)&#123;\n                    if(cnt &amp; 1)&#123;\n                        st[i] = 0;\n                        break;\n                    &#125;\n                &#125;else&#123;\n                    cnt++;\n                &#125;\n            &#125;\n            if(cnt &amp; 1) st[i] = 0;\n        &#125;\n\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;   // 没有横着摆放的小方块，所有小方块都是竖着摆放的，记录为一种状态\n        for(int i = 1; i &lt;= m; i++)&#123;\n            for(int j = 0; j &lt; 1 &lt;&lt; n; j++)&#123;\n                for(int k = 0; k &lt; 1 &lt;&lt; n; k++)&#123;\n                    if((j &amp; k) == 0 &amp;&amp; st[j | k])&#123;\n                        dp[i][j] += dp[i - 1][k];\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; dp[m][0] &lt;&lt; endl;   // 最后一列不会伸出\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"最短-Hamilton-路径🌸\"><a href=\"#最短-Hamilton-路径🌸\" class=\"headerlink\" title=\"最短 Hamilton 路径🌸\"></a>最短 Hamilton 路径🌸</h3><ul>\n<li>状态表示 $f[i, j]$<ul>\n<li>集合：所有从 $0$ 走到 $j$，走过的所有点是 $i$ 的所有路径</li>\n<li>属性：Min</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>$0 \\to \\cdots \\to k \\to j$ 中 $k$ 的所有情况，$k$ 表示走到 $j$ 之前，以 $k$ 为终点的最短距离</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 20, M = 1 &lt;&lt; N;\nint n;\nint w[N][N];\nint dp[M][N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            cin &gt;&gt; w[i][j];\n        &#125;\n    &#125;\n    memset(dp, 0x3f, sizeof(dp));\n    dp[1][0] = 0;\n    for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123;\n        for(int j = 0; j &lt; n; j++)&#123;\n            if(i &gt;&gt; j &amp; 1)&#123;\n                for(int k = 0; k &lt; n; k++)&#123;\n                    if(i &gt;&gt; k &amp; 1)&#123;\n                        dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + w[k][j]);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-小国王\"><a href=\"#AcWing-小国王\" class=\"headerlink\" title=\"AcWing|小国王\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA2Ni8=\">AcWing|小国王</span></h3><ul>\n<li>状态表示 $f[i, j, s]$ <ul>\n<li>集合：所有只摆在前 $i$ 行，已经摆了 $j$ 个国王，并且第 $i$ 行摆放的状态是 $s$ 的所有方案的集合。</li>\n<li>属性：Count</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 12, M = 1 &lt;&lt; 10, K = 110;\nvector&lt;int&gt; st;\nint cnt[M];\nvector&lt;int&gt; head[M];\nLL dp[N][K][M];\n\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    auto check = [&amp;n](int st)&#123;\n        for(int i = 0; i &lt; n; i++)&#123;\n            if((st &gt;&gt; i &amp; 1) &amp;&amp; (st &gt;&gt; (i + 1) &amp; 1)) return false;\n        &#125;\n        return true;\n    &#125;;\n    auto count = [&amp;n](int st)&#123;\n        int res = 0;\n        for(int i = 0; i &lt; n; i++)&#123;\n            if(st &gt;&gt; i &amp; 1) res++;\n        &#125;\n        return res;\n    &#125;;\n    for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123;\n        if(check(i))&#123;\n            st.push_back(i);\n            cnt[i] = count(i);\n        &#125;\n    &#125;\n    for(int i = 0; i &lt; st.size(); i++)&#123;\n        for(int j = 0; j &lt; st.size(); j++)&#123;\n            int a = st[i], b = st[j];\n            if(check(a | b) &amp;&amp; (a &amp; b) == 0)&#123;\n                head[i].push_back(j);\n            &#125;\n        &#125;\n    &#125;\n    dp[0][0][0] = 1;\n    for(int i = 1; i &lt;= n + 1; i++)&#123;\n        for(int j = 0; j &lt;= m; j++)&#123;\n            for(int a = 0; a &lt; st.size(); a++)&#123;\n                for(int b : head[a])&#123;\n                    int c = cnt[st[a]];\n                    if(j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][b];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-玉米田\"><a href=\"#AcWing-玉米田\" class=\"headerlink\" title=\"AcWing|玉米田\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzI5Lw==\">AcWing|玉米田</span></h3><ul>\n<li>状态表示 $f[i, s]$<ul>\n<li>集合：所有已经摆完前 $i$ 行，且第 $i$ 行的状态是 $s$ 的所有摆放方案的集合</li>\n<li>属性：Count</li>\n</ul>\n</li>\n<li>将图按照二进制存储，进行<strong>与操作</strong>即可判断该状态是否合法</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 14, M = 1 &lt;&lt; 12, mod = 1e8;\nint n, m;\nint w[N];\nvector&lt;int&gt; st;\nvector&lt;int&gt; head[M];\nint dp[N][M];\nbool check(int st)&#123;\n    for(int i = 0; i + 1 &lt; m; i++)&#123;\n        if((st &gt;&gt; i &amp; 1) &amp;&amp; (st &gt;&gt; i + 1 &amp; 1)) return false;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            int t; cin &gt;&gt; t;\n            w[i] += !t * (1 &lt;&lt; j);\n        &#125;\n    &#125;\n    for(int i = 0; i &lt; 1 &lt;&lt; m; i++) if(check(i)) st.push_back(i);\n    for(int i = 0; i &lt; st.size(); i++)&#123;\n        for(int j = 0; j &lt; st.size(); j++)&#123;\n            int a = st[i], b = st[j];\n            if(!(a &amp; b)) head[i].push_back(j);\n        &#125;\n    &#125;\n    dp[0][0] = 1;\n    for(int i = 1; i &lt;= n + 1; i++)&#123;\n        for(int j = 0; j &lt; st.size(); j++)&#123;\n            if(!(st[j] &amp; w[i]))&#123;\n                for(int k : head[j])&#123;\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[n + 1][0] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-炮兵阵地-🌸\"><a href=\"#AcWing-炮兵阵地-🌸\" class=\"headerlink\" title=\"AcWing|炮兵阵地 🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjk0Lw==\">AcWing|炮兵阵地</span> 🌸</h3><ul>\n<li>状态表示 $f[i, j, k]$<ul>\n<li>集合：所有已经摆完前 $i$ 行，且第 $i - 1$ 行的状态是 $j$，第 $i$ 行的状态是 $k$ 的所有摆放方案的最大值</li>\n<li>属性：Max</li>\n</ul>\n</li>\n<li>假如开大数组的话，空间复杂度会是 $O(N \\times 2^{M} \\times 2^{M})$ 会爆内存，因此我们必须使用滚动数组</li>\n<li>$a$ 为第 $i - 1$ 行，$b$ 为第 $i$ 行，$c$ 为第 $i - 2$ 行</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10, M = 1 &lt;&lt; 10;\nint n, m;\nint g[1010];\nint dp[2][M][M];\nvector&lt;int&gt; st;\nint cnt[M];\nbool check(int st)&#123;\n    for(int i = 0; i &lt; m; i++)&#123;\n        if((st &gt;&gt; i &amp; 1) &amp;&amp; ((st &gt;&gt; i + 1 &amp; 1) || (st &gt;&gt; i + 2 &amp; 1))) return false;\n    &#125;\n    return true;\n&#125;\nint count(int st)&#123;\n    int res = 0;\n    for(int i = 0; i &lt; m; i++)&#123;\n        if(st &gt;&gt; i &amp; 1) res++;\n    &#125;\n    return res;\n&#125;\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            char c;\n            cin &gt;&gt; c;\n            g[i] += (c == &#39;H&#39;) &lt;&lt; j;\n        &#125;\n    &#125;\n    for(int i = 0; i &lt; 1 &lt;&lt; m; i++)&#123;\n        if(check(i))&#123;\n            st.push_back(i);\n            cnt[i] = count(i);\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n + 2; i++)&#123;\n        for(int j = 0; j &lt; st.size(); j++)&#123; // 上一行状态\n            for(int k = 0; k &lt; st.size(); k++)&#123; // 当前状态\n                for(int u = 0; u &lt; st.size(); u++)&#123; // 前面第两行的状态\n                    int a = st[j], b = st[k], c = st[u];\n                    if(a &amp; b | a &amp; c | b &amp; c) continue;\n                    if(g[i] &amp; b | g[i - 1] &amp; a) continue;\n                    dp[i &amp; 1][j][k] = max(dp[i &amp; 1][j][k], dp[(i - 1) &amp; 1][u][j] + cnt[b]);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[n + 2 &amp; 1][0][0] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-愤怒的小鸟🌖\"><a href=\"#AcWing-愤怒的小鸟🌖\" class=\"headerlink\" title=\"AcWing|愤怒的小鸟🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTI2Lw==\">AcWing|愤怒的小鸟</span>🌖</h3><ul>\n<li>本题中抛物线严格经过原点，所以 $c$ 为 $0$，所以只需要两个点即可确定一条抛物线</li>\n<li><code>path[i][j]</code> 表示编号为 $i$ 的小猪和编号为 $j$ 的小猪所在的抛物线，变量的属性为这个抛物线可消灭的小猪的二进制表示</li>\n<li>状态表示：<code>dp[i]</code> 表示当前击败状态 $i$ 表示的小猪所需要的最少的小鸟</li>\n<li>状态计算：找到 $i$ 状态下没有被消灭的小猪的编号 $x$，枚举可消灭它的抛物线 $path[x][j]$ 并更新状态<ul>\n<li><code>dp[i | path[x][j]] = min(dp[i | path[x][j]], dp[i] + 1)</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef pair&lt;double, double&gt; PDD;\nconst int N = 19, M = 1 &lt;&lt; 18;\nconst double eps = 1e-8;\nint n, m;\nPDD q[N];\nint path[N][N];\nint dp[M];\nint cmp(double x, double y)&#123;\n    if(fabs(x - y) &lt; eps) return 0;\n    if(x &lt; y) return -1;\n    return 1;\n&#125;\nvoid solve()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;\n    memset(path, 0, sizeof(path));\n    for(int i = 0; i &lt; n; i++)&#123;\n        path[i][i] = 1 &lt;&lt; i;\n        for(int j = 0; j &lt; n; j++)&#123;\n            double x1 = q[i].first, y1 = q[i].second;\n            double x2 = q[j].first, y2 = q[j].second;\n            if(!cmp(x1, x2)) continue;\n            double a = (y1 / x1 - y2 / x2) / (x1 - x2);\n            double b = y2 / x2 - a * x2;\n            if(cmp(a, 0) &gt;= 0) continue;\n            int st = 0;\n            for(int k = 0; k &lt; n; k++)&#123;\n                double x = q[k].first, y = q[k].second;\n                if(!cmp(a * x * x + b * x, y)) st += 1 &lt;&lt; k;\n            &#125;\n            path[i][j] = st;\n        &#125;\n    &#125;\n    memset(dp, 0x3f, sizeof(dp));\n    dp[0] = 0;\n    for(int i = 0; i + 1 &lt; 1 &lt;&lt; n; i++)&#123;\n        int x = 0;\n        for(int j = 0; j &lt; n; j++)&#123;\n            if(!(i &gt;&gt; j &amp; 1))&#123;\n                x = j;\n                break;\n            &#125;\n        &#125;\n        for(int j = 0; j &lt; n; j++)&#123;\n            dp[i | path[x][j]] = min(dp[i | path[x][j]], dp[i] + 1);\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1] &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"树形-DP\"><a href=\"#树形-DP\" class=\"headerlink\" title=\"树形 DP\"></a>树形 DP</h2><h3 id=\"没有上司的舞会🌸\"><a href=\"#没有上司的舞会🌸\" class=\"headerlink\" title=\"没有上司的舞会🌸\"></a>没有上司的舞会🌸</h3><ul>\n<li>状态表示 $f[u][0&#x2F;1]$<ul>\n<li>集合：所有从以 $u$ 为根的子树中选择，并且不选 $u$ 这个点的方案，所有从以 $u$ 为根的子树中选，并且选择 $u$ 这个点的方案</li>\n<li>属性：最大值</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>不选当前点 $u$，可以选择他的子节点 $s$，也可以不选，$f[u][0] +&#x3D; max (f[s_i][0], f[s_i][1])$</li>\n<li>选择当前点 $u$，他的子节点 $s$ 一定不能选，$f[u][1] +&#x3D; f[s_i][0]$</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 6010;\nint f[N][2];\nint happy[N];\nbool has_father[N];\nint h[N], e[N], ne[N], idx;\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u)&#123;\n    f[u][1] = happy[u];\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        dfs(j);\n        f[u][0] += max(f[j][1], f[j][0]);\n        f[u][1] += f[j][0];\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; happy[i];\n    &#125;\n    for(int i = 1; i &lt; n; i++)&#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(b, a);\n        has_father[a] = 1;\n    &#125;\n    int root = 1;\n    while(has_father[root])&#123;\n        root++;\n    &#125;\n    dfs(root);\n    cout &lt;&lt; max(f[root][0], f[root][1]) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-树的最长路径\"><a href=\"#AcWing-树的最长路径\" class=\"headerlink\" title=\"AcWing|树的最长路径\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3NC8=\">AcWing|树的最长路径</span></h3><ul>\n<li>找树的直径，边权为 1<ul>\n<li>任取一点为起点，找到距离该点最远的一个点 $u$ DFS&#x2F;BFS</li>\n<li>再找到距离 $u$ 最远的一点 $v$ DFS&#x2F;BFS</li>\n<li>$u$ 和 $v$ 之间的路径就是一条直径</li>\n</ul>\n</li>\n<li>本题边权有正负，故用树形 DP 解决</li>\n<li>枚举路径的中间节点</li>\n<li>观察中间的某一个点，那么经过他的路径有：<ol>\n<li>以其子树中的某个节点作为起点，以他作为终点的粉色路径</li>\n<li>以其子树中的某个节点作为起点，以子树中的某个节点作为终点的蓝色路径</li>\n<li>以其子树中的某个节点作为起点，以非其子树的节点作为终点的橙色路径</li>\n</ol>\n</li>\n<li>对于第 $1$ 种情况，我们可以直接递归处理其子树，找出到当前子树根节点最长的路径长度即可</li>\n<li>对于第 $2$ 种情况，我们在处理第 $1$ 种情况时，顺便找出 $1$ 类路径的次长路径</li>\n<li>把最长和次长拼在一起，就是我们要的第 $2$ 种情况</li>\n<li>而对于第 $3$ 种情况，我们可以把它归类为其祖先节点的第 $1,2$ 种情况，让其祖先节点去处理即可</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010, M = 2 * N;\nint h[N], e[M], ne[M], w[M], idx;\nint ans;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint dfs(int u, int fa)&#123;\n    int dist = 0;   // 表示从当前点往下走的最大长度\n    int d1 = 0, d2 = 0;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == fa) continue;\n        int d = dfs(j, u) + w[i];\n        dist = max(dist, d);\n        if(d &gt; d1) d2 = d1, d1 = d;\n        else if(d &gt; d2) d2 = d;\n    &#125;\n    ans = max(ans, d1 + d2);\n    return dist;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n; cin &gt;&gt; n;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt; n; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(b, a, c);\n        add(a, b, c);\n    &#125;\n    dfs(1, -1);\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-树的中心\"><a href=\"#AcWing-树的中心\" class=\"headerlink\" title=\"AcWing|树的中心\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3NS8=\">AcWing|树的中心</span></h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzY4MjUv\">详细题解</span></li>\n<li>本题即用到了用子节点更新父节点信息的普遍情况，又用到了用父节点更新子节点的情况</li>\n<li>首先分析题目，其实是要我们把每一个点到其他点的最长距离求出来，再求一个其中最短的就可以了，我们来分析一下每一个点可以再树上怎么走，其实就是向上和向下走</li>\n<li>我们用 $d1[u], d2[u], up[u], p1[u], p2[u]$分别存一下需要的信息，这些数据存的是：<ul>\n<li>$d1[u]$：存下 $u$ 节点向下走的最长路径的长度</li>\n<li>$d2[u]$：存下 $u$ 节点向下走的第二长的路径的长度</li>\n<li>$p1[u]$：存下 $u$ 节点向下走的最长路径是从哪一个节点下去的</li>\n<li>$p2[u]$：存下 $u$ 节点向下走的第二长的路径是从哪一个节点走下去的</li>\n<li>$up[u]$：存下 $u$ 节点向上走的最长路径的长度</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010, M = 2 * N, INF = 0x3f3f3f3f;\nint h[N], e[M], ne[M], w[M], idx;\nint d1[N], d2[N], p1[N], p2[N], up[N];\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint dfs_d(int u, int fa)&#123;\n    d1[u] = d2[u] = -INF;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == fa) continue;\n        int d = dfs_d(j, u) + w[i];\n        if(d &gt; d1[u])&#123;\n            d2[u] = d1[u], d1[u] = d;\n            p2[u] = p1[u], p1[u] = j;\n        &#125;else if(d &gt; d2[u])&#123;\n            d2[u] = d;\n            p2[u] = j;\n        &#125;\n    &#125;\n    if(d1[u] == -INF) d1[u] = d2[u] = 0;\n    return d1[u];\n&#125;\nvoid dfs_u(int u, int s)&#123;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        if(j == s) continue;\n        if(p1[u] == j) up[j] = max(up[u], d2[u]) + w[i];\n        else up[j] = max(up[u], d1[u]) + w[i];\n        dfs_u(j, u);\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n; cin &gt;&gt; n;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt; n; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(b, a, c);\n        add(a, b, c);\n    &#125;\n    dfs_d(1, -1);\n    dfs_u(1, -1);\n    int ans = INF;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        ans = min(ans, max(d1[i], up[i]));\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-数字转换\"><a href=\"#AcWing-数字转换\" class=\"headerlink\" title=\"AcWing|数字转换\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3Ny8=\">AcWing|数字转换</span></h3><ul>\n<li>由于任意正整数 $x$，的约数之和是唯一的，且本题要求只又约数之和小于自身才能转换，故对于所有的 $x$ 来说，他向小于自己的数转换的边至多只有一条，那就是 $x$ 的约数之和 $x′(x′&lt;x)$</li>\n<li>建好图后，本题即可转换成在一个森林中，找出一个直径最长的树，并求它的直径</li>\n<li>处理约数之和时，需要运用筛法的思想，可以降低时间复杂度</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 50010;\nint h[N], e[N], ne[N], idx;\nint sum[N];\nbool st[N];\nint ans;\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nint dfs(int u)&#123;\n    int d1 = 0, d2 = 0;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        int d = dfs(j) + 1;\n        if(d &gt; d1) d2 = d1, d1 = d;\n        else if(d &gt; d2) d2 = d;\n    &#125;\n    ans = max(ans, d1 + d2);\n    return d1;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 2; j &lt;= n / i; j++)&#123;\n            sum[i * j] += i;\n        &#125;\n    &#125;\n    memset(h, -1, sizeof(h));\n    for(int i = 2; i &lt;= n; i++)&#123;\n        if(i &gt; sum[i])&#123;\n            add(sum[i], i);\n            st[i] = 1;\n        &#125;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!st[i])&#123;\n            dfs(i);\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-二叉苹果树\"><a href=\"#AcWing-二叉苹果树\" class=\"headerlink\" title=\"AcWing|二叉苹果树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3Ni8=\">AcWing|二叉苹果树</span></h3><ul>\n<li>题目本身是有依赖的背包模型，区别在于把物品价值分给了边而不是点</li>\n<li>对于一棵树来说，任意节点的入边（连向父节点的边）都是唯一的，所以边权和点权在确定树的根节点之后，可以视作一个东西（将入边价值视作该点价值）</li>\n<li>对于本题来说，分组背包集合划分会导致超时，因此采用体积集合划分</li>\n<li>状态表示 $f[i][j]$<ul>\n<li>集合：以 $i$ 为根节点的子树，包含 $i$ 的连通块的边数不超过 $j$ 的方案</li>\n<li>属性：最大值</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>$f_{i,j} &#x3D; max\\left { f_{i, j - 1 - k} + f_{son_i,k} + w_{edge_i}  \\right } ;;; k \\in [0,j - 1]$</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110, M = N &lt;&lt; 1;\nint h[N], e[M], ne[M], w[M], idx;\nint f[N][N];\nint n, m;\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u, int fa)&#123;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        if(e[i] == fa) continue;\n        dfs(e[i], u);\n        for(int j = m; j &gt;= 0; j--)&#123;\n            for(int k = 0; k &lt;= j - 1; k++)&#123;\n                f[u][j] = max(f[u][j], f[u][j - k - 1] + f[e[i]][k] + w[i]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    for(int i = 1; i &lt; n; i++)&#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(b, a, c);\n        add(a, b, c);\n    &#125;\n    dfs(1, -1);\n    cout &lt;&lt; f[1][m] &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-战略游戏\"><a href=\"#AcWing-战略游戏\" class=\"headerlink\" title=\"AcWing|战略游戏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzI1Lw==\">AcWing|战略游戏</span></h3><ul>\n<li>每条边上最少选择一个点，求最小权值</li>\n<li>状态表示 $f[i][0&#x2F;1]$<ul>\n<li>集合：所有在以 $i$ 为根的子树中选，且点 $i$ 的状态是 $j$ 的所有选法</li>\n<li>属性：最小值</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>$f[i][0]$，不选择当前点的方案，$f[i][0] &#x3D; min(\\sum f[son_i][1])$</li>\n<li>$f[i][1]$，选择当前点的方案，$f[i][1] &#x3D; min(\\sum min(f[son_i][1], f[son_i][0]))$</li>\n</ul>\n</li>\n<li><img data-src=\"https://cdn.acwing.com/media/article/image/2021/09/09/55909_968c7bc211-79306FEB-FC94-4BAB-95D3-327AECCCECEF(20210909-222.PNG)\" alt=\"战略游戏\"></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1510;\n\nint h[N], e[N], ne[N], idx;\nint f[N][2];\nbool has_father[N];\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u)&#123;\n    f[u][0] = 0;\n    f[u][1] = 1;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        dfs(j);\n        f[u][0] += f[j][1];\n        f[u][1] += min(f[j][0], f[j][1]);\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    while(~scanf(&quot;%d&quot;, &amp;n))&#123;\n        memset(h, -1, sizeof(h));\n        idx = 0;\n        memset(has_father, 0, sizeof(has_father));\n        for(int i = 1; i &lt;= n; i++)&#123;\n            int a, b ,c;\n            scanf(&quot;%d:(%d) &quot;, &amp;a, &amp;c);\n            while(c--)&#123;\n                scanf(&quot;%d&quot;, &amp;b);\n                add(a, b);\n                has_father[b] = 1;\n            &#125;\n        &#125;\n        int root = 0;\n        while(has_father[root])&#123;\n            root++;\n        &#125;\n        dfs(root);\n        printf(&quot;%d\\n&quot;, min(f[root][0], f[root][1]));\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-皇宫看守🌖\"><a href=\"#AcWing-皇宫看守🌖\" class=\"headerlink\" title=\"AcWing|皇宫看守🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA3OS8=\">AcWing|皇宫看守</span>🌖</h3><ul>\n<li>在战略游戏中，题目要求的放置方案是每条边都被观察到，而本题则是要求每个点都被观察到，因此同样使用树形 DP</li>\n<li>如果只是要求 每条边 被 观察 到，那么我们在处理 父节点 时，枚举到一个 子节点 就可以直接进行讨论<ul>\n<li>父节点放置哨兵，所有子节点都可放可不放哨兵</li>\n<li>父节点不放哨兵，所有子节点都要放置哨兵</li>\n</ul>\n</li>\n<li>但是在本题的要求中，每条边变成了每个点就会出现如下三种情况<ul>\n<li>父节点放置哨兵，所有子节点都可放可不放哨兵</li>\n<li>父节点不放哨兵，但是他至少有一个子节点放置哨兵，观察他</li>\n<li>父节点不放哨兵，但父节点的父节点放置哨兵观察，则子节点可放可不放哨兵</li>\n</ul>\n</li>\n<li>因此状态机模型如下<ol>\n<li>被父节点观察（0）</li>\n<li>被子节点观察（1）</li>\n<li>被自己观察（2）</li>\n</ol>\n<ul>\n<li><img data-src=\"https://cdn.acwing.com/media/article/image/2021/09/13/55909_d25b0f1713-EB1FDF4E-0D6A-4A7A-8FCF-D0F21B94443C(20210913-001.PNG)\"></li>\n</ul>\n</li>\n<li>状态表示 $f[i][0&#x2F;1&#x2F;2]$ <ul>\n<li>集合：以结点 $i$ 为根节点的子树，在 $i$ 点，状态为 $j$ 的方案</li>\n<li>属性：最小值</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>$f[i][0] &#x3D; \\sum min(f[son_i][1], f[son_i][2]);$</li>\n<li>$f[i][1] &#x3D; min(f[son_i][2] + \\sum min(f[son_j][1], f[son_j][2])) ;;;(i \\neq j)$</li>\n<li>$f[i][2] &#x3D; \\sum min\\left {f[son_i][0], f[son_i][1], f[son_i][2] \\right } + w_i$</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1510;\nint h[N], e[N], ne[N], w[N], idx;\nint f[N][3];\nbool st[N];\n\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u)&#123;\n    f[u][0] = 0;\n    f[u][1] = 0x3f3f3f3f;   // f[u][1] 求最小值，初始化为最大值\n    f[u][2] = w[u];\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        dfs(j);\n        f[u][0] += min(f[j][1], f[j][2]);\n        f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]);\n    &#125;\n    for(int i = h[u]; ~i; i = ne[i])&#123;\n        int j = e[i];\n        // f[u][0] 中记录了 sum(min(f[j][1], f[j][2])), 再从中减去对应贡献即可得到剩余的\n        f[u][1] = min(f[u][1], f[u][0] + f[j][2] - min(f[j][1], f[j][2]));\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    memset(h, -1, sizeof(h));\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int id, cnt, cost;\n        cin &gt;&gt; id &gt;&gt; cost &gt;&gt; cnt;\n        w[id] = cost;\n        while(cnt--)&#123;\n            int ver;\n            cin &gt;&gt; ver;\n            add(id, ver);\n            st[ver] = 1;\n        &#125;\n    &#125;\n    int root = 1;\n    while(st[root])&#123;\n        root++;\n    &#125;\n    dfs(root);\n    cout &lt;&lt; min(f[root][1], f[root][2]) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"数位-DP\"><a href=\"#数位-DP\" class=\"headerlink\" title=\"数位 DP\"></a>数位 DP</h2><ul>\n<li>使用<ul>\n<li>求满足一个性质的所有数时使用。</li>\n</ul>\n</li>\n<li>技巧<ul>\n<li>$[X, Y] ; -&gt; ; f (Y) - f (X - 1)$ </li>\n<li>从树的角度来考虑, 把整个数拆成每一位，从最高位向最低位看。设当前这一位为 $x$，则当前位分成 $[0, x)$ 和 $x$ 两种情况，即为树的两个分支，左分支大多都能通过公式获得。答案即为树的全部左分支加起来再加上最右的叶子。</li>\n</ul>\n</li>\n<li>模板<ul>\n<li>预处理通常为 DP 或组合数。在分类讨论计算答案时，和预处理的 DP 过程类似。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">void init() // 根据题意做预处理。\n&#123;\n    for(int i = 0; i &lt;= 9; i ++) // 对第一位初始化\n        f[1][i] = 1;\n\n    // DP过程\n&#125;\n\nint dp(int n)\n&#123;\n    if(!n) return 1;\n    vector&lt;int&gt; num;\n    // 取出每一位数字，可以根据进制转化问题替换 10\n    while(n) num.push_back(n % 10), n /= 10; \n    n = num.size();\n\n    LL ans = 0;\n    int last = 0;\n    for(int i = n - 1; i &gt;= 0; i --)\n    &#123;\n        int x = num[i];\n\n        // 分类讨论\n    &#125;\n\n    return ans;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-度的数量\"><a href=\"#AcWing-度的数量\" class=\"headerlink\" title=\"AcWing|度的数量\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4My8=\">AcWing|度的数量</span></h3><ul>\n<li>首先我们把数字 $n$ 对于 $B$ 进制来进行分解，将每一位上的数字存入一个数组中，然后从高位往低位去讨论，</li>\n<li>对于第 $i$ 位数字 $x$ 有三种情况<ul>\n<li>$x &#x3D; 0$ ：则 $i$ 位上只能取 $0$ ，所以直接讨论 $i-1$ 位就可以了</li>\n<li>$x &#x3D; 1$ ：则 $i$ 位上取 $0$ 的时候，后面 $i-1$ 位都可以随意取值，取 $1$ 的时候，后面 $i- 1$ 位要再小于题目的数的前提下取值，并且能取 $k-last-1$ 个 $1$ </li>\n<li>$x &gt; 1$ ：则 $i$ 位上可以取 $1$ ，$0$ ，并且后面 $i-1$ 位可以随便取。</li>\n</ul>\n</li>\n<li>这里 $i-1$ 位随便取和对于 $i-1$ 位讨论的区别，就体现在前一个直接用组合数 $f[i-1][k-last]$ 就可以，后面则需要再进入循环去讨论。</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 35;\nint f[N][N];\nint K, B;\nvoid init()&#123;\n    for(int i = 0; i &lt; N; i++)&#123;\n        for(int j = 0; j &lt;= i; j++)&#123;\n            if(!j) f[i][j] = 1;\n            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n        &#125;\n    &#125;\n&#125;\nint dp(int n)&#123;\n    if(!n) return 0;\n    vector&lt;int&gt; nums;\n    while(n)&#123;\n        nums.push_back(n % B);\n        n /= B;\n    &#125;\n    int ans = 0;\n    int last = 0;\n    for(int i = nums.size() - 1; i &gt;= 0; i--)&#123;\n        int x = nums[i];\n        if(x &gt; 0)&#123;\n            ans += f[i][K - last];\n            if(x &gt; 1)&#123;\n                if(K - last - 1 &gt;= 0) ans += f[i][K - last - 1];\n                break;\n            &#125;else&#123;\n                last++;\n                if(last &gt; K) break;\n            &#125;\n        &#125;\n        if(i == 0 &amp;&amp; last == K) ans++;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    init();\n    int l, r;\n    cin &gt;&gt; l &gt;&gt; r &gt;&gt; K &gt;&gt; B;\n    cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-数字游戏\"><a href=\"#AcWing-数字游戏\" class=\"headerlink\" title=\"AcWing|数字游戏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4NC8=\">AcWing|数字游戏</span></h3><ul>\n<li>同上一题，先求 $0 \\sim N$ 中不降数的个数</li>\n<li>状态表示 $f[i][j]$<ul>\n<li>集合：所有最高位是 $j$，且一共有 $i$ 位的不降数的集合</li>\n<li>属性：数量</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 15;\nint f[N][N];\nvoid init()&#123;\n    for(int i = 0; i &lt;= 9; i++)&#123;\n        f[1][i] = 1;\n    &#125;\n    for(int i = 2; i &lt; N; i++)&#123;\n        for(int j = 0; j &lt;= 9; j++)&#123;\n            for(int k = j; k &lt;= 9; k++)&#123;\n                f[i][j] += f[i - 1][k];\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint dp(int n)&#123;\n    if(!n) return 1;\n    vector&lt;int&gt; num;\n    while(n)&#123;\n        num.push_back(n % 10);\n        n /= 10;\n    &#125;\n    int ans = 0, last = 0;\n    for(int i = num.size() - 1; i &gt;= 0; i--)&#123;\n        int x = num[i];\n        // 左边分支,因为要保持不降序,所以j &gt;= last\n        for(int j = last; j &lt; x; j++)&#123;\n            ans += f[i + 1][j];\n        &#125;\n        // 如果上一位最大值大于x的话,不构成非降序,所以右边分支结束\n        if(last &gt; x) break;\n        last = x;\n        // 全部枚举完了也同样构成一种方案\n        if(!i) ans++;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    int n, m;\n    init();\n    while(cin &gt;&gt; n &gt;&gt; m)&#123;\n        cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h3 id=\"AcWing-Windy-数\"><a href=\"#AcWing-Windy-数\" class=\"headerlink\" title=\"AcWing|Windy 数\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4NS8=\">AcWing|Windy 数</span></h3><ul>\n<li>基本模板同上</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzE1NTYyLw==\">详细题解</span></li>\n<li>需要判断数是否小于 $n$ 位，因为没有前导零</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 15;\nint f[N][N];\n// f[i][j] 表示一共有i位，且最高为是数字j的满足wingy数定义的数的个数\nvoid init()&#123;\n    for(int i = 0; i &lt;= 9; i++)&#123;\n        f[1][i] = 1;\n    &#125;\n    for(int i = 2; i &lt;= N; i++)&#123;\n        for(int j = 0; j &lt;= 9; j++)&#123;\n            for(int k = 0; k &lt;= 9; k++)&#123;\n                if(abs(j - k) &gt;= 2) f[i][j] += f[i - 1][k];\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint dp(int n)&#123;\n    if(!n) return 0;\n    vector&lt;int&gt; num;\n    while(n)&#123;\n        num.push_back(n % 10);\n        n /= 10;\n    &#125;\n    int ans = 0, last = -1;\n    for(int i = num.size() - 1; i &gt;= 0; i--)&#123;\n        int x = num[i];\n        for(int j = (i == num.size() - 1); j &lt; x; j++)&#123;\n            if(abs(j - last) &gt;= 2) ans += f[i + 1][j];\n        &#125;\n        if(abs(last - x) &lt; 2) break;\n        last = x;\n        if(!i) ans++;\n    &#125;\n    for(int i = 1; i &lt;= num.size() - 1; i++)&#123;\n        for(int j = 1; j &lt;= 9; j++)&#123;\n            ans += f[i][j];\n        &#125;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    int n, m;\n    init();\n    cin &gt;&gt; n &gt;&gt; m;\n    cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; &#39;\\n&#39;;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-数字游戏-Ⅱ\"><a href=\"#AcWing-数字游戏-Ⅱ\" class=\"headerlink\" title=\"AcWing|数字游戏 Ⅱ\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4Ni8=\">AcWing|数字游戏 Ⅱ</span></h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzE1NTU2Lw==\">详细题解</span></li>\n<li>$f[i][j][k]$ 表示一共有 $i$ 位，且最高位数字是 $j$，且所有位数字和 $MOD ; P$ 结果为 $k$ 的数的个数。</li>\n<li>状态计算：<ul>\n<li>由于第 $i$ 位已经是 $j$，且所有数字之和 $MOD ; P$ 为 $k$，所以我们考虑第 $i - 1$ 位，假设第 $i - 1$ 位数字是 $x$，由于 $j$ 已经知道，那么剩下的 $i - 1$ 位数字之和取模后就是 $(k - j) MOD P$</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 11, M = 110;\nint f[N][10][M];\nint P;\nint mod(int u, int v)&#123;\n    return (u % v + v) % v;\n&#125;\nvoid init()&#123;\n    memset(f, 0, sizeof(f));\n    for(int i = 0; i &lt;= 9; i++) f[1][i][i % P]++;\n    for(int i = 2; i &lt; N; i++)&#123;\n        for(int j = 0; j &lt;= 9; j++)&#123;\n            for(int k = 0; k &lt; P; k++)&#123;\n                for(int x = 0; x &lt;= 9; x++)&#123;\n                    f[i][j][k] += f[i - 1][x][mod(k - j, P)];\n                &#125;\n            &#125;\n        &#125;\n    &#125; \n&#125;\nint dp(int n)&#123;\n    if(!n) return 1;\n    vector&lt;int&gt; nums;\n    while(n)&#123;\n        nums.push_back(n % 10);\n        n /= 10;\n    &#125;\n    int ans = 0, last = 0;\n    for(int i = nums.size() - 1; i &gt;= 0; i--)&#123;\n        int x = nums[i];\n        for(int j = 0; j &lt; x; j++)&#123;\n            ans += f[i + 1][j][mod(-last, P)];\n        &#125;\n        last += x;\n        if(!i &amp;&amp; last % P == 0) ans++;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    int l, r;\n    while(cin &gt;&gt; l &gt;&gt; r &gt;&gt; P)&#123;\n        init();\n        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-不要-62\"><a href=\"#AcWing-不要-62\" class=\"headerlink\" title=\"AcWing|不要 62\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4Ny8=\">AcWing|不要 62</span></h3><ul>\n<li>数位 DP + 状态机 DP</li>\n<li>基本分析同其他数位 DP 题一样，难点是求左边分支</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 15;\nint f[N][N];\nvoid init()&#123;\n    for(int i = 0; i &lt;= 9; i++)&#123;\n        if(i != 4)&#123;\n            f[1][i] = 1;\n        &#125;\n    &#125;\n    for(int i = 2; i &lt; N; i++)&#123;\n        for(int j = 0; j &lt;= 9; j++)&#123;\n            if(j == 4) continue;\n            // k 表示第 i - 1 位我填的什么，i - 1 位是我们之前填好的，所以可以拿来用\n            for(int k = 0; k &lt;= 9; k++)&#123;\n                if(k == 4 || j == 6 &amp;&amp; k == 2) continue;\n                f[i][j] += f[i - 1][k];\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint dp(int n)&#123;\n    if(!n) return 1;\n    vector&lt;int&gt; num;\n    while(n)&#123;\n        num.push_back(n % 10);\n        n /= 10;\n    &#125;\n    int ans = 0, last = 0;\n    for(int i = num.size() - 1; i &gt;= 0; i--)&#123;\n        int x = num[i];\n        for(int j = 0; j &lt; x; j++)&#123;\n            if(j == 4 || last == 6 &amp;&amp; j == 2) continue;\n            ans += f[i + 1][j];\n        &#125;\n        if(x == 4 || last == 6 &amp;&amp; x == 2) break;\n        last = x;\n        if(!i) ans++;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    init();\n    int l, r;\n    while(cin &gt;&gt; l &gt;&gt; r, l || r)&#123;\n        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"数字三角形模型\"><a href=\"#数字三角形模型\" class=\"headerlink\" title=\"数字三角形模型\"></a>数字三角形模型</h2><h3 id=\"AcWing-摘花生\"><a href=\"#AcWing-摘花生\" class=\"headerlink\" title=\"AcWing|摘花生\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNy8=\">AcWing|摘花生</span></h3><pre><code class=\"cpp\">for(int i = 1; i &lt;= r; i++)&#123;\n    for(int j = 1; j &lt;= c; j++)&#123;\n        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + w[i][j];\n    &#125;\n&#125;\ncout &lt;&lt; dp[r][c] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-最低通行费\"><a href=\"#AcWing-最低通行费\" class=\"headerlink\" title=\"AcWing|最低通行费\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMC8=\">AcWing|最低通行费</span></h3><pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = 1; j &lt;= n; j++)&#123;\n        if(i == 1 &amp;&amp; j == 1) dp[i][j] = w[i][j];\n        else&#123;\n            dp[i][j] = INF;\n            if(i &gt; 1) dp[i][j] = min(dp[i][j], dp[i - 1][j] + w[i][j]);\n            if(j &gt; 1) dp[i][j] = min(dp[i][j], dp[i][j - 1] + w[i][j]);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[n][n] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-方格取数🌸\"><a href=\"#AcWing-方格取数🌸\" class=\"headerlink\" title=\"AcWing|方格取数🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyOS8=\">AcWing|方格取数</span>🌸</h3><ul>\n<li><strong>为何不能分开走</strong><ul>\n<li>第一次走为局部最优并且也对第二次走造成了影响，第二次走是在第一次影响下所能走的局部最优，不具备“无后效性”，因此分开两次走并不是全局最优解。</li>\n</ul>\n</li>\n<li>状态表示<ul>\n<li>把 $dp[i_1][j_1][i_2][j_2]$ 转化为 $dp[k][i_1][i_2]$，其中 $k &#x3D; i_1 + j_1 &#x3D; i_2 + j_2$，即等价于 $dp[i_1][k - i_1][i_2][k - i_2]$。</li>\n<li>因此，在处理两次走到相同点的时候，可以转化为<strong>在 $i_1 &#x3D; i_2$ 和 $j_1 &#x3D; j_2$ 时</strong>，只取一次 $w[i_1][j_1]$ 的值</li>\n<li>观察可发现，当两条路径走的步长相同时，才有可能出现重复点。</li>\n<li>又因为每步同时走 $i_1 + j_1 &#x3D; i_2 + j_2$ 必然成立，因此令前面的和为 $k$，状态表示为 $dp[k][i_1][i_2]$。</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>可分为四种，一起向右走、一起向下走、一下一右。</li>\n<li>$k - 1 &#x3D; i_1 + j_1 - 1 &#x3D; i_2 + j_2 - 1$ 可分别转换成四种状态转移，取这四种状态集合的 $max$ 即可。</li>\n<li>$i_1 &#x3D; i_2$ 代表路径在该点重合。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">for(int k = 2; k &lt;= 2 * n; k++)&#123;\n    for(int i1 = 1; i1 &lt;= n; i1++)&#123;\n        for(int i2 = 1; i2 &lt;= n; i2++)&#123;\n            int j1 = k - i1, j2 = k - i2;\n            if(j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n)&#123;\n                int t = w[i1][j1];\n                if(i1 != i2) t += w[i2][j2];\n                int &amp;x = dp[k][i1][i2];\n                x = max(x, dp[k - 1][i1 - 1][i2 - 1] + t);\n                x = max(x, dp[k - 1][i1 - 1][i2] + t);\n                x = max(x, dp[k - 1][i1][i2 - 1] + t);\n                x = max(x, dp[k - 1][i1][i2] + t);\n            &#125;\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[2 * n][n][n] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-传纸条🌸\"><a href=\"#AcWing-传纸条🌸\" class=\"headerlink\" title=\"AcWing|传纸条🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjc3Lw==\">AcWing|传纸条</span>🌸</h3><ul>\n<li>可以证明与 <em>方格取数</em> 相同。<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzEyMzg5Lw==\">证明</span></li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">for(int k = 2; k &lt;= n + m; k++)&#123;\n    for(int i = 1; i &lt; k; i++)&#123;\n        for(int j = 1; j &lt; k; j++)&#123;\n            int j1 = k - i, j2 = k - j;\n            int &amp;x = dp[k][i][j];\n            int t = w[i][j1];\n            if(i != j) t += w[j][j2];\n            x = max(x, dp[k - 1][i - 1][j - 1] + t);\n            x = max(x, dp[k - 1][i - 1][j] + t);\n            x = max(x, dp[k - 1][i][j - 1] + t);\n            x = max(x, dp[k - 1][i][j] + t);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[n + m][n][n] &lt;&lt; endl;\n</code></pre>\n<hr>\n<h2 id=\"最长上升子序列模型\"><a href=\"#最长上升子序列模型\" class=\"headerlink\" title=\"最长上升子序列模型\"></a>最长上升子序列模型</h2><h3 id=\"AcWing-怪盗基德的滑翔翼\"><a href=\"#AcWing-怪盗基德的滑翔翼\" class=\"headerlink\" title=\"AcWing|怪盗基德的滑翔翼\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxOS8=\">AcWing|怪盗基德的滑翔翼</span></h3><ul>\n<li>两个方向都求一下 $LIS$</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++)&#123;\n    dp1[i] = 1;\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(w[i] &gt; w[j]) dp1[i] = max(dp1[i], dp1[j] + 1);\n    &#125;\n    ans = max(ans, dp1[i]);\n&#125;\nfor(int i = n; i &gt;= 1; i--)&#123;\n    dp2[i] = 1;\n    for(int j = n; j &gt; i; j--)&#123;\n        if(w[i] &gt; w[j]) dp2[i] = max(dp2[i], dp2[j] + 1);\n    &#125;\n    ans = max(ans, dp2[i]);\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-登山\"><a href=\"#AcWing-登山\" class=\"headerlink\" title=\"AcWing|登山\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNi8=\">AcWing|登山</span></h3><ul>\n<li>两端求 $LIS$，最后遍历每个点。</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\nfor(int i = 1; i &lt;= n; i++)&#123;\n    dp1[i] = 1;\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(w[i] &gt; w[j]) dp1[i] = max(dp1[i], dp1[j] + 1);\n    &#125;\n&#125;\nfor(int i = n; i &gt;= 1; i--)&#123;\n    dp2[i] = 1;\n    for(int j = n; j &gt; i; j--)&#123;\n        if(w[i] &gt; w[j]) dp2[i] = max(dp2[i], dp2[j] + 1);\n    &#125;\n&#125;\nint ans = 0;\nfor(int i = 1; i &lt;= n; i++) ans = max(ans, dp1[i] + dp2[i] - 1);\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-合唱队形\"><a href=\"#AcWing-合唱队形\" class=\"headerlink\" title=\"AcWing|合唱队形\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDg0Lw==\">AcWing|合唱队形</span></h3><ul>\n<li>与 <em>登山</em> 几乎一致。</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\nfor(int i = 1; i &lt;= n; i++)&#123;\n    dp1[i] = 1;\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(w[i] &gt; w[j]) dp1[i] = max(dp1[i], dp1[j] + 1);\n    &#125;\n&#125;\nfor(int i = n; i &gt;= 1; i--)&#123;\n    dp2[i] = 1;\n    for(int j = n; j &gt; i; j--)&#123;\n        if(w[i] &gt; w[j]) dp2[i] = max(dp2[i], dp2[j] + 1);\n    &#125;\n&#125;\nint ans = 0;\nfor(int i = 1; i &lt;= n; i++) ans = max(ans, dp1[i] + dp2[i] - 1);\ncout &lt;&lt; n - ans &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-友好城市\"><a href=\"#AcWing-友好城市\" class=\"headerlink\" title=\"AcWing|友好城市\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNC8=\">AcWing|友好城市</span></h3><ul>\n<li>对一端的城市排序后即可转换成 $LIS$ 问题。</li>\n<li>简单数据版本</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; city[i].first &gt;&gt; city[i].second;\nsort(city + 1, city + n + 1);\nfor(int i = 1; i &lt;= n; i++)&#123;\n    dp[i] = 1;\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(city[i].second &gt; city[j].second) dp[i] = max(dp[i], dp[j] + 1);\n    &#125;\n    ans = max(ans, dp[i]);\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>\n<ul>\n<li>加强数据版本（使用二分）</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; city[i].first &gt;&gt; city[i].second;\nsort(city + 1, city + n + 1);\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int l = 0, r = ans;\n    while(l &lt; r)&#123;\n        int mid = l + r + 1 &gt;&gt; 1;\n        if(dp[mid] &lt; city[i].second) l = mid;\n        else r = mid - 1;\n    &#125;\n    ans = max(ans, l + 1);\n    dp[l + 1] = city[i].second;\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl;\n\n// 或者使用 lower_bound\n\n*lower_bound(dp + 1, dp + ans + 1, city[i].second) = city[i].second;\n</code></pre>\n<h3 id=\"AcWing-最大上升子序列和\"><a href=\"#AcWing-最大上升子序列和\" class=\"headerlink\" title=\"AcWing|最大上升子序列和\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxOC8=\">AcWing|最大上升子序列和</span></h3><pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\nfor(int i = 1; i &lt;= n; i++)&#123;\n    dp[i] = w[i];\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(w[i] &gt; w[j]) dp[i] = max(dp[i], dp[j] + w[i]);\n    &#125;\n    ans = max(ans, dp[i]);\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-拦截导弹\"><a href=\"#AcWing-拦截导弹\" class=\"headerlink\" title=\"AcWing|拦截导弹\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxMi8=\">AcWing|拦截导弹</span></h3><details>\n<summary>贪心证明</summary>\n    <a href = \"https://www.acwing.com/solution/content/52042/\">贪心证明</a>\n</details>\n\n<ul>\n<li>$O(n^2)$ dp + 贪心<ul>\n<li>题目的第二问，对于第 $i$ 号导弹，要么选择末尾导弹高度最小的拦截系统，要么新创一个拦截系统，用一个数字即每套拦截系统此时所拦截的最后一个导弹高度，来表示该系统。</li>\n<li>这样就可以得到一个数组，数组最终长度就是所需要的最少拦截系统数。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">int cnt = 0, ans = 0;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    dp[i] = 1;\n    for(int j = 1; j &lt; i; j++)&#123;\n        if(h[i] &lt;= h[j]) dp[i] = max(dp[i], dp[j] + 1);\n    &#125;\n    ans = max(ans, dp[i]);\n    // 更新子序列\n    int k = 0;\n    while(k &lt; cnt &amp;&amp; q[k] &lt; h[i]) k++;\n    if(k == cnt) q[cnt++] = h[i];\n    else q[k] = h[i];\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;\n</code></pre>\n<ul>\n<li>$O(nlogn)$ 贪心 + 贪心</li>\n</ul>\n<pre><code class=\"cpp\">//cnt表示导弹系统数，ans表示一个系统最多能拦截的导弹数\nint cnt = 0, ans = 0;\nint a;\nwhile(cin &gt;&gt; a)\n&#123;\n    //pos1表示以a结尾的最长不升子序列长度\n    int pos1 = upper_bound(f, f + ans, a, greater&lt;int&gt;()) - f; // 数组降序所以加上参数\n    if(pos1 == ans) f[ans++] = a;\n    else f[pos1] = a;\n\n    int pos2 = lower_bound(g, g + cnt, a) - g;\n    if(pos2 == cnt) g[cnt++] = a;\n    else g[pos2] = a;\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-导弹防御系统🌸\"><a href=\"#AcWing-导弹防御系统🌸\" class=\"headerlink\" title=\"AcWing|导弹防御系统🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTg5Lw==\">AcWing|导弹防御系统</span>🌸</h3><details>\n<summary>迭代加深解法</summary>\n    一般平均答案深度较低时可以采用这种方式。\n    <a href = \"https://www.acwing.com/solution/content/4258/\">迭代加深题解</a>\n</details>\n\n<ul>\n<li>我们很自然地会想到 $LIS$ 算法，不过这里的条件是一套防御系统的导弹拦截高度要么一直上升要么一直下降，所以用 $LIS$ 是不正确的。</li>\n<li>而在 $LIS$ 中，最核心的思想在于能否将一个元素加入到序列中，只与这个序列目前的最后一个元素有关。<ul>\n<li>因此用 $up[k]$ 和 $down[k]$ 记录第 $k$ 套上升（下降）系统目前所拦截的最后一个导弹。</li>\n<li>$dfs(u, su, sd)$ 意味着已有 $su$ 个上升，$sd$ 个下降，正在处理第 $u$ 个数。</li>\n</ul>\n</li>\n<li>在扩展节点时存在一个贪心策略<ul>\n<li>假设现在要把一个数放入一个上升序列，那么一定是所有能放入的上升序列中，最后一个元素最大的那一个。</li>\n<li>对于上升序列，能放入最大的那个就放入最大的那个。</li>\n</ul>\n</li>\n<li>复杂度 $O(n2^n)$</li>\n</ul>\n<pre><code class=\"cpp\">int q[N], ans, up[N], down[N], n;\nvoid dfs(int u, int su, int sd) &#123;\n    if (su + sd &gt;= ans) return; // ans不可能再小了\n    if (u == n) &#123;\n        ans = su + sd;  // su, sd 分别表示 len(up[]), len(down[])\n        return;\n    &#125;\n    // 情况1：将当前数放到上升子序列中\n    int k = 0;\n    while (k &lt; su &amp;&amp; up[k] &gt;= q[u]) k++;\n    int t = up[k];\n    up[k] = q[u];\n    if (k &lt; su) dfs(u + 1, su, sd);\n    else dfs(u + 1, su + 1, sd);\n    up[k] = t;\n    // 情况2：将当前数放到下降子序列中。\n    k = 0;\n    while (k &lt; sd &amp;&amp; down[k] &lt;= q[u]) k++;\n    t = down[k];\n    down[k] = q[u];\n    if (k &lt; sd) dfs(u + 1, su, sd);\n    else dfs(u + 1, su, sd + 1);\n    down[k] = t;\n&#125;\nvoid solve()&#123;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i];\n    ans = n;\n    dfs(0, 0, 0);\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-最大公共上升子序列🌸\"><a href=\"#AcWing-最大公共上升子序列🌸\" class=\"headerlink\" title=\"AcWing|最大公共上升子序列🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjc0Lw==\">AcWing|最大公共上升子序列</span>🌸</h3><ul>\n<li>这题是 <em>最长上升子序列</em> 和 <em>最长公共子序列</em> 的结合版，在状态表示和状态计算上都融合了这两道题的方法。</li>\n<li>状态表示<ul>\n<li>$f[i][j]$ 代表所有 $a[1 \\sim j]$ 中以 $b[j]$ 结尾的公共上升子序列的集合。</li>\n<li>$f[i][j]$ 的值等于该集合的子序列中长度的最大值。</li>\n</ul>\n</li>\n<li>状态计算<ul>\n<li>首先依据公共子序列中是否包含 $a[i]$，将 $f[i][j]$ 所代表的集合划分成两个不重不漏的子集：<ol>\n<li>不包含 $a[i]$ 的子集，最大值是 $f[i - 1][j]$。</li>\n<li>包含 $a[i]$ 的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在 $b[]$ 中是哪个数。<ul>\n<li>子序列只包含 $b[j]$ 一个数，长度是 $1$.</li>\n<li>子序列的倒数第二个数是 $b[1]$ 的集合，最大长度是 $f[i - 1][1] + 1$。</li>\n<li>…</li>\n<li>子序列的倒数第二个数是 $b[j - 1]$ 的集合，最大长度是 $f[i - 1][j - 1] + 1$。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>如果直接按上述思路实现，需要三重循环。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">for (int i = 1; i &lt;= n; i ++ )&#123;\n    for (int j = 1; j &lt;= n; j ++ )&#123;\n        f[i][j] = f[i - 1][j];\n        if (a[i] == b[j])&#123;\n            int maxv = 1;\n            for (int k = 1; k &lt; j; k ++ )\n                if (a[i] &gt; b[k])\n                    maxv = max(maxv, f[i - 1][k] + 1);\n            f[i][j] = max(f[i][j], maxv);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>然后我们发现每次循环求得的 $maxv$ 是满足 $a[i] &gt; b[k]$ 的 $f[i - 1][k] + 1$ 的前缀最大值。因此可以直接将 $maxv$ 提到第一层循环外面，减少重复计算，此时只剩下两重循环。</li>\n<li>最终答案枚举子序列结尾取最大值即可。</li>\n<li>时间复杂度 $O(n^2)$</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\nfor(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i];\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int maxv = 1;\n    for(int j = 1; j &lt;= n; j++)&#123;\n        f[i][j] = f[i - 1][j];\n        if(a[i] == b[j]) f[i][j] = max(f[i][j], maxv);\n        if(a[i] &gt; b[j]) maxv = max(maxv, f[i - 1][j] + 1);\n    &#125;\n&#125;\nint ans = 0;\nfor(int i = 1; i &lt;= n; i++) ans = max(ans, f[n][i]);\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>\n<hr>\n<h2 id=\"背包模型\"><a href=\"#背包模型\" class=\"headerlink\" title=\"背包模型\"></a>背包模型</h2><h3 id=\"AcWing-采药\"><a href=\"#AcWing-采药\" class=\"headerlink\" title=\"AcWing|采药\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDI1Lw==\">AcWing|采药</span></h3><ul>\n<li>01 背包裸题</li>\n</ul>\n<pre><code class=\"cpp\">int T, M;\ncin &gt;&gt; T &gt;&gt; M;\nfor(int i = 1; i &lt;= M; i++) cin &gt;&gt; t[i] &gt;&gt; w[i];\nfor(int i = 1 ;i &lt;= M; i++)&#123;\n    for(int j = T; j &gt;= t[i]; j--)&#123;\n        dp[j] = max(dp[j], dp[j - t[i]] + w[i]);\n    &#125;\n&#125;\ncout &lt;&lt; dp[T] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-装箱问题\"><a href=\"#AcWing-装箱问题\" class=\"headerlink\" title=\"AcWing|装箱问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyNi8=\">AcWing|装箱问题</span></h3><pre><code class=\"cpp\">int V, n;\ncin &gt;&gt; V &gt;&gt; n;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int v;\n    cin &gt;&gt; v;\n    for(int j = V; j &gt;= v; j--)&#123;\n        dp[j] = max(dp[j], dp[j - v] + v);\n    &#125;\n&#125;\ncout &lt;&lt; V - dp[V] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-二位费用的背包问题\"><a href=\"#AcWing-二位费用的背包问题\" class=\"headerlink\" title=\"AcWing|二位费用的背包问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOC8=\">AcWing|二位费用的背包问题</span></h3><pre><code class=\"cpp\">int n, V, M;\ncin &gt;&gt; n &gt;&gt; V &gt;&gt; M;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int v, m, w;\n    cin &gt;&gt; v &gt;&gt; m &gt;&gt; w;\n    for(int j = V; j &gt;= v; j--)&#123;\n        for(int k = M; k &gt;= m; k--)&#123;\n            dp[j][k] = max(dp[j][k], dp[j - v][k - m] + w);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[V][M] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-宠物小精灵之收服\"><a href=\"#AcWing-宠物小精灵之收服\" class=\"headerlink\" title=\"AcWing|宠物小精灵之收服\"></a><a href=\"\">AcWing|宠物小精灵之收服</a></h3><ul>\n<li>在背包问题中，体积 $w$ 与价值 $v$ 是可以互逆的！可以将 $f[i]$  表示为体积为 $i$ 能装的最大价值，也可以将  $f[i]$  表示为价值为 $i$ 所需的最小体积。两者等价，我们只需要选择范围较小的那维作为体就可以了！这直接影响到时空复杂度。</li>\n<li>这题就是个案例。</li>\n<li>同时，该题也是个 <strong>01 背包</strong> 的扩展 —— <strong>二维费用 01 背包问题</strong></li>\n<li>把 <em>野生宝可梦</em> 看作物品，则捕捉他需要的 <em>精灵球</em> 个数就是第一费用，战斗时皮卡丘要减少的血量就是第二费用。</li>\n<li>最后答案要求物品数量最多，因此我们可以用状态的属性来表示选择的物品数</li>\n</ul>\n<pre><code class=\"cpp\">int N, M, K;\ncin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\t// 精灵球数量；皮卡丘初始的体力值、野生小精灵的数量\nfor(int i = 1; i &lt;= K; i++)&#123;\n    int v1, v2;\n    cin &gt;&gt; v1 &gt;&gt; v2;\n    for(int j = N; j &gt;= v1; j--)&#123;\n        for(int k = M - 1; k &gt;= v2; k--)&#123;\n            dp[j][k] = max(dp[j][k], dp[j - v1][k - v2] + 1);\n        &#125;\n    &#125;\n&#125;\nint cost_health = M;\t// 消耗的体力值的最小值\nfor(int i = 0; i &lt;= M - 1; i++)&#123;\n    if(dp[N][i] == dp[N][M - 1]) cost_health = min(cost_health, i);\n&#125;\ncout &lt;&lt; dp[N][M - 1] &lt;&lt; &quot; &quot; &lt;&lt; M - cost_health &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-多重背包问题-Ⅲ🌸\"><a href=\"#AcWing-多重背包问题-Ⅲ🌸\" class=\"headerlink\" title=\"AcWing|多重背包问题 Ⅲ🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNi8=\">AcWing|多重背包问题 Ⅲ</span>🌸</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzUzNTA3Lw==\">详细证明</span></li>\n<li>求滑动窗口内的最大值<ul>\n<li>滑动窗口大小随每种物品可选个数变化</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 200010;\nint n, m; // 种类数，总体积大小\nint f[N], g[N], q[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n; i++)&#123;\n        int v, w, s;\n        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;\n        memcpy(g, f, sizeof(f));\n        for(int j = 0; j &lt; v; j++)&#123; // 枚举余数\n            int hh = 0, tt = -1;\n            for(int k = j; k &lt;= m; k += v)&#123;\n                if(hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh++;\n                while(hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt--;\n                q[++tt] = k;\n                f[k] = g[q[hh]] + (k - q[hh]) / v * w;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-潜水员\"><a href=\"#AcWing-潜水员\" class=\"headerlink\" title=\"AcWing|潜水员\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMi8=\">AcWing|潜水员</span></h3><ul>\n<li>只要有一维的体积为 $0$ ，则另一维一定为 $0$。</li>\n<li>若有一维小于 $0$ ，则可以看作是从 $0$ 开始转移。</li>\n<li>求最小值</li>\n</ul>\n<pre><code class=\"cpp\">memset(dp, 0x3f, sizeof(dp));\ndp[0][0] = 0;\nint n, m, q;\ncin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\nfor(int i = 1; i &lt;= q; i++)&#123;\n    int a, b, w;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;\n    for(int j = n; j &gt;= 0; j--)&#123;\n        for(int k = m; k &gt;= 0; k--)&#123;\n            dp[j][k] = min(dp[j][k], dp[max(0, j - a)][max(0, k - b)] + w);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[n][m] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-数字组合\"><a href=\"#AcWing-数字组合\" class=\"headerlink\" title=\"AcWing|数字组合\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjgwLw==\">AcWing|数字组合</span></h3><pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\ndp[0] = 1;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int x;\n    cin &gt;&gt; x;\n    for(int j = m; j &gt;= x; j--)&#123;\n        dp[j] += dp[j - x];\n    &#125;\n&#125;\ncout &lt;&lt; dp[m] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-庆功会\"><a href=\"#AcWing-庆功会\" class=\"headerlink\" title=\"AcWing|庆功会\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMS8=\">AcWing|庆功会</span></h3><ul>\n<li>多重背包裸题，朴素版即可 AC 。</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int v, w, s;\n    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;\n    for(int j = m; j &gt;= v; j--)&#123;\n        for(int k = 0; k &lt;= s &amp;&amp; k * v &lt;= j; k++)&#123;\n            dp[j] = max(dp[j], dp[j - v * k] + w * k);\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[m] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-买书\"><a href=\"#AcWing-买书\" class=\"headerlink\" title=\"AcWing|买书\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyNS8=\">AcWing|买书</span></h3><ul>\n<li>完全背包经典优化<br>$\\quad f(i, j) \\quad &#x3D; ; f(i-1, j)+f(i-1, j-v_{i})+\\cdots+f \\left (i-1, j-s v_{i} \\right)$<br>$f\\left (i, j-v_{i}\\right) &#x3D; \\qquad \\qquad \\quad ; f\\left (i-1, j-v_{i}\\right)+\\cdots+f\\left (i-1, j-s v_{i}\\right)$</li>\n<li>同时，观察到该转移方程对于第 $i$ 阶段的状态，只会使用第 $i-1$ 层和第 $i$ 层的状态。因此我们也可以采用 01 背包的空间优化方案</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint v[4] = &#123;10, 20, 50, 100&#125;;\nint dp[1010];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n;\n    cin &gt;&gt; n;\n    dp[0] = 1;\n    for(int i = 0; i &lt; 4; i++)&#123;\n        for(int j = v[i]; j &lt;= n; j++)&#123;\n            dp[j] += dp[j - v[i]];\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[n] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-背包问题求具体方案\"><a href=\"#AcWing-背包问题求具体方案\" class=\"headerlink\" title=\"AcWing|背包问题求具体方案\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTIv\">AcWing|背包问题求具体方案</span></h3><ul>\n<li>先正序保存物品的体积和价值，然后倒序 dp ，就可以按正序逆推出字典序最小的方案了。</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];\nfor(int i = n; i &gt;= 1; i--)&#123;\n    for(int j = 0; j &lt;= m; j++)&#123;\n        dp[i][j] = dp[i + 1][j];\n        if(j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]);\n    &#125;\n&#125;\nint t = m;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    if(t &gt;= v[i] &amp;&amp; dp[i][t] == dp[i + 1][t - v[i]] + w[i])&#123;\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n        t -= v[i];\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-机器分配\"><a href=\"#AcWing-机器分配\" class=\"headerlink\" title=\"AcWing|机器分配\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxNS8=\">AcWing|机器分配</span></h3><ul>\n<li>可以将此题看作分组背包问题，每个公司仅能选择 $k$ 个机器，总体积为 $m$ ，即为总共 $m$ 个机器。</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = 1; j &lt;= m; j++)&#123;\n        cin &gt;&gt; w[i][j];\n    &#125;\n&#125;\nfor(int i = n; i &gt;= 1; i--)&#123;\n    for(int j = 0; j &lt;= m; j++)&#123;\n        for(int k = 0; k &lt;= j; k++)&#123;\n            dp[i][j] = max(dp[i][j], dp[i + 1][j - k] + w[i][k]);\n        &#125;\n    &#125;\n&#125;\nint j = m;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int k = 0; k &lt;= j; k++)&#123;\n        if(dp[i][j] == dp[i + 1][j - k] + w[i][k])&#123;\n            way[i] = k;\n            j -= k;\n            break;\n        &#125;\n    &#125;\n&#125;\ncout &lt;&lt; dp[1][m] &lt;&lt; endl;\nfor(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; way[i] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-金明的预算方案\"><a href=\"#AcWing-金明的预算方案\" class=\"headerlink\" title=\"AcWing|金明的预算方案\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDg5Lw==\">AcWing|金明的预算方案</span></h3><ul>\n<li>可以把每种主件和附属的附件组合的方案全列举出来进行选择，用二进制进行枚举。<ul>\n<li>每种主件的搭配方案共 $2^2$ 种。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\n#define x first\n#define y second\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 32010, M = 70;\nint dp[N];\nPII master[M];\nvector&lt;PII&gt; servant[M];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        int v, p, q;\n        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;\n        if(!q) master[i] = &#123;v, v * p&#125;;\n        else servant[q].push_back(&#123;v, v * p&#125;);\n    &#125;\n    for(int i = 1; i &lt;= m; i++)&#123;\n        if (master[i]. x)&#123;\t\t// 判断是否为主件，且价值是否不是 0.\n            for(int j = n; j &gt;= 0; j--)&#123;\n                auto &amp;s = servant[i];\n                for(int k = 0; k &lt; 1 &lt;&lt; s.size(); k++)&#123;\n                    int v = master[i].x, w = master[i].y;\n                    for(int l = 0; l &lt; s.size(); l++)&#123;\n                        if(k &gt;&gt; l &amp; 1) v += s[l].x, w += s[l].y;\n                    &#125;\n                    if(j &gt;= v) dp[j] = max(dp[j], dp[j - v] + w);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; dp[n] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-开心的金明\"><a href=\"#AcWing-开心的金明\" class=\"headerlink\" title=\"AcWing|开心的金明\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDI4Lw==\">AcWing|开心的金明</span></h3><pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= m; i++)&#123;\n    int v, p;\n    cin &gt;&gt; v &gt;&gt; p;\n    for(int j = n; j &gt;= v; j--)&#123;\n        dp[j] = max(dp[j], dp[j - v] + v * p);\n    &#125;\n&#125;\ncout &lt;&lt; dp[n] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-货币系统\"><a href=\"#AcWing-货币系统\" class=\"headerlink\" title=\"AcWing|货币系统\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAyMy8=\">AcWing|货币系统</span></h3><ul>\n<li>同上 <em>买书</em> 一题</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i];\ndp[0] = 1;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    for(int j = v[i]; j &lt;= m; j++)&#123;\n        dp[j] += dp[j - v[i]];\n    &#125;\n&#125;\ncout &lt;&lt; dp[m] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-货币系统-NOIP2018\"><a href=\"#AcWing-货币系统-NOIP2018\" class=\"headerlink\" title=\"AcWing|货币系统 NOIP2018\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTM0Lw==\">AcWing|货币系统 NOIP2018</span></h3><ul>\n<li>题意<ul>\n<li>定义一个货币系统 $(n, a)$ ：一共有 $n$ 种货币，每种货币对应面值为 $a_i$。</li>\n<li>每种货币可以使用任意多个，进行线性组合：</li>\n<li>$k &#x3D; x_1a_1 + x_2a_2 + \\cdots + x_na_n$，其中 $X_i\\in Z \\quad (i &#x3D; 1, 2, \\cdots)$</li>\n<li>$k$ 为该货币系统 $(n, a)$ 能够 <strong>线性表示</strong> 的数值 （本题的系数必须为非负整数，因此<strong>与线性代数中的线性表出不一致</strong>）</li>\n<li>定义 $(n, a) \\text { 和 }(m, b) \\text { 等价 } \\Leftrightarrow \\forall k \\in Z^{+}$，$k$ 如果能被 $a$ 线性表出，则 $k$ 也能被 $b$ 线性表出，反之则都不能。</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>由已知每种货币可以使用 <em>无穷多</em> 信息可以初步判断是完全背包的变种。</li>\n<li>假设货币系统中存在一个元素可以被其他的元素线性表示的话，该元素则可以认为是无效的。</li>\n<li>因此我们需要求出该货币系统的最大无关向量组。</li>\n<li>我们可以利用数论中 <strong>埃氏筛法</strong> 的思想。<ul>\n<li>对于一个无效的元素，它只会被小于它的元素线性表示。所以我们需要先行排序。</li>\n<li>而我们在做完全背包的适合，需要求出所有恰好能被前 $i$ 个物品选出的体积的方案，即在完全背包求方案数的过程中，统计那些 <em>初始不能被满足</em> 的物品体积的个数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">int n;\ncin &gt;&gt; n;\nfor(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\nsort(a + 1, a + 1 + n);\ndp[0] = 1;\nint m = a[n], ans = 0;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    if(!dp[a[i]]) ans++;\n    for(int j = a[i]; j &lt;= m; j++)&#123;\n        dp[j] += dp[j - a[i]];\n    &#125;\n&#125;\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-混合背包问题\"><a href=\"#AcWing-混合背包问题\" class=\"headerlink\" title=\"AcWing|混合背包问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNy8=\">AcWing|混合背包问题</span></h3><ul>\n<li>01 背包可以看作是可选次数最多为 $1$ 的多重背包。</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int v, w, s;\n    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;\n    if(s == 0)&#123;\n        for(int j = v; j &lt;= m; j++) dp[j] = max(dp[j], dp[j - v] + w);\n    &#125;else&#123;\n        if(s == -1) s = 1;\n        for(int j = 1; j &lt;= s; j &lt;&lt;= 1)&#123;\n            for(int k = m; k &gt;= j * v; k--) dp[k] = max(dp[k], dp[k - j * v] + j * w);\n            s -= j;\n        &#125;\n        if(s) for(int k = m; k &gt;= s * v; k--) dp[k] = max(dp[k], dp[k - s * v] + s * w);\n    &#125;\n&#125;\ncout &lt;&lt; dp[m] &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-有依赖的背包问题🌸\"><a href=\"#AcWing-有依赖的背包问题🌸\" class=\"headerlink\" title=\"AcWing|有依赖的背包问题🌸\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAv\">AcWing|有依赖的背包问题</span>🌸</h3><ul>\n<li>题意<ul>\n<li>有依赖的背包问题是指物品之间存在依赖关系，这种依赖关系可以用一棵树来表示，要是我们想要选择子节点就必须连同其父节点一起选。</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>按照以往线性背包 DP 的状态转移，第 $i$ 件物品只会依赖第 $i - 1$ 物品的状态。假如本题也采用该种状态依赖关系的话，对于节点 $i$ ，我们需要枚举他所有子节点的组合共 $2^k$ 种，再枚举体积，时间复杂度会变得十分高。</li>\n<li>因此我们转换思考方式，枚举<strong>每个状态分给子节点的体积</strong></li>\n<li>时间复杂度为 $O (N \\times V \\times V)$</li>\n</ul>\n</li>\n<li><strong>状态表示</strong><ul>\n<li>集合：所有从以 $u$ 为根的子树中选，且总体积不超过 $j$ 的方案。</li>\n<li>属性：Max</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\nint dp[N][N];\nint v[N], w[N];\nint h[N], e[N], ne[N], idx;\nint n, m;\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\nvoid dfs(int u)&#123;\n    for(int i = h[u]; ~i; i = ne[i])&#123;   // 循环物品组\n        int son = e[i];\n        dfs(son);\n        // 分组背包\n        for(int j = m - v[u]; j &gt;= 0; j--)&#123;     // 循环体积\n            for(int k = 0; k &lt;= j; k++)&#123;        // 循环决策\n                dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[son][k]);\n            &#125;\n        &#125;\n    &#125;\n    // 将物品 u 加进去\n    for(int i = m; i &gt;= v[u]; i--) dp[u][i] = dp[u][i - v[u]] + w[u];\n    for(int i = 0; i &lt; v[u]; i++) dp[u][i] = 0;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof(h));\n    int root;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int p;\n        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;\n        if(p == -1) root = i;\n        else add(p, i);\n    &#125;\n    dfs(root);\n    cout &lt;&lt; dp[root][m] &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-背包问题求方案数\"><a href=\"#AcWing-背包问题求方案数\" class=\"headerlink\" title=\"AcWing|背包问题求方案数\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTEv\">AcWing|背包问题求方案数</span></h3><ul>\n<li>首先题目中要求 <strong>最优选法的方案数</strong>, 且为 01 背包求解最优方案。</li>\n<li>$dp[i]$ 表示背包容积恰好为 $i$ 时的最大价值和。</li>\n<li>$ans[i]$ 表示背包容积恰好为 $i$ 时取最优解的方案。</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;\ncin &gt;&gt; n &gt;&gt; m;\nmemset(dp, -0x3f, sizeof(dp));\nans[0] = 1, dp[0] = 0;\nfor(int i = 1; i &lt;= n; i++)&#123;\n    int v, w;\n    for(int j = m; j &gt;= v; j--)&#123;\n    cin &gt;&gt; v &gt;&gt; w;\n        int maxv = max(dp[j], dp[j - v] + w);\n        int cnt = 0;\n        if(maxv == dp[j]) cnt += ans[j];\n        if(maxv == dp[j - v] + w) cnt += ans[j - v];\n        dp[j] = maxv, ans[j] = cnt % MOD;\n    &#125;\n&#125;\nint res = *max_element(dp, dp + m + 1);\nint cnt = 0;\nfor(int i = 0; i &lt;= m; i++)&#123;\n    if(dp[i] == res)&#123;\n        cnt = (cnt + ans[i]) % MOD;\n    &#125;\n&#125;\ncout &lt;&lt; cnt &lt;&lt; endl;\n</code></pre>\n<h3 id=\"AcWing-能量石🌖\"><a href=\"#AcWing-能量石🌖\" class=\"headerlink\" title=\"AcWing|能量石🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNzM2Lw==\">AcWing|能量石</span>🌖</h3><ul>\n<li>题意<ul>\n<li>共有 $N$ 块能量石，吃掉它的时间是 $S_i$ ，获得的能量是 $E_i$，每单位时间内损失的能量是 $L_i$。在刚吃每块能量石时就能立刻获得它的能量，不会继续衰减，且无法中断整个过程。求最终获得的最大能量。</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>先进行 <strong>贪心</strong> 将问题转化，使用<em>交换位置法</em> ，假设对任意两个有能量剩余的能量石 $s_i, s_j$，交换位置后两个宝石的贡献总和不会变得更大，即 $E_i + E_j - (S_i \\times L_j \\le E_i + E_j - (S_J \\times L_i)$，化简后为 $S_i \\times L_j \\le S_j \\times L_i$。我们只需要按照该条件对能量石进行排序。</li>\n<li>对于其它形式的放置方法，必然可以通过上面的条件交换某满足的两项来获得更小值。</li>\n<li>因此，我们只需要按照 01 背包的方法，对其进行动态规划。</li>\n<li>$dp[i]$ 表示当前恰好花费 $i$ 单位时间得到的最大能量。</li>\n<li>初始状态 $dp[0] &#x3D; 0$。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010;\nstruct Stone\n&#123;\n    int s, e, l;\n    bool operator&lt;(const Stone &amp;w) const&#123;\n        return s * w.l &lt; w.s * l;\n    &#125;\n&#125;stones[110];\nint dp[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int T;\n    cin &gt;&gt; T;\n    for(int C = 1; C &lt;= T; C++)&#123;\n        int n, m = 0;\n        cin &gt;&gt; n;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            cin &gt;&gt; stones[i].s &gt;&gt; stones[i].e &gt;&gt; stones[i].l;\n            m += stones[i].s;\n        &#125;\n        sort(stones + 1, stones + n + 1);\n        memset(dp, -0x3f, sizeof(dp));\n        dp[0] = 0;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            int s = stones[i].s, e = stones[i].e, l = stones[i].l;\n            for(int j = m; j &gt;= s; j--)&#123;\n                dp[j] = max(dp[j], dp[j - s] + e - (j - s) * l);\n            &#125;\n        &#125;\n        int ans = *max_element(dp, dp + m + 1);\n        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; C &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"状态机模型\"><a href=\"#状态机模型\" class=\"headerlink\" title=\"状态机模型\"></a>状态机模型</h2><ul>\n<li>把结果扩展成过程</li>\n</ul>\n<h3 id=\"AcWing-大盗阿福\"><a href=\"#AcWing-大盗阿福\" class=\"headerlink\" title=\"AcWing|大盗阿福\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA1MS8=\">AcWing|大盗阿福</span></h3><ul>\n<li>状态表示 $f[i, 0], f[i, 1]$<ul>\n<li>集合：所有走了 $i$ 步，且当前位于状态 $j$ 的所有走法</li>\n<li>属性：Max</li>\n</ul>\n</li>\n<li>状态机入口时一定是状态 $0$，因此需要将 $dp[0][1]$ 置为负无穷</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010, INF = 0x3f3f3f3f;\nint dp[N][2], w[N];\nvoid solve()&#123;\n    int n; cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    dp[0][0] = 0, dp[0][1] = -INF;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);\n        dp[i][1] = dp[i - 1][0] + w[i];\n    &#125;\n    cout &lt;&lt; max(dp[n][0], dp[n][1]) &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h3 id=\"AcWing-股票买卖-Ⅳ\"><a href=\"#AcWing-股票买卖-Ⅳ\" class=\"headerlink\" title=\"AcWing|股票买卖 Ⅳ\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA1OS8=\">AcWing|股票买卖 Ⅳ</span></h3><ul>\n<li>状态表示 $f[i, j, 0], f[i, j, 1]$<ul>\n<li>集合：$f[i, j, 0]$ 表示第 $i$ 天，已经进行完第 $j$ 次交易，且手中无货。$f[i, j, 1]$ 表示第 $i$ 天，正在进行第 $j$ 次交易，且手中有货。</li>\n<li>属性：Max</li>\n</ul>\n</li>\n<li>初始化为 $0$ 表示该状态合法，初始化为 $-INF$ 表示为不合法</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010, K = 110, INF = 0x3f3f3f3f;\nint dp[N][K][2], w[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, k; cin &gt;&gt; n &gt;&gt; k;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    memset(dp, -0x3f, sizeof(dp));\n    for(int i = 0; i &lt;= n; i++) dp[i][0][0] = 0; // 注意从第 0 天开始\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 1; j &lt;= k; j++)&#123;\n            dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + w[i]);\n            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - w[i]);\n        &#125;\n    &#125;\n    int ans = 0;\n    for(int i = 1; i &lt;= k; i++) ans = max(ans, dp[n][i][0]);\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-股票买卖-Ⅴ\"><a href=\"#AcWing-股票买卖-Ⅴ\" class=\"headerlink\" title=\"AcWing|股票买卖 Ⅴ\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA2MC8=\">AcWing|股票买卖 Ⅴ</span></h3><ul>\n<li>有三个状态，「手中有货」、「手中无货的第 $1$ 天 」、「手中无货的第 $\\ge 2$ 天 」</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010, INF = 0x3f3f3f3f;\nint dp[N][3], w[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n; cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\n    dp[0][0] = dp[0][1] = -INF;\n    dp[0][2] = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - w[i]);\n        dp[i][1] = dp[i - 1][0] + w[i];\n        dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);\n    &#125;\n    cout &lt;&lt; max(dp[n][1], dp[n][2]) &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"AcWing-设计密码🌖\"><a href=\"#AcWing-设计密码🌖\" class=\"headerlink\" title=\"AcWing|设计密码🌖\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA1NC8=\">AcWing|设计密码</span>🌖</h3><ul>\n<li>状态表示 $f(i, j)$<ul>\n<li>集合：到第 $i$ 的字母时，匹配到子串中（next 数组）中状态是 $j$ 时所有方案的数量</li>\n</ul>\n</li>\n<li>本题以 $j$ 的位置为状态机</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzU1NDQ5Lw==\">线性DP + KMP自动机模型</span> | <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50LzI4MDIyLw==\">思路详解</span></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 55, mod = 1e9 + 7;\nchar s[N];\nint dp[N][N], ne[N];\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; s + 1;\n    m = strlen(s + 1);\n    for(int i = 2, j = 0; i &lt;= m; i++)&#123;\n        while(j &amp;&amp; s[i] != s[j + 1]) j = ne[j];\n        if(s[i] == s[j + 1]) j++;\n        ne[i] = j;\n    &#125;\n    dp[0][0] = 1;\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt; m; j++)&#123;\n            for(char ch = &#39;a&#39;; ch &lt;= &#39;z&#39;; ch++)&#123;\n                int ptr = j;\n                while(ptr &amp;&amp; s[ptr + 1] != ch) ptr = ne[ptr];\n                if(s[ptr + 1] == ch) ptr++;\n                dp[i + 1][ptr] = (dp[i + 1][ptr] + dp[i][j]) % mod;\n            &#125;\n        &#125;\n    &#125;\n    int ans = 0;\n    for(int i = 0; i &lt; m; i++) ans = (ans + dp[n][i]) % mod;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"单调队列优化-DP\"><a href=\"#单调队列优化-DP\" class=\"headerlink\" title=\"单调队列优化 DP\"></a>单调队列优化 DP</h2><hr>\n<h2 id=\"斜率优化-DP\"><a href=\"#斜率优化-DP\" class=\"headerlink\" title=\"斜率优化 DP\"></a>斜率优化 DP</h2>",
            "tags": [
                "模板",
                "题集"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html",
            "url": "https://asterzc19.github.io/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86.html",
            "title": "位运算合集",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<blockquote>\n<p><del>因为无法使用 <em>LaTex</em> 语法，故只使用外部链接的方式进行跳转。</del><br>已可以正常使用 <em>LaTex</em> 语法   -2022&#x2F;02&#x2F;07</p>\n</blockquote>\n<h3 id=\"位运算基础知识\"><a href=\"#位运算基础知识\" class=\"headerlink\" title=\"位运算基础知识\"></a>位运算基础知识</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY29sb3Blbi1ibG9nLmNvbS9BbGdvcml0aG0vbHlkZ3VpZC96MHgwMV8lRTQlQkQlOEQlRTglQkYlOTAlRTclQUUlOTcv\">《算法竞赛进阶指南》0x01 位运算</span></li>\n</ul>\n<blockquote>\n<p><strong>待完成</strong></p>\n</blockquote>\n",
            "tags": [
                "算法",
                "模板"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF.html",
            "url": "https://asterzc19.github.io/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF.html",
            "title": "基础数据结构模板",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><pre><code class=\"cpp\">// head存储链表头, e[]存储节点的值, ne[]存储节点的next指针, idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n// 初始化\nvoid init()\n&#123;\n    head = -1;\n    idx = 0;\n&#125;\n// 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] = a, ne[idx] = head, head = idx++;\n&#125;\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head = ne[head];\n&#125;\n</code></pre>\n<h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><pre><code class=\"cpp\">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\nvoid init()\n&#123;\n    // 0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n&#125;\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx++;\n&#125;\n// 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n&#125;\n</code></pre>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><pre><code class=\"cpp\">// tt表示栈顶\nint stk[N], tt = 0;\n// 向栈顶插入一个数\nstk[++tt] = x;\n// 从栈顶弹出一个数\ntt--;\n// 栈顶的值\nstk[tt];\n// 判断栈是否为空\nif (tt &gt; 0)&#123;\n\n&#125;\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"1-普通队列\"><a href=\"#1-普通队列\" class=\"headerlink\" title=\"1. 普通队列\"></a>1. 普通队列</h4><pre><code class=\"cpp\">// hh表示队头， tt表示队尾\nint q[N], hh = 0, tt = -1;\n// 向队尾插入一个数\nq[++tt] = x;\n// 从队头弹出一个数\nhh++;\n// 队头的值\nq[hh]; // 队尾的值 q[tt]\n// 判断队列是否为空\nif (hh &lt;= tt)&#123;\n\n&#125;\n</code></pre>\n<h4 id=\"2-循环队列\"><a href=\"#2-循环队列\" class=\"headerlink\" title=\"2. 循环队列\"></a>2. 循环队列</h4><pre><code class=\"cpp\">// hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh = 0, tt = 0;\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh != tt)&#123;\n\n&#125;\n</code></pre>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><pre><code class=\"cpp\">常见模型：找出每个数左边离它最近的比它大/小的数\n//如果遇到每个数右边离它最近的比它大/小的数 倒序判断即可, i = n;\nint tt = 0;\nfor (int i = 1; i &lt;= n; i++)&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt--;\n    stk[++tt] = i;\n&#125;\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU3ODg=\">Luogu 例题</span></p>\n<h3 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h3><pre><code class=\"cpp\">常见模型：找出滑动窗口中的最大值/最小值\nint hh = 0, tt = -1;\nfor (int i = 1; i &lt; n; i++)&#123;\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh++; // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt--;\n    q[++tt] = i;\n&#125;\n</code></pre>\n<h3 id=\"kmp\"><a href=\"#kmp\" class=\"headerlink\" title=\"kmp\"></a>kmp</h3><pre><code class=\"cpp\">// s[]是长文本, p[]是模式串, n是s的长度, m是p的长度\n求模式串的Next数组：\nfor (int i = 2, j = 0; i &lt;= m; i++)&#123;\n    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n    if (p[i] == p[j + 1]) j++;\n    ne[i] = j;\n&#125;\n// 匹配\nfor (int i = 1, j = 0; i &lt;= n; i++)&#123;\n    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j++;\n    if (j == m)&#123;\n        j = ne[j];\n        // 匹配成功后的逻辑 \n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"Trie-树\"><a href=\"#Trie-树\" class=\"headerlink\" title=\"Trie 树\"></a>Trie 树</h3><pre><code class=\"cpp\">int son[N][26], cnt[N], idx;\n// 0号节点既是根节点，又是空节点\n// son[][]存储树中每个节点的子节点\n// cnt[]存储以每个节点结尾的单词数量\n// 插入一个字符串\nvoid insert(char *str)\n&#123;\n    int p = 0;\n    for (int i = 0; str[i]; i++)&#123;\n        int u = str[i] - &#39;a&#39;;\n        if (!son[p][u]) son[p][u] = ++idx;\n        p = son[p][u];\n    &#125;\n    cnt[p]++;\n&#125;\n// 查询字符串出现的次数\nint query(char *str)\n&#123;\n    int p = 0;\n    for (int i = 0; str[i]; i++)&#123;\n        int u = str[i] - &#39;a&#39;;\n        if (!son[p][u]) return 0;\n        p = son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n</code></pre>\n<h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><pre><code class=\"cpp\">（1）朴素并查集：\n\nint p[N]; // 存储每个点的祖宗节点\n// 返回x的祖宗节点\nint find(int x)\n&#123;\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\n// 初始化，假定节点编号是1~n\n    for (int i = 1; i &lt;= n; i++) p[i] = i;\n// 合并a和b所在的两个集合\n    p[find(a)] = find(b);\n\n（2）维护size的并查集：\n\nint p[N], size[N];\n// p[]存储每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n// 返回x的祖宗节点\nint find(int x)\n&#123;\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)&#123;\n    p[i] = i;\n    size[i] = 1;\n&#125;\n// 合并a和b所在的两个集合：\nsize[find(b)] += size[find(a)];\np[find(a)] = find(b);\n\n（3）维护到祖宗节点距离的并查集：\n\nint p[N], d[N];\n// p[]存储每个点的祖宗节点，d[x]存储x到p[x]的距离\n// 返回x的祖宗节点\nint find(int x)\n&#123;\n    if (p[x] != x)&#123;\n        int u = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = u;\n    &#125;\n    return p[x];\n&#125;\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)&#123;\n    p[i] = i;\n    d[i] = 0;\n&#125;\n//合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n</code></pre>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><pre><code class=\"cpp\">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n// ph[k]存储第k个插入的点在堆中的位置\n// hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]], ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\nvoid down(int u)\n&#123;\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)&#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\nvoid up(int u)\n&#123;\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])&#123;\n        heap_swap(u, u/2);\n        u &gt;&gt;= 1;\n    &#125;\n&#125;\n// O(n)建堆\nfor (int i = n/2; i; i--) down(i);\n</code></pre>\n<p><a href=\"\">例题：AcWing 839</a></p>\n<h3 id=\"一般哈希\"><a href=\"#一般哈希\" class=\"headerlink\" title=\"一般哈希\"></a>一般哈希</h3><pre><code class=\"cpp\">// 一般取模数要是质数，且离2的整次幂较远。\n（1）拉链法\nint h[N], e[N], ne[N], idx;//h[]为各个点的头结点\n// 向哈希表中插入一个数\nvoid insert(int x)\n&#123;\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx++;\n&#125;\n\n// 在哈希表中查询某个数是否存在\nbool find(int x)\n&#123;\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i])&#123;\n        if (e[i] == x) return true;\n    &#125;\n    return false;\n&#125;\n\n（2）开放寻址法\nint h[N];\n// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\nint find(int x)\n&#123;\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x)&#123;\n        t++;\n        if (t == N) t = 0;\n    &#125;\n    return t;\n&#125;\n</code></pre>\n<h3 id=\"字符串哈希\"><a href=\"#字符串哈希\" class=\"headerlink\" title=\"字符串哈希\"></a>字符串哈希</h3><pre><code class=\"cpp\">核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long 存储，溢出的结果就是取模的结果。\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值，p[k]存储 P^k mod 2^64\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i++)&#123;\n    h[i] = h[i-1] * P + str[i];\n    p[i] = p[i-1] * P;\n&#125;\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n</code></pre>\n",
            "tags": [
                "算法",
                "数据结构",
                "模板"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/STL%E7%AE%80%E4%BB%8B.html",
            "url": "https://asterzc19.github.io/post/STL%E7%AE%80%E4%BB%8B.html",
            "title": "STL 简介",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<pre><code class=\"cpp\">vector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()/back()\n    push_back()/pop_back()\n    begin()/end()\n    []\n    支持比较运算，按字典序\n\npair&lt;int, int&gt;\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\nstring，字符串\n    size()/length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大根堆\n    size()\n    empty()\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列\n    size()\n    empty()\n    clear()\n    front()/back()\n    push_back()/pop_back()\n    push_front()/pop_front()\n    begin()/end()\n    []\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()/end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set/multiset\n        insert()  插入一个数\n        find()  查找一个数\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()/upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map/multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()/upper_bound()\n\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()/upper_bound()， 迭代器的++，--\n\nbitset, 圧位\n    bitset&lt;10000&gt; s;\n    ~, &amp;, |, ^\n    &gt;&gt;, &lt;&lt;\n    ==, !=\n    []\n\n    count()  返回有多少个1\n\n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n\n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n</code></pre>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM0MDU=\">洛谷P3405</span></p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMjcxNTAvQg==\">黑龙江职院B题</span></p>\n",
            "tags": [
                "算法",
                "模板"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html",
            "url": "https://asterzc19.github.io/post/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95.html",
            "title": "题目小集",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<p>打算按题型分大类，然后选取相关的题目。</p>\n<p>*部分题目可能也会随着时间流逝，被我删除（</p>\n<p>以下题目相关题解部分来自</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9wenItODQvcG9zdHM=\">知乎 | pzr</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jYWRlLTc0LTEwL3Bvc3Rz\">知乎 | Ander</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sdW9ndS5jb20uY24v\">洛谷</span></p>\n<h2 id=\"自然数列全排列（大概意思）\"><a href=\"#自然数列全排列（大概意思）\" class=\"headerlink\" title=\"自然数列全排列（大概意思）\"></a>自然数列全排列（大概意思）</h2><h3 id=\"CodeForces-1617C-Paprika-and-Permutation\"><a href=\"#CodeForces-1617C-Paprika-and-Permutation\" class=\"headerlink\" title=\"CodeForces|1617C. Paprika and Permutation\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTcvcHJvYmxlbS9D\">CodeForces|1617C. Paprika and Permutation</span></h3><ul>\n<li><p>题意</p>\n<ul>\n<li>有一个长度为 $n$ 的数组 $a_1, a_2, … , a_n$ 。每次操作你可以选择数组中的一个元素 $a_i$ 和 $x$ ，然后将 $a_i$ 替换为 $a_i ; mod ; x$。</li>\n<li>求至少要多少次操作才能够将数组 $a$ 变为一个 $1$ 到 $n$ 的排列。如果无法实现，输出 <code>-1</code>。</li>\n<li>$t$ 组数据。</li>\n</ul>\n</li>\n<li><p>题解</p>\n</li>\n<li><p>可以发现，对 $a_i$ 进行一次操作，$a_i$ 的值将是 $\\left[ 1 , a_i - a_i &#x2F; 2 \\right) \\cup \\left { a_i \\right } $ 之间的一个数。而 $a_i \\to a_i$ 没有什么意义，所以认为一次操作是将 $a_i$ 变为 $\\left[ 1 , a_i - a_i &#x2F; 2 \\right)$ 中的一个数。</p>\n<ul>\n<li>考虑这组样例：</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">9\n1 2 3 4 18 19 5 6 7\n</code></pre>\n<ul>\n<li>这提示我们，如果原来有某个 $a_i$ 已经在 $\\left[ 1, n \\right ]$ 之间，最好不要对它进行任何操作。（当然，如果 $a_i$ 这个数出现了多次，我们选择其中一个数，不对它进行任何操作。）这样的策略是明智的，假设我们现在令 $a_i \\to x$ ，但为了形成排列，现在没有数等于 $a_i$ ，一定又需要对某个 $y : y - y&#x2F;2 &gt; a_i$ 进行操作使得 $y \\to a_i$ 。这样一来花费了 $2$ 的代价，还不如直接令 $y \\to x$ 。</li>\n<li>接下来我们令 $i &#x3D; 1 … n$ 循环，如果原数组中没有任何数等于 $i$ ，则需要找一个数变化到 $i$ 。此时贪心地将较小的数变化到 $i$ 是比较合适的。例如：</li>\n</ul>\n<pre><code class=\"cpp\">5\n1 3 3 4 7\n</code></pre>\n<ul>\n<li><p>考虑 $3 \\to 2, 7 \\to 5$ 是比较合适的。如果 $3$ 不能变化到 $2$ ，显然更不能变化到 $5$ 或更大的数，直接输出 $-1$ 即可。</p>\n</li>\n<li><p>代码</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">void solve()&#123;\n    int n;\n    cin &gt;&gt; n;\n    multiset&lt;int&gt; s;\n    int vis[n + 1] = &#123;0&#125;;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        if(x &lt;= n &amp;&amp; !vis[x])&#123;\n            vis[x] = 1;\n            continue;\n        &#125;\n        s.insert(x);\n    &#125;\n    int cnt = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(vis[i])&#123;\n            continue;\n        &#125;\n        if(*s.begin() - *s.begin()/2 &gt; i)&#123;\n            s.erase(s.begin());\n            cnt++;\n        &#125;else&#123;\n            cout &lt;&lt; -1 &lt;&lt; endl;\n            return;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"CodeForces-1624C-Division-by-Two-and-Permutation\"><a href=\"#CodeForces-1624C-Division-by-Two-and-Permutation\" class=\"headerlink\" title=\"CodeForces|1624C. Division by Two and Permutation\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MjQvcHJvYmxlbS9D\">CodeForces|1624C. Division by Two and Permutation</span></h3><ul>\n<li>题意<ul>\n<li>有一个长度为 $n$ 的数组 $a$。你可以对其中的数进行以下操作：<ul>\n<li>不断除以 $2$ ，并向下取整。</li>\n</ul>\n</li>\n<li>问能否在若干次操作后，使得 $a$ 数组变成一个 $1 \\sim n$ 的全排列。</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>当这个数大于 $n$ 时，要进行上述操作。</li>\n<li>当全排列中出现了重复数字，该重复数字需要进行上述操作。</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">void solve()&#123;\n    int n;\n    memset(cnt, 0, sizeof(cnt));\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        while(x &gt; n || (x &lt;= n &amp;&amp; cnt[x] &amp;&amp; x / 2 &gt; 0)) x /= 2;\n        cnt[x]++;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!cnt[i])&#123;\n            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n            return ;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><h3 id=\"CodeForces-1613C-Poisoned-Dagger\"><a href=\"#CodeForces-1613C-Poisoned-Dagger\" class=\"headerlink\" title=\"CodeForces|1613C. Poisoned Dagger\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTMvcHJvYmxlbS9D\">CodeForces|1613C. Poisoned Dagger</span></h3><ul>\n<li><p>题意</p>\n<ul>\n<li>勇士在第 $a_1, a_2, … , a_n$ 秒使恶龙中毒，中毒属性至多持续 $k$ 秒，每秒将造成一点伤害。问 $k$ 至少是多少，才能造成 $h$ 点或以上的伤害？</li>\n</ul>\n</li>\n<li><p>题解</p>\n<ul>\n<li>可以二分答案寻找 $k$ 。</li>\n</ul>\n</li>\n<li><p>代码</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n// binary_search\nvoid solve()&#123;\n    LL n, h;\n    cin &gt;&gt; n &gt;&gt; h;\n    LL a[n + 1];\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; a[i];\n    &#125;\n    LL l = 1, r = h;\n    while(l &lt; r)&#123;\n        LL mid = (l + r) &gt;&gt; 1;\n        LL res = h - mid;\n        for(int i = 2; i &lt;= n; i++)&#123;\n            if(res &lt;= 0) break;\n            res -= min(a[i] - a[i - 1], mid);\n        &#125;\n        if(res &lt;= 0) r = mid;\n        else l = mid + 1;\n    &#125;\n    cout &lt;&lt; l &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        solve();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"CodeForces-1624D-Palindromes-Coloring\"><a href=\"#CodeForces-1624D-Palindromes-Coloring\" class=\"headerlink\" title=\"CodeForces|1624D. Palindromes Coloring\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MjQvcHJvYmxlbS9E\">CodeForces|1624D. Palindromes Coloring</span></h3><ul>\n<li>题意<ul>\n<li>给定一个长度为 $n$ 的字符串，可以给其中一些字符染色（可以不染），颜色种类不超过 $k$。然后将同种颜色的字符进行任意交换。</li>\n<li>定义一个颜色串为，所有染上此颜色的字符按照 <strong>原串顺序（可以为交换后）</strong> 组成的字符串。</li>\n<li>你要使得所有颜色串均为回文串，并且所有颜色串长度的最小值最大。求这个最大值。</li>\n<li>多组测试</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>由要求的 <strong>最小值最大</strong> 可知，该题可以使用二分，下证：</li>\n<li>假设现在颜色串长度的最小值为 $len$ ，那么所有长度 $&gt; len$ 的颜色串一定可以通过删除某些字符（相当于不染一些字符），变成一个长度为 $len$ 的回文串。</li>\n<li>也就是说，我们只需判断是否存在 $k$ 个长度为 $len$ 的回文颜色串即可。</li>\n<li>同理，如果颜色串长度为 $len$ 可以，那么 $len - 1$ 也可以。这就说明了 $len$ 具有单调性，故可以使用二分。</li>\n<li>又发现我们可以不限次数地交换同颜色字符。这说明我们可以将颜色串字符的顺序进行任意变换，得到我们想要的颜色串。</li>\n<li>所以，我们只需知道同颜色的字符有哪些，就可以快速判断它是否为回文串。统计出每个字符出现的次数，如果它是回文串，要么出现的次数均为偶数（颜色串长度为偶数），要么只有一个奇数（颜色串长度为奇数）。</li>\n<li>据此，我们可以使用一个桶记录下整个字符串中各个字符出现的次数。<ul>\n<li>若 $len$ 为偶数，我们就要为 $k$ 种不同颜色串提供 $\\frac{len}{2}$ 对相同字符，总共就是 $k \\times \\frac{len}{2}$ 对。直接判断 $\\sum_{i &#x3D; 1}^{26} \\left \\lfloor \\frac{cnt_i}{2} \\right \\rfloor $ 是否大于等于 $k \\times \\frac{len}{2}$ 即可。</li>\n<li>若 $len$ 为奇数，同理，先判断 $\\sum_{i &#x3D; 1}^{26} \\left \\lfloor \\frac{cnt_i}{2} \\right \\rfloor $ 是否大于等于 $k \\times \\left \\lfloor \\frac{len}{2} \\right \\rfloor$，因为长度为奇数的回文串还有中间一个落单的字符，所以还需判断剩下未使用的字符是否大于等于 $k$。</li>\n</ul>\n</li>\n<li>时间复杂度 $O(26n log n)$</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">bool check(LL x)&#123;\n    LL cnt[27];\n    memset(cnt, 0, sizeof(cnt));\n    for(int i = 1; i &lt;= n; i++)&#123; // 桶计数\n        cnt[str[i-1] - &#39;a&#39; + 1]++;\n    &#125;\n    LL tmp = x/2, tot = 0;  // tmp表示需要多少对相同字符\n    for(int i = 1; i &lt;= 26; i++)&#123;   // 计算最多有多少对相同字符\n        tot += cnt[i]/2;\n    &#125;\n    if(tot &lt; tmp * k) return 0; // 数量不够的话直接返回 false\n    if(x % 2 == 0) return 1;\n    tot = 0;\n    for(int i = 1; i &lt;= 26; i++)&#123;   // 长度为奇数时，计算总字符个数\n        tot += cnt[i];\n    &#125;\n    return tot &gt;= x * k;\n&#125;\n</code></pre>\n<h3 id=\"CodeForces-1610C-Keshi-Is-Throwing-a-Party\"><a href=\"#CodeForces-1610C-Keshi-Is-Throwing-a-Party\" class=\"headerlink\" title=\"CodeForces|1610C. Keshi Is Throwing a Party\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTAvcHJvYmxlbS9D\">CodeForces|1610C. Keshi Is Throwing a Party</span></h3><ul>\n<li>题意<ul>\n<li>有 $n$ 个人，第 $i$ 个人有 $i$ 元。现在要邀请若干个人参加聚会若<ul>\n<li>钱数大于 $i$ 的人的个数小于等于 $a_i$。</li>\n<li>钱数小于 $i$ 的人的个数小于等于 $b_i$。</li>\n</ul>\n</li>\n<li>则这个人会高兴，求 <strong>最多</strong> 邀请多少个人使得每个参加宴会的人都会高兴。</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>题意中出现了 <strong>最多</strong>，故考虑二分。</li>\n<li>假设存在邀请 $k$ 个人的方案，那么邀请 $k - 1, k - 2 … 1$ 个人都一定可以。反过来如果 $k$ 个人的方案不行，那么 $k + 1, k + 2 … n$ 个人的方案一定都不行。</li>\n<li>因此该题可以对 <em>能够邀请的人数</em> 进行二分。</li>\n<li>之后考虑贪心判断人数是否可行。</li>\n<li>现在的目标是根据已选的总人数判断我们可以选出的最多人数。</li>\n<li>对于第 $i$ 个人，如果 $b_i \\ge cnt$ 并且 $a_i \\le sum - cnt - 1$，此时如果邀请 $i$ ，他会很开心，所以我们一定会邀请他。因此扫一遍所有人，我们就得到了实际选择的人数，最后将其与 $sum$ 比较即可。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">bool check(int sum)&#123;\n    int cnt = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(b[i] &gt;= cnt &amp;&amp; a[i] &gt;= (sum - cnt - 1)) cnt++;\n    &#125;\n    return (cnt &gt;= sum);\n&#125;\nvoid solve()&#123;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];\n    int l = 1, r = n;\n    while(l &lt; r)&#123;\n        int mid = (l + r + 1) &gt;&gt; 1;\n        if(check(mid)) l = mid;\n        else r = mid - 1;\n    &#125;\n    cout &lt;&lt; l &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"CodeForces-1613D-MEX-Sequences\"><a href=\"#CodeForces-1613D-MEX-Sequences\" class=\"headerlink\" title=\"CodeForces|1613D. MEX Sequences\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MTMvcHJvYmxlbS9E\">CodeForces|1613D. MEX Sequences</span></h3><ul>\n<li><p>题意：求满足以下条件的子序列 $(a_1, … , a_n)$ 的数量。</p>\n<ul>\n<li>对任意的 $a_i$ ，有 $| a_i - MEX(a_1, a_2, … , a_i)| \\le  1$ 。</li>\n</ul>\n</li>\n<li><p>题解</p>\n<ul>\n<li>我们考虑子序列如何拓展。</li>\n<li>设 $1.$ 类子序列满足以下条件：最大值为 $x$ ，且包含了 $[0, x]$ 中的所有整数。则其下一个数可选 $x, x + 1, x + 2$ 。如果选前两个，则其仍然是 $1.$ 类子序列。如果选择 $x + 2$ ，则转化为另一类子序列。<ul>\n<li>空序列是 $1.$ 类子序列。</li>\n</ul>\n</li>\n<li>设 $2.$ 类子序列满足以下条件：最大值为 $x$ ，且包含了 $[0, x - 2]$ 的所有整数，却不包含 $x - 1$ 。则其下一个数可选 $x - 2$ 或 $x$ 。无论选择哪一个，其 $MEX$ 值均不改变。</li>\n<li>所以，所有满足条件的序列都可以分为这两类。</li>\n<li>设 <strong>$dp[x][0&#x2F;1]$</strong> 是最大值为 $x$ 的 $1. &#x2F; 2.$ 类子序列的数量，则可以进行状态转移。</li>\n</ul>\n</li>\n<li><p>代码</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int MOD = 998244353;\nvoid solve()&#123;\n    int n;\n    cin &gt;&gt; n;\n    LL dp[n + 4][2] = &#123;0&#125;;\n    dp[0][0] = 1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        x++;\n        dp[x][0] += dp[x][0] + dp[x - 1][0];\n        dp[x][1] += dp[x][1];\n        dp[x + 2][1] += dp[x + 2][1];\n        if(x &gt; 1) dp[x][1] += dp[x - 2][0];\n        dp[x][0] %= MOD; dp[x][1] %= MOD; dp[x + 2][1] %= MOD;\n    &#125;\n    LL ans = 0;\n    for(int i = 1; i &lt;= n + 1; i++)&#123;\n        ans += dp[i][0] + dp[i][1];\n        ans %= MOD;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        solve();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"CodeForces-1637D-Yet-Another-Minimization-Problem\"><a href=\"#CodeForces-1637D-Yet-Another-Minimization-Problem\" class=\"headerlink\" title=\"CodeForces|1637D. Yet Another Minimization Problem\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MzcvcHJvYmxlbS9E\">CodeForces|1637D. Yet Another Minimization Problem</span></h3><ul>\n<li>题意<ul>\n<li>给定等长的 $a, b$ 数组，你可以多次交换 $a, b$ ，请最小化 $\\sum_{i &#x3D; 1}^{n} \\sum_{j &#x3D; i + 1}^{n} (a_i + a_j)^2 + \\sum_{i &#x3D; 1}^{n} \\sum_{j &#x3D; i + 1}^{n} (b_i + b_j)^2$</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>这个等式可以转换成 $(a_1 + a_2 + … + a_n)^2 +(b_1 + b_2 + … + b_n)^2 + (n - 2)(a_1^{2} + a_2^{2} + … + a_n^{2}) + (n - 2)(b_1^{2} + b_2^{2} + … + b_n^{2})$</li>\n<li>因为该式子右边部分是固定的，所以只需要考虑左边。合理地交换 $a_i, b_i$ 使得左边部分最小即可。</li>\n<li>又因为本题数据很小，可以当成分组背包问题看，算出 $a_1 + a_2 + … + a_n$ 能取到的最小值即可。</li>\n<li>时间复杂度 $O(n(\\sum {a_i} + \\sum {b_i}))$</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">void solve()&#123;\n    int n;\n    cin &gt;&gt; n;\n    long long total = 0;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; a[i], total += a[i];\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        cin &gt;&gt; b[i], total += b[i];\n    &#125;\n    int dp[n + 1][total + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        for(int j = 0; j &lt;= total; j++)&#123;\n            if(j &gt;= a[i] &amp;&amp; dp[i - 1][j - a[i]]) dp[i][j] = 1;\n            if(j &gt;= b[i] &amp;&amp; dp[i - 1][j - b[i]]) dp[i][j] = 1;\n        &#125;\n    &#125;\n    long long ans = 1e17;\n    for(int i = 0; i &lt;= total; i++)&#123;    // 求 a的和 b的和的 平方的最小值\n        if(dp[n][i]) ans = min(ans, i * i + (total - i) * (total - i));\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        ans += (n - 2) * (a[i] * a[i] + b[i] * b[i]);\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"杂题\"><a href=\"#杂题\" class=\"headerlink\" title=\"杂题\"></a>杂题</h2><h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><h4 id=\"CodeForces-1638C-Inversion-Graph\"><a href=\"#CodeForces-1638C-Inversion-Graph\" class=\"headerlink\" title=\"CodeForces|1638C. Inversion Graph\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MzgvcHJvYmxlbS9D\">CodeForces|1638C. Inversion Graph</span></h4><ul>\n<li>题意<ul>\n<li>给定排序 $p$，对于逆序对 $(p_i, p_j)$，连接一条 $i\\longleftrightarrow j$ 的双向边。求整个图的连通块数量。</li>\n<li>多组测试。</li>\n</ul>\n</li>\n<li>题解<ul>\n<li>考虑单调栈，<strong>栈内的每一个元素代表一个独立的连通块（中的元素最大值）</strong>。</li>\n<li>维护方法如下<ul>\n<li>枚举 $i &#x3D; 1 \\sim n$ 入栈。</li>\n<li>如果 $a_i$ 小于栈内的某些元素 $t_1, t_2, … , t_x$ ，说明这些元素包括 $a_i$ 同属于一个连通块，故弹出这些元素，以该连通块中的一个最大元素代表这个连通块。</li>\n<li>如果当前 $a_i$ 大于栈内所有的元素，则认为其与前面的连通块之间没有任何直接连边，可认为其为当前状态下是一个最大元素为 $a_i$ 的新的连通块。</li>\n</ul>\n</li>\n<li>时间复杂度为 $O(n)$。</li>\n</ul>\n</li>\n<li>代码</li>\n</ul>\n<pre><code class=\"cpp\">void solve()&#123;\n    int n;\n    cin &gt;&gt; n;\n    stack&lt;int&gt; q;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        if(q.empty())&#123;\n            q.push(x);\n            continue;\n        &#125;\n        if(x &gt; q.top()) q.push(x);\n        else&#123;\n            auto t = q.top();\n            while(!q.empty() &amp;&amp; q.top() &gt; x) q.pop();\n            q.push(t);\n        &#125;\n    &#125;\n    cout &lt;&lt; q.size() &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h3><h4 id=\"CodeForces-1562B-Scenes-From-a-Memory\"><a href=\"#CodeForces-1562B-Scenes-From-a-Memory\" class=\"headerlink\" title=\"CodeForces|1562B. Scenes From a Memory\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE1NjIvcHJvYmxlbS9C\">CodeForces|1562B. Scenes From a Memory</span></h4><ul>\n<li><p>题意</p>\n<ul>\n<li>给定一个 $k$ 位数，要求对其删除若干位后使其是一个 <strong>非质数</strong> （等于 $1$ 或是一个合数），该数中不含 $0$。</li>\n<li>多组测试。保证有解。</li>\n</ul>\n</li>\n<li><p>题解</p>\n<ul>\n<li><strong>引理</strong> 对于一个三位数 $n$ ，你总可以找到一种方案，删掉至少 $1$ 位，使其剩下最多 $2$ 位且是一个 <strong>非质数</strong>。</li>\n<li><strong>证明</strong> 注意到可以分成以下几种情况考虑：<ol>\n<li>$n$ 中本身含有 $1, 4, 6, 8, 9$ 之一，只保留这一位即可。</li>\n<li>$n$ 中第 $i(i &gt; 1)$ 位是 $2, 5$ 之一，保留第 $1, i$ 位即可。</li>\n<li>$n$ 中有两个相同的数，只保留这两个相同的数即可。</li>\n<li>$n$ 中第 $1$ 位是 $2, 5$ 之一，第 $i(i &gt; 1)$ 位是 $7$，保留第 $1, i$ 位即可。</li>\n</ol>\n</li>\n<li>运用数学归纳法可以把该 <strong>引理</strong> 拓展至 $k$ 位数。</li>\n<li>同时，根据数据范围来看，只需要特判个位数，两位数只需要遍历一遍，判断是否为合数即可，故在此预处理 $100$ 以内的所有数。</li>\n</ul>\n</li>\n<li><p>代码</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 110;\nint primes[N], cnt;\nbool st[N];\nvoid get_primes(int n)\n&#123;\n    st[1] = true;\n    for (int i = 2; i &lt;= n; i++)&#123;\n        if (!st[i]) primes[cnt++] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j++)&#123;\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n         &#125;\n    &#125;\n&#125;\nvoid solve()&#123;\n    int n, ans = 0;\n    cin &gt;&gt; n;\n    string s, t;\n    cin &gt;&gt; s;\n    for(int i = 0; i &lt;= n - 1; i++)&#123;\n        int c = s[i] - &#39;0&#39;;\n        if(c == 1 || c == 4 || c == 6 || c == 8 || c == 9)&#123;\n            ans = c;\n            break;\n        &#125;\n    &#125;\n    if(ans)&#123;\n        cout &lt;&lt; 1 &lt;&lt; endl;\n        cout &lt;&lt; ans &lt;&lt; endl;\n        return ;\n    &#125;\n    for(int i = 0; i &lt;= n - 1; i++)&#123;\n        for(int j = i + 1; j &lt;= n - 1; j++)&#123;\n            t = s[i];\n            t += s[j];\n            if(st[stoi(t)])&#123;\n                ans = stoi(t);\n                cout &lt;&lt; 2 &lt;&lt; endl;\n                cout &lt;&lt; ans &lt;&lt; endl;\n                return ;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    get_primes(100);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        solve();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"CodeForces-1635D-Infinite-Set\"><a href=\"#CodeForces-1635D-Infinite-Set\" class=\"headerlink\" title=\"CodeForces|1635D. Infinite Set\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MzUvcHJvYmxlbS9E\">CodeForces|1635D. Infinite Set</span></h4><ul>\n<li><p>题意</p>\n</li>\n<li><p>题解</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzAwMDQzMjg=\">知乎|pzr</span></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9 + 7;\nvoid solve()&#123;\n    int n, p;\n    cin &gt;&gt; n &gt;&gt; p;\n    map&lt;LL, bool&gt; mp;\n    LL a[n + 1], fib[p + 1] = &#123;0&#125;, pre[p + 1] = &#123;0&#125;;\n    fib[0] = 1, fib[1] = 1;\n    pre[0] = 1, pre[1] = 2;\n    for(int i = 2; i &lt;= p; i++)&#123;\n        fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n        pre[i] = (pre[i - 1] + fib[i]) % mod;\n    &#125;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], mp[a[i]] = true;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x = a[i];\n        while(x)&#123;\n            if(x % 2 == 0 &amp;&amp; x % 4 != 0) break;\n            if(x % 4 == 0) x /= 4;\n            else x /= 2;\n            if(mp.find(x) != mp.end())&#123;\n                mp.erase(mp.find(a[i]));\n                break;\n            &#125;\n            // x 通过 *(2 + 1), *4 变化到 a[i] 等同于 a[i] 能通过 /2, /4 变化到 x\n        &#125;\n    &#125;\n    LL ans = 0;\n    for(auto [num, _] : mp)&#123;\n        int w = 64 - __builtin_clzll(num); // 返回前导 0 的个数\n        if(w &gt; p) continue;\n        ans = (ans + pre[p - w]) % mod;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n&#125;\n</code></pre>\n<h4 id=\"CodeForces-1602C-Array-Elimination\"><a href=\"#CodeForces-1602C-Array-Elimination\" class=\"headerlink\" title=\"CodeForces|1602C. Array Elimination\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2MDIvcHJvYmxlbS9D\">CodeForces|1602C. Array Elimination</span></h4><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NrX0hvbG1ld2VpL2FydGljbGUvZGV0YWlscy8xMjA5NjQ0NzY=\">题解</span></li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint gcd(int a, int b)&#123;\n    if(b == 0) return a;\n    return gcd(b, a % b);\n&#125;\nvoid solve()&#123;\n    int n;\n    cin &gt;&gt; n;\n    int _bits[32] = &#123;0&#125;;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        int x;\n        cin &gt;&gt; x;\n        for(int j = 0; j &lt; 31; j++)&#123;\n            _bits[j] += (1 &amp; (x &gt;&gt; j));\n        &#125;\n    &#125;\n    int k = _bits[0];\n    for(int j = 0; j &lt;= 31; j++) k = gcd(k, _bits[j]);\n    if(k == 0)&#123;\n        for(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    &#125;else&#123;\n        for(int i = 1; i &lt;= k; i++)&#123;\n            if(k % i == 0) cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n        &#125;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        solve();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"CodeForces-1656D-K-good\"><a href=\"#CodeForces-1656D-K-good\" class=\"headerlink\" title=\"CodeForces|1656D. K-good\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE2NTYvcHJvYmxlbS9E\">CodeForces|1656D. K-good</span></h4><ul>\n<li>题意<ul>\n<li>$n$ 能否分为 $k$ 个正整数的和，且这 $k$ 个正整数对 $k$ 的余数两两不同。</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>题意即 $n - k(k + 1) &#x2F; 2 \\equiv 0 \\quad (mod ; k)$ 且 $n - k(k + 1)&#x2F;2 \\ge 0$</li>\n<li>显然，若 $k$ 是偶数，则 $k &#x2F; 2$ 是 $n$ 的因子；若 $k$ 是奇数，则 $k$ 是 $n$ 的因子，所以我们需要对 $n$ 进行一定的因数分解。</li>\n<li>将 $n$ 分解成 $2^t \\times s$ 的形式（$s$ 是奇数）。现在取因子的方案大致分为：<ol>\n<li>取 $2^x$，看看 $k &#x3D; 2^{x + 1}$ 是否符合要求。容易证明只有取因子 $2^t ; (k &#x3D; 2^{t + 1})$ 才能满足同余的要求，若此时又有 $n - k(k + 1)&#x2F;2 \\ge 0$，输出即可。</li>\n<li>取 $s$ ，只要 $n - s(s + 1)&#x2F;2 \\ge 0$ 即可。当然，$k &#x3D; s &#x3D; 1$ 是无法满足要求的。</li>\n<li>其他方案不需要考虑</li>\n</ol>\n</li>\n<li>下证 <em>上 3</em><ul>\n<li>设 $q &#x3D; 2^t , n &#x3D; qs$，其中 $2q(2q + 1)&#x2F;2 &gt; n$ 和 $s(s + 1)&#x2F;2 &gt; n$ 不可能同时满足</li>\n<li>将 $n &#x3D; qs$ 代入即有 $2q + 1 &gt; s, s + 1 &gt; 2q$，即 $s - 1 &lt; 2q &lt; s + 1$，即 $2q &#x3D; s$，这与 $s$ 是奇数矛盾。</li>\n</ul>\n</li>\n<li>所以，以上过程中，$2^t$ 和 $s \\ne 1$ 至少有一个满足条件。特殊的是，若 $s &#x3D; 1$，显然我们只能取 $2$ 的幂次，按以上讨论不能满足题意，应输出 <code>-1</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nvoid solve()&#123;\n    LL n; cin &gt;&gt; n;\n    LL s = n, q = 1;\n    while(s % 2 == 0)&#123;\n        s /= 2;\n        q *= 2;\n    &#125;\n    \n    if(q &lt;= 1e9 &amp;&amp; q * (2 * q + 1) &lt;= n)&#123;\n        cout &lt;&lt; 2 * q &lt;&lt; endl;\n        return ;\n    &#125;\n    if(s != 1 &amp;&amp; s &lt;= 2e9 &amp;&amp; s * (s + 1) / 2 &lt;= n)&#123;\n        cout &lt;&lt; s &lt;&lt; endl;\n        return ;\n    &#125;\n    cout &lt;&lt; -1 &lt;&lt; endl;\n&#125;\nint main()&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t; cin &gt;&gt; t;\n    while(t--) solve();\n&#125;\n</code></pre>\n<h4 id=\"CodeForces-1436C-Binary-Search\"><a href=\"#CodeForces-1436C-Binary-Search\" class=\"headerlink\" title=\"CodeForces|1436C. Binary Search\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0MzYvcHJvYmxlbS9D\">CodeForces|1436C. Binary Search</span></h4><ul>\n<li>题意<ul>\n<li>给定三个正整数 $n, x, pos$，请你求出满足以下条件的数组 $a$ 的个数<ul>\n<li>数组 $a$ 是正整数 $1 \\sim n$ 的一种排列，且 $a_{pos} &#x3D; x$ （下标从 $0$ 开始）</li>\n<li>对于数组 $a$ 运行如上代码，其返回值为 <code>true</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>分析<ul>\n<li>首先想一下二分查找的过程，如果我们知道了 $x$ 的位置 $pos$，实际上就能确定出来需要找几次了，因为二分查找的前提是满足序列单调性，虽然排列不是单调的，但这个排列的下标是单调的（即 $1, 2, 3, 4, \\cdots, n$），不管是按什么二分，折返点的位置是固定的，因此我们直接对下标 $pos$ 二分查找，在这个过程中记录比 $pos$ 大的下标的个数以及比 $pos$ 小的下标的个数，这实际上也就是在最终要构造出来的序列中二分转折点上比 $x$ 大的数的个数以及比 $x$ 小的数的个数。个数确定后就是排列组合问题了，对于这两部分先选再排，剩下的数求全排列，把这些乘起来即可。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e4 + 10;\nconst int mod = 1e9 + 7;\nLL fact[N], infact[N];\nint qmi(int a, int k, int p)&#123;    // 快速幂模板\n    int res = 1;\n    while (k)&#123;\n        if (k &amp; 1) res = (LL)res * a % p;\n        a = (LL)a * a % p;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nLL C(LL n, LL m)&#123;\n    return (fact[n] * infact[m] % mod * infact[n - m] % mod);\n&#125;\nLL A(LL n, LL m)&#123;\n    LL ans = 1;\n    for(LL i = n; i &gt;= n - m + 1; i--)&#123;\n        ans = (ans * i) % mod;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    int n, x, pos;\n    cin &gt;&gt; n &gt;&gt; x &gt;&gt; pos;\n    int l = 0, r = n;\n    LL smaller = 0, bigger = 0;\n    while(l &lt; r)&#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if(mid &gt; pos)&#123;\n            r = mid;\n            bigger++;\n        &#125;else&#123;\n            l = mid + 1;\n            if(mid &lt; pos) smaller++;\n        &#125;\n    &#125;\n    // 预处理阶乘的余数和阶乘逆元的余数\n    fact[0] = infact[0] = 1;\n    for (int i = 1; i &lt; N; i++)&#123;\n        fact[i] = (LL)fact[i - 1] * i % mod;\n        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;\n    &#125;\n    LL ans = C(n - x, bigger) * A(bigger, bigger) % mod * C(x - 1, smaller) % mod * A(smaller, smaller) % mod * A(1LL * n - smaller - bigger - 1, 1LL * n - smaller - bigger - 1) % mod;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法",
                "数据结构",
                "CodeForces",
                "AtCoder",
                "题解",
                "题单"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html",
            "url": "https://asterzc19.github.io/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html",
            "title": "基础算法模板",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7 - 10^8$ 为最佳。</p>\n<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>\n<ol>\n<li>$n≤30$, 指数级别, dfs+剪枝，状态压缩 dp</li>\n<li>$n≤100  &#x3D;&gt; O (n3)$，floyd，dp，高斯消元</li>\n<li>$n≤1000  &#x3D;&gt; O (n^2)，O (n^2logn)$，dp，二分，朴素版 Dijkstra、朴素版 Prim、Bellman-Ford</li>\n<li>$n≤10000  &#x3D;&gt; O (n∗\\sqrt n)$，块状链表、分块、莫队</li>\n<li>$n≤100000  &#x3D;&gt; O (nlogn)$ &#x3D;&gt; 各种 sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ 分治、整体二分、后缀数组、树链剖分、动态树</li>\n<li>$n≤1000000  &#x3D;&gt; O (n)$, 以及常数较小的 $O (nlogn)$ 算法 &#x3D;&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC 自动机，常数比较小的$ O (nlogn) O (nlogn) $的做法：sort、树状数组、heap、dijkstra、spfa</li>\n<li>$n≤10000000  &#x3D;&gt; O (n)$，双指针扫描、kmp、AC 自动机、线性筛素数</li>\n<li>$n≤10^9 &#x3D;&gt; O (\\sqrt n) O (n)$，判断质数</li>\n<li>$n≤10^{18}  &#x3D;&gt; O (logn)$，最大公约数，快速幂，数位 DP</li>\n<li>$n≤10^{1000}  &#x3D;&gt; O ((logn) 2)$，高精度加减乘除</li>\n<li>$n≤10^{100000} &#x3D;&gt; O (logk×loglogk)$，k 表示位数, 高精度加减、FFT&#x2F;NTT</li>\n</ol>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><pre><code class=\"cpp\">int q[1000010];\nvoid quick_sort(int l, int r)&#123;\n    if(l &gt;= r) return;\n    int i = l-1, j = r+1, x = q[l+r &gt;&gt; 1];\n    while(i &lt; j)&#123;\n        do i++; while(q[i] &lt; x);\n        do j--; while(q[j] &gt; x);\n        if(i &lt; j)&#123;\n            swap(q[i], q[j]);\n        &#125;\n    &#125;\n    quick_sort(l, j);\n    quick_sort(j+1, r);\n&#125;\n</code></pre>\n<h3 id=\"快速选择（快排）\"><a href=\"#快速选择（快排）\" class=\"headerlink\" title=\"快速选择（快排）\"></a>快速选择（快排）</h3><pre><code class=\"cpp\">// k 为第 k 小的数\nint q[1000010];\nint quick_sort(int l, int r, int k)&#123;\n    if(l == r) return q[l];\n    int i = l-1, j = r+1, x = q[l+r &gt;&gt; 1];\n    while(i &lt; j)&#123;\n        while(q[++i] &lt; x);\n        while(q[--j] &gt; x);\n        if(i &lt; j)&#123;\n            swap(q[i], q[j]);\n        &#125;\n    &#125;\n    int sl = j - l + 1; //sl 为左半边元素的个数\n    if(k &lt;= sl) return quick_sort(l, j, k);\n    return quick_sort(j+1, r, k - sl);\n&#125;\n</code></pre>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><pre><code class=\"cpp\">int q[1000010], temp[1000010];\nvoid merge_sort(int l, int r)&#123;\n    if(l &gt;= r) return;\n    int mid = l+r &gt;&gt; 1;\n    merge_sort(l, mid);\n    merge_sort(mid+1, r);\n    \n    int k = 0, i = l, j = mid+1;\n    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;\n        if(q[i] &lt;= q[j])&#123;\n            temp[k++] = q[i++];\n        &#125;else&#123;\n            temp[k++] = q[j++];\n        &#125;\n    &#125;\n    while(i &lt;= mid) temp[k++] = q[i++];\n    while(j &lt;= r) temp[k++] = q[j++];\n    \n    for(int i = l, j = 0; i &lt;= r; i++, j++)&#123;\n        q[i] = temp[j];\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"逆序对数量\"><a href=\"#逆序对数量\" class=\"headerlink\" title=\"逆序对数量\"></a>逆序对数量</h3><pre><code class=\"cpp\">typedef long long LL;\nint q[N], tmp[N];\nLL merge_sort(int l, int r)\n&#123;\n    if(l &gt;= r) return 0;\n    int mid = l + r &gt;&gt; 1;\n    LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);\n    int k = 0, i = l, j = mid + 1;\n    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;\n        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];\n        else &#123;\n            temp[k++] = q[j++];\n            res += mid - i + 1;\n        &#125;\n    &#125;\n    while(i &lt;= mid) tmp[k++] = q[i++];\n    while(j &lt;= r) tmp[k++] = q[j++];\n    for(int i = l, j = 0; i &lt;= r; i++, j++) q[i] = temp[j];\n    \n    return res;\n&#125;\n</code></pre>\n<h3 id=\"整数二分\"><a href=\"#整数二分\" class=\"headerlink\" title=\"整数二分\"></a>整数二分</h3><pre><code class=\"cpp\">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    &#125;\n    return l;\n&#125;\n</code></pre>\n<h3 id=\"浮点数二分\"><a href=\"#浮点数二分\" class=\"headerlink\" title=\"浮点数二分\"></a>浮点数二分</h3><pre><code class=\"cpp\">bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps = 1e-6;   \n    // eps 表示精度，取决于题目对精度的要求 一般取规定小数位+2\n    while (r - l &gt; eps)\n    &#123;\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    &#125;\n    return l;\n&#125;\n</code></pre>\n<h3 id=\"高精度加法\"><a href=\"#高精度加法\" class=\"headerlink\" title=\"高精度加法\"></a>高精度加法</h3><pre><code class=\"cpp\">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n    //也可以先做大小处理，也可以不做处理直接在下方循环中做判断。\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0 ; i &lt; A.size(); i++)&#123;\n        t += A[i];\n        if (i &lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    &#125;\n    if (t) C.push_back(1);\n    return C;\n&#125;\n</code></pre>\n<h3 id=\"高精度减法\"><a href=\"#高精度减法\" class=\"headerlink\" title=\"高精度减法\"></a>高精度减法</h3><pre><code class=\"cpp\">//要求A &gt;= B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0, t = 0; i &lt; A.size(); i++)&#123;\n        t = A[i] - t;\n        if (i &lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t = 1;\n        else t = 0;\n    &#125;\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n</code></pre>\n<h3 id=\"高精度乘低精度\"><a href=\"#高精度乘低精度\" class=\"headerlink\" title=\"高精度乘低精度\"></a>高精度乘低精度</h3><pre><code class=\"cpp\">// C = A * b, A &gt;= 0, b &gt;= 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size() || t; i++)&#123;\n        if(i &lt; A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    &#125;\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n</code></pre>\n<h3 id=\"高精度除以低精度\"><a href=\"#高精度除以低精度\" class=\"headerlink\" title=\"高精度除以低精度\"></a>高精度除以低精度</h3><pre><code class=\"cpp\">// A / b = C ... r, A &gt;= 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i--)&#123;\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n</code></pre>\n<h3 id=\"一维前缀和\"><a href=\"#一维前缀和\" class=\"headerlink\" title=\"一维前缀和\"></a>一维前缀和</h3><pre><code class=\"cpp\">S[i] = a[1] + a[2] + ... + a[i]\na[l] + ... + a[r] = S[r] - S[l - 1]\n</code></pre>\n<h3 id=\"二维前缀和\"><a href=\"#二维前缀和\" class=\"headerlink\" title=\"二维前缀和\"></a>二维前缀和</h3><pre><code class=\"cpp\">S[i, j] = 第i行j列格子左上部分所有元素的和\nS[i, j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j]\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 -1]\n</code></pre>\n<h3 id=\"一维差分\"><a href=\"#一维差分\" class=\"headerlink\" title=\"一维差分\"></a>一维差分</h3><ul>\n<li>考虑构造<ul>\n<li>b 为差分数组，a 为原数组（即 b 的前缀和）</li>\n<li>a 初始全为 0，可构造 b 全为 0</li>\n<li>初始化 a 后，可以看作是在 $[i, i]$ 区间中加上 $a[i]$, 从而构造出 b 数组</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">给区间[l, r]中的每个数加上c: B[l] += c, B[r + 1] -= c\n</code></pre>\n<h3 id=\"二维差分\"><a href=\"#二维差分\" class=\"headerlink\" title=\"二维差分\"></a>二维差分</h3><pre><code class=\"cpp\">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nB[x1, y1] += c\nB[x2 + 1, y1] -= c\nB[x1][y2 + 1] -= c\nB[x2 + 1][y2 + 1] += c\n</code></pre>\n<h3 id=\"双指针算法\"><a href=\"#双指针算法\" class=\"headerlink\" title=\"双指针算法\"></a>双指针算法</h3><pre><code class=\"cpp\">//最长连续不重复子序列\nfor (int i = 0, j = 0; i &lt; n; i++)&#123;\n    while(j &lt; i &amp;&amp; check(i, j)) j++;\n    //具体问题的逻辑\n&#125;\n</code></pre>\n<ul>\n<li>常见问题分类：<ul>\n<li>对于一个序列，用两个指针维护一段区间</li>\n<li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作。</li>\n</ul>\n</li>\n<li>要点<ul>\n<li>先用朴素方法，在思考 i 和 j 有没有单调关系，有单调关系即可优化至 O (n)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h3><pre><code class=\"cpp\">求n的第k位数字：n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) = n &amp; -n (等同于 n &amp; (~n + 1))\n~n n取反 因为以补码存储\n</code></pre>\n<h3 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h3><pre><code class=\"cpp\">vector&lt;int&gt; alls; //存储所有待离散化的值\nsort(alls.begin(), alls.end()); //将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end()); //去掉重复元素\n//二分求出x对应的离散化的值\nint find(int x) //找到第一个大于等于x的位置\n&#123;\n    int l = 0, r = alls.size() - 1;\n    while(l &lt; r)&#123;\n        int mid = l+r &gt;&gt; 1;\n        if(alls[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return r + 1; //映射到1,2,...n\n&#125;\n</code></pre>\n<h3 id=\"区间合并\"><a href=\"#区间合并\" class=\"headerlink\" title=\"区间合并\"></a>区间合并</h3><pre><code class=\"cpp\">// 将所有存在交集的区间合并\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n    sort(segs.begin(), segs.end());\n    int st = -2e9, ed = -2e9;\n    for(auto seg : segs)&#123;\n        if(ed &lt; seg.first)&#123;\n            if(st != -2e9) res.push_back(&#123;st, ed&#125;);\n            st = seg.first, ed = seg.second;\n        &#125;else&#123;\n            ed = max(ed, seg.second);\n        &#125;\n    &#125;\n    if(st != -2e9) res.push_back(&#123;st, ed&#125;);\n    segs = res;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法",
                "模板"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html",
            "url": "https://asterzc19.github.io/post/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.html",
            "title": "搜索与图论模板",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<h3 id=\"树与图的存储\"><a href=\"#树与图的存储\" class=\"headerlink\" title=\"树与图的存储\"></a>树与图的存储</h3><ul>\n<li>树是一种特殊的图，与图的存储方式相同。</li>\n<li>对于无向图中的边 ab，存储两条有向边 a-&gt;b, b-&gt;a。</li>\n<li>因此我们可以只考虑有向图的存储。<ul>\n<li>（1）邻接矩阵：<code>g[a][b]</code> 存储边 a-&gt;b。</li>\n<li>（2）邻接表：</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"cpp\">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n// 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n&#125;\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n</code></pre>\n<h3 id=\"树与图的遍历\"><a href=\"#树与图的遍历\" class=\"headerlink\" title=\"树与图的遍历\"></a>树与图的遍历</h3><p>时间复杂度 $O (n+m)$, n 表示点数，m 表示边数<br>（1）深度优先遍历</p>\n<pre><code class=\"cpp\">int dfs(int u)\n&#123;\n    st[u] = true;// st[u] 表示点u已经被遍历过\n    for (int i = h[u]; i != -1; i = ne[i])&#123;\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;\n</code></pre>\n<p>（2）宽度优先遍历</p>\n<pre><code class=\"cpp\">queue&lt;int&gt; q;\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())&#123;\n    int t = q.front();\n    q.pop();\n    \n    for (int i = h[t]; i != -1; i = ne[i])&#123;\n        int j = e[i];\n        if (!st[j])&#123;\n            st[j] = true;\n            q.push(j); // 表示点j已经被遍历过\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><ul>\n<li>时间复杂度 $O(n+m)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">bool topsort()\n&#123;\n    int hh = 0, tt = -1;\n    // d[i] 存储i的入度\n    for (int i = 1; i &lt;= n; i++)&#123;\n        if (!d[i]) q[++tt] = i;\n    &#125;\n    while (hh &lt;= tt)&#123;\n        int t = q[hh++];\n        for (int i = h[t]; i != -1; i = ne[i])&#123;\n            int j = e[j];\n            if (--d[j] == 0) q[++tt] = j;\n        &#125;\n    &#125;\n    // 如果所有点都入队了，说明存在拓扑排序；否则不存在。\n    return tt == n-1;\n&#125;\n</code></pre>\n<h3 id=\"朴素-dijkstra-算法\"><a href=\"#朴素-dijkstra-算法\" class=\"headerlink\" title=\"朴素 dijkstra 算法\"></a>朴素 dijkstra 算法</h3><ul>\n<li>时间复杂度是 $O (n^2 + m)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int g[N][N]; // 存储每条边\nint dist[N]; // 存储1号点到每个点的最短距离\nbool st[N]; // 存储每个点的最短路是否已经确定\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    for (int i = 0; i &lt; n - 1; i++)&#123;\n        int t = -1; // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j &lt;= n; j++)&#123;\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))&#123;\n                t = j;\n            &#125;\n        &#125;\n        // 用t更新其他点的距离\n        for (int j = 1; j &lt;= n; j++)&#123;\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        &#125;\n        st[t] = true;\n    &#125;\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n</code></pre>\n<h3 id=\"堆优化版dijkstra\"><a href=\"#堆优化版dijkstra\" class=\"headerlink\" title=\"堆优化版dijkstra\"></a>堆优化版dijkstra</h3><ul>\n<li>时间复杂度 $O (mlogn)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">typedef pair&lt;int, int&gt; PII;\nint n;  // 点的数量\nint h[N], w[N], e[N], ne[N], idx;  // 邻接表存储所有边\nint dist[N];   // 存储所有点到1号点的距离\nbool st[N];   // 存储每个点的最短距离是否已确定\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; heap;\n    heap.push(&#123;0, 1&#125;);   // first存储距离，second存储节点编号\n    while (heap.size())&#123;\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver]) continue;\n        st[ver] = true;\n        \n        for (int i = h[ver]; i != -1; i = ne[i])&#123;\n            int j = e[i];\n            if (dist[j] &gt; distance + w[i])&#123;\n                dist[j] = distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n</code></pre>\n<h3 id=\"Bellman-Ford-算法\"><a href=\"#Bellman-Ford-算法\" class=\"headerlink\" title=\"Bellman-Ford 算法\"></a>Bellman-Ford 算法</h3><p>时间复杂度 $O(nm)$, n 表示点数，m 表示边数<br>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p>\n<pre><code class=\"cpp\">int n, m;   // n表示点数， m表示边数\nint dist[N];   // dist[x]存储1到x的最短路距离\nstruct Edge   // 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    /* 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径\n    由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。*/\n    for (int i = 0; i &lt; n; i++)&#123;\n        for (int j = 0; j &lt; m; j++)&#123;\n            int a = edges[j].a, b = edges[j].b, w = edges[j.w];\n            if (dist[b] &gt; dist[a] + w)&#123;\n                dist[b] = dist[a] + w;\n            &#125;\n        &#125;\n    &#125;\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n&#125;\n</code></pre>\n<h3 id=\"spfa-算法（队列优化的-Bellman-Ford-算法）\"><a href=\"#spfa-算法（队列优化的-Bellman-Ford-算法）\" class=\"headerlink\" title=\"spfa 算法（队列优化的 Bellman-Ford 算法）\"></a>spfa 算法（队列优化的 Bellman-Ford 算法）</h3><ul>\n<li>时间复杂度平均情况下 $O (m)$，最坏情况下 $O (nm)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int n;\nint h[N], w[N], e[N], ne[N], idx;\nint dist[N];\nbool st[N];\n\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    \n    while (q.size())&#123;\n        auto t = q.front();\n        q.pop();\n        st[t] = false;\n        \n        for (int i = h[t]; i != -1; i = ne[i])&#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])&#123;\n                dist[j] = dist[t] + w[i];\n                if (!st[j])&#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n</code></pre>\n<h3 id=\"spfa-判断图中是否存在负环\"><a href=\"#spfa-判断图中是否存在负环\" class=\"headerlink\" title=\"spfa 判断图中是否存在负环\"></a>spfa 判断图中是否存在负环</h3><ul>\n<li>时间复杂度是 $O (nm)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int n;   // 总点数\nint h[N], w[N], e[N], ne[N], idx;   // 邻接表存储所有边\nint dist[N], cnt[N];   \n// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];   // 存储每个点是否在队列中\n// 如果存在负环，则返回true，否则返回false\nbool spfa()\n&#123;\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点\n    // 由抽屉原理一定有两个点相同，所以存在环。\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; i++)&#123;\n        q.push(i);\n        st[i] = true;\n    &#125;\n    while (q.size())&#123;\n        auto t = q.front();\n        q.pop();\n        st[t] = false;\n        \n        for (int i = h[t]; i != -1; i = ne[i])&#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])&#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] &gt;= n) return true;\n    // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])&#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h3 id=\"floyd-算法\"><a href=\"#floyd-算法\" class=\"headerlink\" title=\"floyd 算法\"></a>floyd 算法</h3><ul>\n<li>时间复杂度是 $O (n^3)$，n 表示点数</li>\n</ul>\n<pre><code class=\"cpp\">初始化：\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = 1; j &lt;= n; j++)\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k = 1; k &lt;= n; k++)\n        for (int i = 1; i &lt;= n; i++)\n            for (int j = 1; j &lt;= n; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n</code></pre>\n<h3 id=\"朴素版-prim-算法\"><a href=\"#朴素版-prim-算法\" class=\"headerlink\" title=\"朴素版 prim 算法\"></a>朴素版 prim 算法</h3><ul>\n<li>时间复杂度是 $O(n^2+m)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int n;    // n表示点数\nint g[N][N];    // 邻接矩阵，存储所有边\nint dist[N];    // 存储其他点到当前最小生成树的距离\nbool st[N];    // 存储每个点是否已经在生成树中\n// 如果图不连通，则返回INF（值是0x3f3f3f3f），否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    int res = 0;\n    for (int i = 0; i &lt; n; i++)&#123;\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)&#123;\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))&#123;\n                t = j;\n            &#125;\n        &#125;\n        if (i &amp;&amp; dist[t] == INF) return INF;\n        if (i) res += dist[t];\n        st[t] = true;\n        for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]);\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"Kruskal-算法\"><a href=\"#Kruskal-算法\" class=\"headerlink\" title=\"Kruskal 算法\"></a>Kruskal 算法</h3><ul>\n<li>时间复杂度是 $O(mlogm)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int n, m;    // n是点数，m是边数\nint p[N];    // 并查集的父节点数组\nstruct Edge    // 存储边\n&#123;\n    int a, b, w;\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\nint find(int x)    // 并查集核心操作\n&#123;\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n    for (int i = 1; i &lt;= n; i++) p[i] = i;    // 初始化并查集\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i++)&#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n        a = find(a), b = find(b);\n        if (a != b)&#123;    // 如果两个连通块不连通，则将这两个连通块合并\n            p[a] = b;\n            res += w;\n            cnt++;\n        &#125;\n    &#125;\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"染色法判别二分图\"><a href=\"#染色法判别二分图\" class=\"headerlink\" title=\"染色法判别二分图\"></a>染色法判别二分图</h3><ul>\n<li>时间复杂度是 $O(n+m)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int n;    // n表示点数\nint h[N], e[M], ne[M], idx;   // 邻接表存储图\nint color[N];   // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n// 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i])&#123;\n        int j = e[i];\n        if (color[j] == -1)&#123;\n            if (!dfs(j, !c)) return false;\n        &#125;else&#123;\n            if (color[j] == c) return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\nbool check()\n&#123;\n    memset(color, -1, sizeof(color));\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i++)\n        if (color[i] == -1)\n            if (!dfs(i, 0))&#123;\n                flag = true;\n                break;\n            &#125;\n    return flag;\n&#125;\n</code></pre>\n<h3 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h3><ul>\n<li>时间复杂度是 $O(nm)$，n 表示点数，m 表示边数</li>\n</ul>\n<pre><code class=\"cpp\">int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N]; // 表示第二个集合中的每个点是否已经被遍历过\nbool find(int x)\n&#123;\n    for (int i = h[x]; i != -1; i = ne[i])&#123;\n        int j = e[i];\n        if (!st[j])&#123;\n            st[j] = true;\n            if (match[j] == 0 || find(match[j]))&#123;\n                match[j] = x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res = 0;\nfor (int i = 1; i &lt;= n1; i++)&#123;\n    memset(st, false, sizeof(st));\n    if (find(i)) res++;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法",
                "数据结构",
                "模板"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html",
            "url": "https://asterzc19.github.io/post/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8A%A5%E5%91%8A.html",
            "title": "注意力使用不完全报告",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<h2 id=\"注意力是什么\"><a href=\"#注意力是什么\" class=\"headerlink\" title=\"注意力是什么\"></a>注意力是什么</h2><blockquote>\n<p>所谓「注意」，是意识以清晰而迅速的形式，在多种可能性中选取一个物体或一系列想法的过程。定焦、集中和意识是注意的关键因素。</p>\n</blockquote>\n<p>在讨论注意力这个话题时，我也会用「聚焦」这个概念来形容保持专注时的感受——我们一直想要的专注力，其实就是将焦点对准任务目标（譬如工作、作业或者某件事物）并保持的过程。</p>\n<ul>\n<li>这个概念还能带来一些延展讯息：<ol>\n<li>大脑需要一个明确的目标，才能调动注意力。这个目标可能是某个具体事务，也可能是关于某主题的一连串想法。</li>\n<li>注意力就是大脑将意识集中在某个目标上的结果。在注意力高度集中时，你会有清晰的意识和自我意识。</li>\n<li>一旦切换焦点，注意力也会随之迁移。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"注意力的三种形式\"><a href=\"#注意力的三种形式\" class=\"headerlink\" title=\"注意力的三种形式\"></a>注意力的三种形式</h2><ul>\n<li>选择性注意</li>\n<li>执行性注意</li>\n<li>警惕性注意</li>\n</ul>\n<hr>\n<p><strong>选择性注意是指我们将意识的焦点主动保持在某些事物上的状态，我们通常所说的注意力指的就是选择性注意。</strong> 譬如你同时在电脑上打开了浏览器、To-do、微信等多个窗口，无论实际打开的窗口有多少，你的注意力总会主要集中在你当前正在使用的那个窗口中。</p>\n<p><strong>执行性注意则更强调你在专注度极高时刻意调动注意力来处理复杂任务的能力。</strong> </p>\n<p> <strong>警惕型注意则强调执行某些特殊活动时对某些特别的事物或元素保持高度警惕。</strong> 譬如你在走路时不会特别注意马路上画的线、周围的路人、路口的红绿灯等，但当你开车的时候，就会格外留意这些东西。即使旁边有人跟你讲话，一旦出现交通状况，你都会突然进入紧急状态，及时调整车辆。</p>\n<h2 id=\"注意力的特点\"><a href=\"#注意力的特点\" class=\"headerlink\" title=\"注意力的特点\"></a>注意力的特点</h2><p> 正如「注意力的类型」一节所言，选择性注意是注意力的基础。事实上，也只有我们<strong>刻意选择一个目标</strong>，并将注意力汇集在它身上时，注意力才能被称为「注意力」。</p>\n<p> 人的注意力就像一个相机的镜头——当我们要拍摄一张照片时，需要找到焦点并对焦。焦内的图像都是清晰锐利的；焦外的画面虽然也都存在于照片中，但都模糊不清<br> 。</p>\n<p> <strong>无论使用任何关于保持专注力的技巧或工具，都一定不要忽略「人脑无法进行多任务处理（或者我们理想中的多任务处理）」这个前提。</strong> 在这个前提下，每天或每个重要时段只能安排一件核心任务。相对短期或零碎的任务则需要放在其它时段，或者找时间集中处理，这样才能让任务安排与大脑特性相匹配。</p>\n<ul>\n<li>有研究指出，大脑在同一时间所能主动进行的运算只有大约 40 bit 的信息，而能够主动记忆的空间则是可怜的 4 bit。所以，大部分人连记住一个 7 位数的电话号码都需要重复记忆很多次。在实际生活中，这一特点体现在——我们更容记住 4 以下的信息块，尤其对 3 非常敏感。在谈话中，我们喜欢将演讲的主题归为 3 点；如果需要记住一串数字，我们也更习惯将其拆分为 3 个一组，逐组记忆。</li>\n<li>在实际工作中，要避免让大脑同时面对多个任务，以免造成注意力过载。即使是「回复同事微信」、「修改文稿错别字」、「下载 app 更新」这样的小事，如果都放在同一时间来做，仍然会让你手忙脚乱。</li>\n</ul>\n<h2 id=\"认识注意力\"><a href=\"#认识注意力\" class=\"headerlink\" title=\"认识注意力\"></a>认识注意力</h2><h4 id=\"跑神可以带来专注\"><a href=\"#跑神可以带来专注\" class=\"headerlink\" title=\"跑神可以带来专注\"></a>跑神可以带来专注</h4><p>在大众对于专注力的想象中，总觉得保持注意力的高度投入才是专注力高的表现。但事实上，人的专注程度无法持续长期保持在一条稳定的水平线上，而会不断波动。</p>\n<p>每隔一段时间，人脑就会从完全专注的状态中脱离出来，典型的表现就是跑神。譬如你正在奋笔疾书一篇长文，写到某个点时需要停下来思考，但当你回过神时，才发现自己盯着萤幕上的光标愣了好久。</p>\n<p>别担心，跑神不可怕，相反，从长期来看，跑神可以提升你的整体专注度。在你意识到自己跑神的时候，可以<strong>主动提醒自己</strong>回到任务中来。你的大脑可以得到短暂的放松，然后重新进入高度专注模式。</p>\n<p>低频率的跑神还能唤醒你对于当前工作的新鲜感，让你找到「重新上路」的感觉。这种感觉可以有效地降低长时间工作带来的大脑疲劳，避免延误工作的情绪产生。</p>\n<p>我将这个过程称为「注意力修正」，有许多提升专注力的技巧与工具都用到了注意力修正的理论，其中最知名的就是番茄工作法。番茄工作法提倡你每专注工作 25 分钟就休息 5 分钟，这个过程其实就是借助外力来诱导大脑形成专注力波动，以更规律的节奏来保持注意力集中。</p>\n<p>如果你愿意的话，其实可以定制一个更适合你的注意力特质的个人番茄计划，实现方式是测试和了解自己专注力的极限。具体操作流程为：</p>\n<ul>\n<li>选择一个完全不被打扰的完整时段</li>\n<li>选择一件需要你专注完成的事，譬如读书、写作或准备下周的工作</li>\n<li>根据你对自己的了解，预估一下自己执行这件事所能保持专注的最长时间，记录下来</li>\n<li>开启一个计时器，开始执行任务。不要让自己看到计时器上的时间</li>\n<li>任务进行中，如果出现了分心、跑神等状况，提醒自己回到任务上来，继续保持专注</li>\n<li>持续进行任务，直到自己觉得「我实在坚持不下去了」，或者跑神之后无法回到之前的专注状态为止</li>\n<li>记录你坚持下来的时间，对比一下自己的预估</li>\n<li>目前的测试结果就是你衡量自己专注力极限的标准。如果你想让结果更准确，可以多测试几次，或者每次测试时进行不同类型的任务，以更细致地了解自己的大脑在进行不同工作时的专注程度</li>\n</ul>\n<p>有了上面的测试结果，你就可以更有针对性地制定个人的番茄循环了。需要注意的是，你的最长专注时间有可能长达数小时，这并不意味着你要设定一个每次几小时的番茄循环，只需要每个循环能被最长专注时间整除即可。例如你的专注时长是 90 分钟，那你的专注循环周期可以设定为每 30 分钟或 45 分钟一次（也可以针对不同任务使用不同长度的周期），每个循环内休息 5 分钟，每达到 90 分钟则进行一次长时间的休息（或者换一项任务来做）。</p>\n<h4 id=\"专注与体能\"><a href=\"#专注与体能\" class=\"headerlink\" title=\"专注与体能\"></a>专注与体能</h4><p>在关于注意力的讨论中，最容易被人们忽视的一点就是注意力和体力之间的关系。在调动专注力进行工作和思考的同时，身体——特别是大脑——会加速消耗能量，这也是你的专注度无法 24 小时都保持在高水平的重要原因。</p>\n<p>实际生活中，需要注意的重点是：人体缺少能量供应时的表现不一定是饥饿。换言之，也许你并未感觉到饿，但其实身体供给大脑的能量已经不足了。此时，你会发现自己调动注意力会变得格外困难，却找不到相关联的原因。</p>\n<p>不仅如此，<strong>随着体能的下降，调动同等注意力所消耗的体能也会越来越多。</strong></p>\n<p>还有一点也需要留意——<strong>你工作环境的含氧量也会直接影响你的注意力和身体机能</strong>，其原理与体能和注意力的关系差不多。</p>\n<h2 id=\"如何保持专注\"><a href=\"#如何保持专注\" class=\"headerlink\" title=\"如何保持专注\"></a>如何保持专注</h2><h4 id=\"不要脱离主窗口\"><a href=\"#不要脱离主窗口\" class=\"headerlink\" title=\"不要脱离主窗口\"></a>不要脱离主窗口</h4><p>大多数人的日常工作都需要借助电脑实现，窗口管理就成了保持专注的重要途径。如果你需要保持专注，需要着重注意两点：让窗口面积与你需要投入的注意力相匹配，以及避免在多个主窗口之间切换。</p>\n<p><strong>内容占据的视觉面积与注意力的投入程度呈现正相关。</strong> 因此，如果你当前工作主要在一个工具内进行（譬如专心进行写作），那就把这个工具的窗口最大化，或让它覆盖绝大部分显示面积，引导视线和大脑集中在主窗口中。如果你的工作需要用到多个工具（譬如一边用浏览器查找资料，一边用笔记工具记录），就利用窗口管理工具，将主窗口并行排列。</p>\n<p>要用到的工具很多，也就意味着注意力流失的出口也很多，很容易出现「明明只是要查个词，结果打开浏览器就收不住了」的情况。因此，我会将文章编辑器保持在萤幕主体，其它辅助工具都缩放为小方块，以悬浮窗口的方式放在主窗口周边。另外，如果其它辅助工具能够以启动器、快捷键、菜单栏等方式启动和使用，就优先使用这些方式，尽可能减少辅助工具对主窗口的影响。</p>\n<p>避免在多个主窗口之间切换的目的是减少跳出主窗口的次数，不给注意力被其它元素吸引走的机会。在不影响工作效率的前提下，尽可能使用 app 的全屏模式，增加切换窗口的视觉和操作成本，逐渐习惯在一个单一窗口中使用工具的感觉。</p>\n<h4 id=\"建立心理路径\"><a href=\"#建立心理路径\" class=\"headerlink\" title=\"建立心理路径\"></a>建立心理路径</h4><p>最集中的问题是「使用社交工具很容易打断当前的工作思路」，具体表现为两种情况：其一是 app 内部的路径中断，譬如你想跟小张对接一下工作安排，打开微信之后发现有三条来自小王的消息，回复之后你就完全忘记了要找小张聊天这回事；其二是 app 之间的路径中断，譬如你在微博上看到一个有趣的商品，想上淘宝搜索一下，但退出微博、打开淘宝之后，虽然只过了短短的几秒钟，却已经忘记了自己要搜什么。</p>\n<p>如果你认真阅读了上文提到的关于记忆和专注的原理就不难明白，<strong>我们大脑的临时缓存能力就是这么脆弱，连几秒钟的事情都无法保持连续记忆</strong></p>\n<p>建立心理路径这个名字听上去很学术，实操起来却很简单：利用大脑喜欢追踪简单目标的特点，先在心里确认自己要做的事——哪怕是件小事——然后再执行具体动作。<br>以用微信回复工作消息这件事为例。如果你打开微信的目的是找小张对接一项事务，那在点进微信前先深吸一口气，同时在脑内跟自己确认一下「我要找小张聊工作」这个目标。之后再打开微信，无视一切红点、提示或消息推送，<strong>通过搜索框找到小张的名字</strong>，点进去把你要发起的话题告诉对方。</p>\n<p>一旦这个过程开始了，大脑就会自动建立「找小张聊工作」这个任务的标记，你会在之后的一段时间里一直记着它，大脑和身体都不容易脱线。</p>\n<p><em>事实上，GTD 体系里强调「先把一切想法丢进 Inbox 里」，就是利用了大脑的这个特点。只是在实际操作中，如果连微信上临时找个人这样的事都要先丢进 To-do 应用，未免流程太长。而且很可能在你打开 To-do 应用的时候就已经忘了自己要干吗，得不偿失。因此，调动大脑的缓存机制，采取口中默念无疑是更实际的选择。</em></p>\n<h4 id=\"先吃一个青蛙\"><a href=\"#先吃一个青蛙\" class=\"headerlink\" title=\"先吃一个青蛙\"></a>先吃一个青蛙</h4><p>基于「将工作难度与注意力的投入相匹配」的原则，我想推荐一个完全改变了我的工作习惯的理论——吃青蛙理论。工作中，总有一些事务是你最不想做的，它们可能很琐碎，也可能很复杂，每当你想起来这些工作你就头大。为了不完成这些困难的工作，你可能会磨磨蹭蹭地做一些零碎或边缘的工作，迟迟不愿意直奔主题，不仅浪费时间，而且会导致拖延。</p>\n<p>吃青蛙理论的核心内容即：每天最先从这些恶心的工作开始，一旦最难的工作完成了，之后的工作其实就没有那么难了——麻烦的工作就像青蛙，你会因为恶心而不愿意吃掉它，但一旦吃掉了，最大的麻烦也就解决了。这个过程很像登山，如果你在精力最旺盛的时候一口气登上山顶，之后的路就都是下坡，越走越顺。反之，如果你总觉得山太高而不断在山脚下徘徊，等你最终下定决心登山的时候，即使有心气，可能也已经没体力了。</p>\n<p>在实践中，我还会配合「先做五分钟」的技巧一起进行。人们之所以不想一上来就做困难或复杂的工作，往往是因为项目体系过于庞大，觉得自己无从下手。在这种情况下，可以引导自己「先做五分钟」，从一点点基础的准备工作做起。譬如我今天需要做一份 PPT，头五分钟我会先建立文档，选一个风格或模板，把每个大板块的标题输入进去，或者大致构思一下 PPT 的结构。五分钟过完后，其实我已经进入了状态，工作也会持续细化，进入对细节的填充和完善阶段。<br>——人的思维是具有连贯性的，一旦任务开始了，大脑就会不断思考下一步该做什么，当五分钟过去的时候，你已经进入了专注工作的状态。</p>\n<p>正如前文所言，吃青蛙理论是对我工作习惯影响最大的理论之一，在安排每日工作的时候，我也会选出一件「今日必行」的重点工作，并且把它放在我状态最好的时段来做。</p>\n<h4 id=\"提升工作难度\"><a href=\"#提升工作难度\" class=\"headerlink\" title=\"提升工作难度\"></a>提升工作难度</h4><p>在实际工作中，不是每天都有复杂或者困难的工作要做。很多时候，每天的日程就是一堆琐碎事务的集合。在这种情况下，我会使用吃青蛙理论的衍生技巧——提升工作难度。</p>\n<p>相信你或多或少都有过这样的经历——突然想起一件非常紧急且还没完成的事，然后马上就开始着手追赶 deadline。在这个过程中，你会推掉一切打扰你的人和事，并且调动大脑的全部专注力，飞快地把工作完成。</p>\n<p>如果逆向解构这个过程就不难发现，<strong>你之所以可以快速进入一种极致专注状态，原因在于工作的难度突然上升了</strong>——你需要在两个小时内完成以前一两天才能搞定的事务。在这样的前提下，你的全身都进入了一种类似应激的状态，大脑也开始全速运转，让你能在规定的时间内完成任务，避免挨骂。</p>\n<p>应激状态是无法持久的，你也不能做每件事都强迫自己马上搞定。不过，背后的原理却可以借鉴——在工作中主动提升难度，可以让你的大脑投入更多精力用于思考，你的专注度也可以得到提升。</p>\n<p>提高工作难度的具体方案要根据你所做的工作灵活变通，通常来说，我提高工作难度的方式有两个方向，分别是「做多」和「做细」。</p>\n<p><strong>「做多」指在规定的工作量基础上给自己增加额外的任务。</strong> 以少数派的一项常规工作——编辑社区文章——为例。按照我派的推荐规则，由社区推荐至首页的文章，责编通常只需要进行排版、错别字方面的修改，不需要调整原文内容。但我通常会在基础工作之外帮作者微调一下语病和表达，让整体观感更为通顺。此外，我也会在时间允许的前提下重新制作文章题图，甚至帮作者换掉原文中清晰度不够高的图片。这项额外工作大概要多花时间 20% 到 30% 的排稿时间，但我的工作状态却从「简单改改」变成了「全情投入」，投入度和工作成果都截然不同。</p>\n<p><strong>「做细」指在工作中更加细致地解构工作内容，并在一些细节问题上投入更多时间和精力。</strong> 以剪辑少数派的播客为例，大部分播客制作者都会在所有剪辑工作完成后统一进行一个名为「压缩」（compress）的步骤，目的是防止某些高音响度突然提升，影响听感。但我则会针对每一条音轨单独压缩，并且匹配每个讲话者适合的压缩强度（因为压缩也有类似调节 EQ 的效果）。从结果上来看，这样的调整其实差别不大，但分轨操作可以让我在执行剪辑工作时思维更有条理，也会因为要为嘉宾匹配合适他的音色而更为仔细地收听音轨内容，提升了我的专注程度。</p>\n<h4 id=\"把重复性工作变成习惯\"><a href=\"#把重复性工作变成习惯\" class=\"headerlink\" title=\"把重复性工作变成习惯\"></a>把重复性工作变成习惯</h4><p>我们在前文中多次提到，大脑无法把注意力平摊给每件事，总要选出重点。另一方面，如果能把日常工作中反复出现的重复性动作变成习惯或下意识行为，就能极大地节约注意力资源，减少这些事务对注意力的消耗。</p>\n<p>有个很好的例子可以解释这件事：如果你去到一个陌生的城市，你需要去往的每个地点的大部分注意力可能都用在了找路上——看地图、找路标、判断方向等。但如果你只是从公司回家，那全程对你来说轻车熟路，你一路上刷手机、听音乐、看风景，只借助下意识地行走就能把自己平安地带回家里。</p>\n<p>回到工作中，想要把常规动作变成习惯或下意识行为，可以从几个方向出发：</p>\n<ul>\n<li><strong>在固定时间做固定事务，</strong> 譬如每天上午 9 点做当日工作计划、每月 5 号的 17: 00 做月度工作总结等。人体有一套天然的时间感应系统，将固定时间与固定行动绑定之后，身体会在对应时刻自动进入相应状态，大脑也会提醒自己「该做这个了」。</li>\n<li><strong>重复、大量练习，形成肌肉记忆和视觉记忆。</strong> 许多刚步入职场或者还在实习阶段的新人往往更容易觉得工作琐碎或繁杂，原因之一就是几乎大部分工作流程对他们来说都是全新的，每前进一步都需要投入大量精力进行尝试和学习。解决这个问题的唯一方式就是重复、持续地做相同或类似的工作，一段时间后就能掌握这项任务的诀窍和捷径，部分工作流程也能形成肌肉记忆和视觉记忆。如果你在工作中需要高频用到某些工具，那可以利用私下时间大量使用它们（<strong>甚至学习一些超出你工作范围的技巧和案例</strong>）。虽然前期会让你花费更多精力，但熟练之后带来的是持续性的效率提升。</li>\n<li><strong>设计一套自己专属的工作流程和操作规范。</strong> 虽然大部分工作岗位都有着大体明确的工作目标和方向，但具体到你个人，还是有很多主观的操作空间。你可以找个时间把自己所有工作项目里的常规性工作与特殊性工作做个区隔，并给不同类型的任务制定相应的、适合自己的工作流程和操作规范。实际工作中，你遵循流程来逐个完成，这样不仅可以让大脑逐步适应每种任务的节奏，还能避免遗漏某些细节。</li>\n</ul>\n<h2 id=\"注意力是可以训练的\"><a href=\"#注意力是可以训练的\" class=\"headerlink\" title=\"注意力是可以训练的\"></a>注意力是可以训练的</h2><p>就像长期跑步能提升体能，<strong>长期处于专注状态也能提升注意力的持久度和专注度。</strong>不仅如此，如果你习惯了在高度专注的状态下完成工作，你的大脑也能更快地在普通模式和专注模式下切换，调动注意力的成本会逐渐降低。</p>\n<p>锻炼注意力没有特别的方法，或者说，我们以上的整篇报告其实都是在讲锻炼注意力的方法。提高注意力的核心就是多调动它、使用它，让自己每天都有一段时间处于高度专注的状态中，也让你的大脑清楚地意识到，它有那么多的注意力资源可以随时调配，听你安排。</p>\n<p>还记得我们刚刚讲过的那个注意力上限的测试方法吗？你可以每隔一段时间就进行一次测试（但频率不要太高，每隔几个月、半年甚至一年测一次皆可），看看自己注意力的持续性有怎样的变化。在工作、学习和生活中，你也可以随时从当下跳脱出来，以上帝视角观察一下自己做事时专注度与行为上的变化，及时调整。</p>\n<p><strong>正如绝大部分人的智力都处于一个不错的水平上一样，绝大部分人的注意力也都能达到很高的水准。</strong>如果你在实际的工作和学习中受到了注意力方面的困扰，就利用我们今天谈到的原理和方法，改善环境，自我调节，找回自己的专注力吧。</p>\n<p>而且，即使像我这样一个注意力缺失者，也能利用三个专注周期一鼓作气写完这篇长且枯燥的文章。你要相信你一定可以做得更好，&#x3D;&#x3D;只要你愿意，没人可以打断你。&#x3D;&#x3D;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>注意力是一种资源，正确使用它的方式是将要做的任务的复杂程度与之相匹配，在精神最佳、状态最好的时候完成最重要的任务。</li>\n<li>大脑喜欢简单、明确的指令和任务，任务目标越清楚，大脑越容易进入专注状态。</li>\n<li>使用注意力会消耗体能，吃饱饭、睡好觉、多锻炼，都可以有效提升注意力的上限。</li>\n<li>注意力不是恒定不变，而是在时刻波动的。短暂的跑神可以让大脑得到休息，要主动提醒自己回到焦点，保持专注。</li>\n<li>注意力就像摄影，找到目标之后要通过建立心理路径将焦点锁定，避免大脑受到其它元素干扰而脱离主线。</li>\n<li>注意力和身体素质一样，越锻炼越强壮，越使用越熟练。</li>\n</ul>\n",
            "tags": [
                "文章",
                "效率"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html",
            "url": "https://asterzc19.github.io/post/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.html",
            "title": "数学知识",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<h1 id=\"试除法判定质数\"><a href=\"#试除法判定质数\" class=\"headerlink\" title=\"试除法判定质数\"></a>试除法判定质数</h1><pre><code class=\"cpp\">bool is_prime(int x)\n&#123;\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i++)\n        if (x % i == 0)\n            return false;\n    return true;\n&#125;\n</code></pre>\n<h1 id=\"试除法分解质因数\"><a href=\"#试除法分解质因数\" class=\"headerlink\" title=\"试除法分解质因数\"></a>试除法分解质因数</h1><pre><code class=\"cpp\">void divide(int x)\n&#123;\n    for (int i = 2; i &lt;= x / i; i++)&#123;\n        if (x % i == 0)&#123;\n            int s = 0;\n            while (x % i == 0) x /= i, s++;\n            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;\n        &#125;\n    &#125;\n    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n&#125;\n</code></pre>\n<h1 id=\"朴素筛法求素数\"><a href=\"#朴素筛法求素数\" class=\"headerlink\" title=\"朴素筛法求素数\"></a>朴素筛法求素数</h1><pre><code class=\"cpp\">int primes[N], cnt;    // primes[]存储所有素数\nbool st[N];    // st[x]存储x是否被筛掉\nvoid get_primes(int n)\n&#123;\n    for (int i = 2; i &lt;= n; i++)&#123;\n        if (st[i]) continue;\n        primes[cnt++] = i;\n        for (int j = i + i; j &lt;= n; j += i)&#123;\n            st[j] = true;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"线性筛法求素数\"><a href=\"#线性筛法求素数\" class=\"headerlink\" title=\"线性筛法求素数\"></a>线性筛法求素数</h1><pre><code class=\"cpp\">int primes[N], cnt;\nbool st[N];\nvoid get_primes(int n)\n&#123;\n    st[1] = true;\n    for (int i = 2; i &lt;= n; i++)&#123;\n        if (!st[i]) primes[cnt++] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j++)&#123;\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n         &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"试除法求所有约数\"><a href=\"#试除法求所有约数\" class=\"headerlink\" title=\"试除法求所有约数\"></a>试除法求所有约数</h1><pre><code class=\"cpp\">vector&lt;int&gt; get_divisors(int x)\n&#123;\n    vector&lt;int&gt; res;\n    for (int i = 1; i &lt;= x / i; i++)&#123;\n        if (x % i == 0)&#123;\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);\n        &#125;\n    &#125;\n    sort(res.begin(), res.end());\n    return res;\n&#125;\n</code></pre>\n<h1 id=\"约数个数和约数之和\"><a href=\"#约数个数和约数之和\" class=\"headerlink\" title=\"约数个数和约数之和\"></a>约数个数和约数之和</h1><p>如果<br>$$N &#x3D; {p_{1}}^{c_{1}} \\times {p_{2}}^{c_{2}} \\times … \\times {p_{k}}^{c_{k}}$$<br>约数个数：<br>$${(c_1 + 1)} \\times {(c_2 + 1)} \\times … \\times {(c_k + 1)}$$<br>&#x2F;&#x2F; 配合秦九韶算法 [[870. 约数个数]]</p>\n<p>约数之和：<br>$${((p_1^0) + (p_1^1) + … + ({p_{1}}^{c_{1}})} \\times … \\times {((p_k^0) + (p_k^1) + … + ({p_{k}}^{c_{k}})}$$<br>&#x2F;&#x2F; [[871. 约数之和]]</p>\n<h1 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h1><pre><code class=\"cpp\">int gcd(int a, int b)\n&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\n</code></pre>\n<h1 id=\"求欧拉函数\"><a href=\"#求欧拉函数\" class=\"headerlink\" title=\"求欧拉函数\"></a>求欧拉函数</h1><pre><code class=\"cpp\">int phi(int x)\n&#123;\n    int res = x;\n    for (int i = 2; i &lt;= x / i; i++)&#123;\n        if (X % i == 0)&#123;\n            res = res / i * (i - 1);\n            while (x % i == 0) x /= i;\n        &#125;\n    &#125;\n    if (x &gt; 1) res = res / x * (x - 1);\n    \n    return res;\n&#125;\n</code></pre>\n<h1 id=\"筛法求欧拉函数\"><a href=\"#筛法求欧拉函数\" class=\"headerlink\" title=\"筛法求欧拉函数\"></a>筛法求欧拉函数</h1><pre><code class=\"cpp\">int primes[N], cnt;\nint euler[N];\nbool st[N];\nvoid get_eulers(int n)\n&#123;\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i++)&#123;\n        if (!st[i])&#123;\n            primes[cnt++] = i;\n            euler[i] = i - 1;\n        &#125;\n        for (int j = 0; primes[j] &lt;= n / i; j++)&#123;\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)&#123;\n                euler[t] = euler[i] * primes[j];\n                break;\n            &#125;\n            euler[t] = euler[i] * (primes[j] - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h1><h2 id=\"快速幂模板\"><a href=\"#快速幂模板\" class=\"headerlink\" title=\"快速幂模板\"></a>快速幂模板</h2><pre><code class=\"cpp\">int power(int a, int b, int p)\n&#123;\n    int res = 1 % p;\n    for (; b; b &gt;&gt;= 1)&#123;\n        if (b &amp; 1) res = (LL) res * a % p;\n        a = (LL) a * a % p;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<ul>\n<li>求  $m^k\\mod p$，时间复杂度 $O(logk)$</li>\n</ul>\n<pre><code class=\"cpp\">int qmi(int m, int k, int p)\n&#123;\n    int res = 1 % p, t = m;\n    while (k)&#123;\n        if (k &amp; 1) res = res * t % p;\n        t = t * t % p;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h2 id=\"快速幂求逆元\"><a href=\"#快速幂求逆元\" class=\"headerlink\" title=\"快速幂求逆元\"></a>快速幂求逆元</h2><p>因为 $$ax \\equiv (mod ; b)$$ 所以 (费马小定理) $$ax \\equiv a^{b-1}(mod ; b)$$ 所以 $$x \\equiv a^{b-2}(mod ; b)$$  (b 为质数)</p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nLL qmi(LL a, LL b, LL p)\n&#123;\n    LL res = 1;\n    while (b)&#123;\n        if (b &amp; 1) res = res * a % p;\n        a = a * a % p;\n        b &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint main()\n&#123;\n    cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int n;\n    cin &gt;&gt; n;\n    while(n--)&#123;\n        LL a, p;\n        cin &gt;&gt; a &gt;&gt; p;\n        if(a % p == 0) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;\n        else cout &lt;&lt; qmi(a, p - 2, p) &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a>扩展欧几里得算法</h1><pre><code class=\"cpp\">// 求x, y, 使得 ax + by = gcd(a, b)\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if (!b)&#123;\n        x = 1, y = 0;\n        return a;\n    &#125;\n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;\n    return d;\n&#125;\n</code></pre>\n<p>[[线性同余方程]]</p>\n<h1 id=\"高斯消元\"><a href=\"#高斯消元\" class=\"headerlink\" title=\"高斯消元\"></a>高斯消元</h1><pre><code class=\"cpp\">// a[N][N]是增广矩阵\nint gauss()&#123;\n    int c, r;\n    for (c = 0, r = 0; c &lt; n; c++)&#123;\n        int t = r;\n        for (int i = r; i &lt; n; i++)&#123;\t\t// 找到绝对值最大的行\n            if (fabs(a[i][c]) &gt; fabs(a[t][c]))\n                t = i;\n        &#125;\n        if (fabs(a[t][c]) &lt; eps) continue;\n        // 将绝对值最大的行换到最顶端\n        for (int i = c; i &lt;= n; i++) swap(a[t][i], a[r][i]);\n        // 将当前行的首位变成 1\n        for (int i = n; i &gt;= c; i--) a[r][i] /= a[r][c];\n        // 用当前行将下面所有的列消成 0\n        for (int i = r + 1; i &lt; n; i++)&#123;\n            if (fabs(a[i][c]) &gt; eps)&#123;\n                for(int j = n; j &gt;= c; j--)&#123;\n                    a[i][j] -= a[r][j] * a[i][c];\n                &#125;\n            &#125;\n        &#125;\n        r++;\n    &#125;\n    \n    if (r &lt; n)&#123;\n        for (int i = r; i &lt; n; i++)&#123;\n            if (fabs(a[i][n]) &gt; eps)&#123;\n                return 2;    // 无解\n            &#125;\n        &#125;\n        return 1;    // 有无穷多组解\n    &#125;\n    \n    for (int i = n - 1; i &gt;= 0; i--)&#123;\n        for (int j = i + 1; j &lt; n; j++)&#123;\n            a[i][n] -= a[i][j] * a[j][n];\n        &#125;\n    &#125;\n    return 0; // 有唯一解\n&#125;\n</code></pre>\n<h1 id=\"递归法求组合数\"><a href=\"#递归法求组合数\" class=\"headerlink\" title=\"递归法求组合数\"></a>递归法求组合数</h1><pre><code class=\"cpp\">// c[a][b] 表示从a个苹果中选b个的方案数\nfor (int i = 0; i &lt; N; i++)&#123;\n    for (int j = 0; j &lt;= i; j++)&#123;\n        if (!j) c[i][j] = 1;\n        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"通过预处理逆元的方法求组合数\"><a href=\"#通过预处理逆元的方法求组合数\" class=\"headerlink\" title=\"通过预处理逆元的方法求组合数\"></a>通过预处理逆元的方法求组合数</h1><pre><code class=\"cpp\">首先预处理出所有阶乘取模的余数 fact[N]，以及所有阶乘取模的逆元 infact[N]\n如果取模的数是质数，可以用费马小定理求逆元\nint qmi(int a, int k, int p)&#123;    // 快速幂模板\n    int res = 1;\n    while (k)&#123;\n        if (k &amp; 1) res = (LL)res * a % p;\n        a = (LL)a * a % p;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\n\n// 预处理阶乘的余数和阶乘逆元的余数\nfact[0] = infact[0] = 1;\nfor (int i = 1; i &lt; N; i++)&#123;\n    fact[i] = (LL)fact[i - 1] * i % mod;\n    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;\n&#125;\n</code></pre>\n<h1 id=\"Lucas-定理\"><a href=\"#Lucas-定理\" class=\"headerlink\" title=\"Lucas 定理\"></a>Lucas 定理</h1><pre><code class=\"cpp\">若 p 是质数，则对于任意整数 1 &lt;= m &lt;= n，有：\n    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)\nint qmi(int a, int k, int p)&#123;\t// 快速幂模板\n    int res = 1 % p;\n    while (k)&#123;\n        if (k &amp; 1) res = (LL)res * a % p;\n        a = (LL)a * a % p;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\n\nint C(int a, int b, int p)&#123; \t// 通过定理求组合数C(a, b)\n    if (a &lt; b) return 0;\n    LL x = 1, y = 1;\t// x 是分子，y 是分母\n    for (int i = a, j = 1; j &lt;= b; i--, j++)&#123;\n        x = (LL)x * i % p;\n        y = (LL)y * j % p;\n    &#125;\n    return x * (LL)qmi(y, p - 2, p) % p;\n&#125;\n\nint lucas(LL a, LL b, int p)&#123;\n    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);\n    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n&#125;\n</code></pre>\n<h1 id=\"分解质因数法求组合数\"><a href=\"#分解质因数法求组合数\" class=\"headerlink\" title=\"分解质因数法求组合数\"></a>分解质因数法求组合数</h1><pre><code class=\"cpp\">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n    1. 筛法求出范围内的所有质数\n    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...\n    3. 用高精度乘法将所有质因子相乘\nint primes[N], cnt;\t\t// 存储所有质数\nint sum[N];\t\t// 存储每个质数的次数\nbool st[N];\t\t// 存储每个数是否已被筛掉\nvoid get_primes(int n)&#123;\t\t// 线性筛法求素数\n    for (int i = 2; i &lt;= n; i++)&#123;\n        if (!st[i]) primes[cnt++] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j++)&#123;\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        &#125;\n    &#125;\n&#125;\n\nint get(int n, int p)&#123;\t\t// 求 n! 中的次数\n    int res = 0;\n    while (n)&#123;\n        res += n / p;\n        n /= p;\n    &#125;\n    return res;\n&#125;\n\nvector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;\t\t// 高精度乘低精度模板\n    vector&lt;int&gt; c;\n    int t = 0;\n    for (int i = 0; i &lt; a.size(); i++)&#123;\n        t += a[i] * b;\n        c.push_back(t % 10);\n        t /= 10;\n    &#125;\n    while (t)&#123;\n        c.push_back(t % 10);\n        t /= 10;\n    &#125;\n    return c;\n&#125;\n\nget_primes(a);\t\t// 预处理范围内的所有质数\n\nfor (int i = 0; i &lt; cnt; i++)&#123;\t\t// 求每个质因数的次数\n    int p = primes[i];\n    sum[i] = get(a, p) - get(b, p) - get(a - b, p);\n&#125;\n\nvector&lt;int&gt; res;\nres.push_back(1);\n\nfor (int i = 0; i &lt; cnt; i++)&#123;\t\t// 用高精度乘法将所有质因子相乘\n    for (int j = 0; j &lt; sum[i]; j++)&#123;\n        res = mul(res, primes[i]);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"卡特兰数\"><a href=\"#卡特兰数\" class=\"headerlink\" title=\"卡特兰数\"></a>卡特兰数</h1><pre><code class=\"cpp\">给定 n 个 0 和 n 个 1，它们按照某种顺序排成长度为 2n 的序列，满足任意前缀中 0 的个数都不少于 1 的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\n</code></pre>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9zb2x1dGlvbi9jb250ZW50Lzg5MDcv\">卡特兰数例题及转换方式</span></li>\n</ul>\n<h1 id=\"NIM-游戏\"><a href=\"#NIM-游戏\" class=\"headerlink\" title=\"NIM 游戏\"></a>NIM 游戏</h1><ul>\n<li>给定 $n$ 堆物品，第 $i$ 堆物品有 $A_i$ 个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</li>\n<li>我们把这种游戏称为 <strong>Nim博弈</strong> 。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。</li>\n<li>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。</li>\n<li><strong>NIM博弈</strong> 不存在平局，只有先手必胜和先手必败两种情况。</li>\n<li>定理<ul>\n<li><strong>NIM博弈</strong> 先手必胜，当且仅当 $A_1 \\oplus A_2 \\oplus … \\oplus A_n \\ne 0$</li>\n<li>$XOR ; \\oplus$ 相当于不带进位的二进制加法。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"公平组合游戏-ICG\"><a href=\"#公平组合游戏-ICG\" class=\"headerlink\" title=\"公平组合游戏 ICG\"></a>公平组合游戏 ICG</h1><ul>\n<li>若一个游戏满足：<ol>\n<li>由两名玩家交替行动。</li>\n<li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关。</li>\n<li>不能行动的玩家判负。</li>\n</ol>\n</li>\n<li>则称该游戏为一个公平组合游戏。</li>\n<li><strong>NIM博弈</strong> 属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件 <em>2</em> 和条件 <em>3</em>。</li>\n</ul>\n<h1 id=\"有向图游戏\"><a href=\"#有向图游戏\" class=\"headerlink\" title=\"有向图游戏\"></a>有向图游戏</h1><ul>\n<li>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。</li>\n<li>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</li>\n</ul>\n<h1 id=\"Mex-运算\"><a href=\"#Mex-运算\" class=\"headerlink\" title=\"Mex 运算\"></a>Mex 运算</h1><ul>\n<li>设 $S$ 表示一个非负整数集合。定义 $MEX(S)$ 为求出不属于集合 $S$ 的最小非负整数的运算，即：$MEX(S) &#x3D; MIN(x)$，$x$ 属于自然数，且 $x$ 不属于 $S$ 。</li>\n</ul>\n<h1 id=\"SG-函数\"><a href=\"#SG-函数\" class=\"headerlink\" title=\"SG 函数\"></a>SG 函数</h1><ul>\n<li>在有向图游戏中，对于每个节点 $x$ ，设从 $x$ 出发共有 $k$ 条有向边，分别到达节点 $y_1, y_2, … , y_k$，定义 $SG(x)$ 为 $x$ 的后继节点 $y_1, y_2, … , y_k$ 的 $SG$ 函数值构成的集合再执行 $MEX(S)$ 运算的结果，即：$SG(x) &#x3D; MEX({[SG(y_1), SG(y_2), …, SG(y_k)]})$ 。</li>\n<li>特别的，整个有向图游戏 $G$ 的 $SG$ 函数值被定义为有向图游戏起点 $s$ 的 $SG$ 函数值，即 $SG(G) &#x3D; SG(s)$ 。</li>\n</ul>\n<h1 id=\"有向图游戏的和\"><a href=\"#有向图游戏的和\" class=\"headerlink\" title=\"有向图游戏的和\"></a>有向图游戏的和</h1><ul>\n<li>设 $G_1, G_2, … , G_m$ 是 $m$ 个有向图游戏。定义有向图游戏 $G$ ，它的行动规则是任选某个有向图游戏 $G_i$ ，并在 $G_i$ 上行动一步。$G$ 被称为有向图游戏 $G_1, G_2, … , G_m$ 的和。</li>\n<li>有向图游戏的和的 $SG$ 函数值等于它包含的各个子游戏 $SG$ 函数值的异或和，即：$SG(G) &#x3D; SG(G_1) ; \\oplus ; SG(G_2) ; \\oplus; …; \\oplus ; SG(G_m)$</li>\n</ul>\n<h1 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h1><ul>\n<li>有向图游戏的某个局面必胜，当且仅当该局面对应节点的 $SG$ 函数值大于 $0$ 。</li>\n<li>有向图游戏的某个局面必败，当且仅当该局面对应节点的 $SG$ 函数值等于 $0$ 。</li>\n</ul>\n<h1 id=\"额外的小知识\"><a href=\"#额外的小知识\" class=\"headerlink\" title=\"额外的小知识\"></a>额外的小知识</h1><ol>\n<li>$a ; mod ; b$ 取得最大时 $b &#x3D; \\left \\lfloor \\frac{a}{2} \\right \\rfloor  + 1$ , 模数是 $\\left \\lfloor \\frac{a - 1}{2} \\right \\rfloor$ 。</li>\n</ol>\n<ul>\n<li>小证明：<ul>\n<li>设 $y &#x3D; kx + b ; (k\\ge 1， b &lt; k)$</li>\n<li>$y &#x3D; kx + b &gt; b + b &#x3D; 2b$</li>\n<li>$b$ $&lt;$ $\\frac{y}{2};$</li>\n<li>证毕。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "题集"
            ]
        },
        {
            "id": "https://asterzc19.github.io/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html",
            "url": "https://asterzc19.github.io/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B.html",
            "title": "线性同余方程",
            "date_published": "2022-02-12T10:00:20.000Z",
            "content_html": "<p>题意：给定 $n$ 组数据 $a_i, b_i, m_i$，对于每组数求出一个 $x_i$，使其满足 $a_i \\times x_i \\equiv b_i ( mod (m_i) )$，如果无解则输出 <code>impossible</code></p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nint x, y;\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if(!b)&#123;\n        x = 1, y = 0;\n        return a;\n    &#125;\n    int d = exgcd(b, a % b, y, x);\n    y -= a/b * x;\n    return d;\n&#125;\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    while(n--)&#123;\n        int a, b, m;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;\n        int d = exgcd(a, m, x, y);\n        if(b % d) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;\n        else cout &lt;&lt; ((LL)x * (b / d) % m + m) % m &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "AcWing",
                "题解"
            ]
        }
    ]
}